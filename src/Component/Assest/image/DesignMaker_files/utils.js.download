// var server_path; var static_file_server_path
// if(window['globalThis'] && window['globalThis'].config){
//     server_path = globalThis.config.server_path
//     static_file_server_path = globalThis.config.static_file_server_path
// }else if(window['config'] && window['config'].server_path){
//     server_path = config.server_path
//     static_file_server_path = config.static_file_server_path
// }else{
//     server_path = 'http://3.1.18.100:4444/'
//     static_file_server_path = 'http://3.1.18.100/'
// }


var PIXEL_RATIO = (function () {
    var ctx = document.createElement("canvas").getContext("2d"),
    dpr = window.devicePixelRatio || 1,
    bsr = ctx.webkitBackingStorePixelRatio ||
    ctx.mozBackingStorePixelRatio ||
    ctx.msBackingStorePixelRatio ||
    ctx.oBackingStorePixelRatio ||
    ctx.backingStorePixelRatio || 1;

    return dpr / bsr;
})();

function deref(obj){
    return JSON.parse(JSON.stringify(obj));
}

function findBrowser(){
	var s = navigator.userAgent.toLowerCase()
	if(s.includes('chrome')){
		return 'chrome'
	}else if(s.includes('firefox')){
		return 'firefox'
	}else if(s.includes('safari')){
		return 'safari'
	}
}

function promisify_dm_image(image_dom){
    return new Promise(function(resolve,reject){
        image_dom.onload = function(){
            resolve(image_dom);
        }

        image_dom.onerror = function(){
            resolve(image_dom);
        }
    })
}

function loadStaticImage(src,no_cache){
    return new Promise(function(resolve,reject){
        var img = new Image()
        img.crossOrigin = 'anonymous'
        var tried_proxy = false;
        img.onload = function(){
            resolve(img)
        }

        img.onerror = function(err){
            if(!tried_proxy){
                img.src = server_path.replace('api/','')+'api/image_proxy?src='+encodeURIComponent(img.src)
                tried_proxy = true
            }else{
                reject();
            }
        }

        if(src.indexOf('data:image')>-1 || src.indexOf('http')>-1 || src.indexOf('blob:')>-1){
            if(src.indexOf('123rf.com')>-1 || src.indexOf('pixlr.com')>-1 || src.indexOf('assetsdelivery.com')>-1 ){
                img.src = server_path.replace('api/','')+'api/image_proxy?src='+encodeURIComponent(src)
            }else{
                img.src = src
            }
        }else if(src.indexOf('public/')>-1){
            img.src = server_path+src;
        }else{
            if(no_cache){
                img.src = server_path+src + '?timestamp='+Date.now()
            }else{
                img.src = server_path+src
            }
        }
    }).catch(function(err){
        console.log(err)
    })
}

function fetchDesignResource(resource_id,type){
    var form_data = {}
    if(resource_id){
        form_data.id =  resource_id
    }
    if(type){
        form_data.type =  type
    }


    return fetch(server_path + 'design_resource/get', {method: 'POST',headers: {'Content-Type':'application/json'}, body:JSON.stringify(form_data)})
    .then(resp => {
        return resp.json().then((data) => {
            if(data.response_code == -1){
                return Promise.reject(data)
            }else{
                return Promise.resolve(data)
            }
            
        })
    })
    .catch(err => Promise.reject(err))
}


function syncForEach(array,stepFunction,extra_param1,extra_param2,extra_param3){
    try{
        var stack = null;
        array.forEach(function(element,index){
            if(index==0 && array.length>1){
                stack = stepFunction(element,index,extra_param1,extra_param2,extra_param3)
            }else if(index == 0 && array.length == 1){
                stack = stepFunction(element,index,extra_param1,extra_param2,extra_param3)
            }else if(index == array.length-1){
                stack = stack.then(function(response){
                    return stepFunction(element,index,extra_param1,extra_param2,extra_param3)
                })
            }else{  
                stack = stack.then(function(response){
                    return stepFunction(element,index,extra_param1,extra_param2,extra_param3)
                })
            }
        })

        if(stack!=null){
            return stack
        }else{
            return Promise.resolve(true)
        }
    }catch(err){
        console.log(err);
        return Promise.reject(err);
    }
}

function checkFontLoad(font_family){
    var font_iterator = document.fonts.entries()
    var entries = font_iterator.next();
    while(entries && entries.value){
        for(var i in entries.value){
            if(entries.value[i].family == font_family && entries.value[i].status == 'loaded'){
                return true
            }
        }

        entries = font_iterator.next();

    }
    return false
}

var existing_fonts = {}

function checkFontExists(font_family){
    if(existing_fonts[font_family]){
        return true;
    }
    
    var font_iterator = document.fonts.entries()
    var entries = font_iterator.next();
    while(entries && entries.value){
        for(var i in entries.value){
            if(entries.value[i].family == font_family){
                existing_fonts[font_family] = true
                return entries.value[i]
            }
        }

        entries = font_iterator.next();
    }

    return false;
}

function mmToPDFPoints(mm){
    //96 points per inch
    var inch = mm/25.4;
    return inch*72;
}

function addWatermark(canvas){
    return loadStaticImage('uploads/icons/watermark.png')
    .then(function(image){
        var pat_width = 150
        var pat_height = 150;
        var canvasPattern = document.createElement("canvas");
        canvasPattern.width = pat_width;
        canvasPattern.height = pat_height;
        var contextPattern = canvasPattern.getContext("2d");
        contextPattern.drawImage(image,0,0,pat_width,pat_height);
        var pattern = canvas.getContext('2d').createPattern(canvasPattern,"repeat");
        canvas.getContext('2d').fillStyle = pattern

        canvas.getContext('2d').globalAlpha = 0.2;
        canvas.getContext('2d').fillRect(0,0,canvas.width,canvas.height)
        canvas.getContext('2d').globalAlpha = 1
        return Promise.resolve(canvas)
    })
}

var bg_removal_generic = (image_raw,bgremoval) => {
    var temp_canvas = document.createElement('canvas');
    var temp_canvas2 = document.createElement('canvas');
    temp_canvas.width = image_raw.naturalWidth;/*Math.ceil(image_raw.width/2);*/
    temp_canvas.height = image_raw.naturalHeight;/*Math.ceil(image_raw.height/2);*/
    temp_canvas2.width = image_raw.naturalWidth;
    temp_canvas2.height = image_raw.naturalHeight;

    temp_canvas.getContext('2d').drawImage(image_raw,0,0,temp_canvas.width,temp_canvas.height)
    return bg_removal_compute(temp_canvas.toDataURL(),bgremoval.crf,bgremoval.matting)
    .then(function(datauri){
        return new Promise(function(resolve,reject){
            var img_temp = new Image();
            img_temp.onload = function(){
                var temp_ctx = temp_canvas.getContext('2d')
                var temp_ctx2 = temp_canvas2.getContext('2d')
                temp_ctx2.drawImage(img_temp,0, 0, temp_canvas2.width, temp_canvas2.height);
                var img_data = temp_ctx2.getImageData(0, 0, temp_canvas2.width, temp_canvas2.height);
                img_data = blackToTransparent(img_data);

                temp_ctx2.clearRect(0, 0, temp_canvas2.width, temp_canvas2.height);
                temp_ctx2.putImageData(img_data, 0, 0);

                temp_ctx.globalCompositeOperation = 'destination-in'
                temp_ctx.drawImage(temp_canvas2,0, 0, temp_canvas.width, temp_canvas.height);
                resolve(temp_canvas.toDataURL());
            }

            img_temp.onerror = function(err){
                reject(err);
            }

            img_temp.src = datauri
        })
    })
}

function bg_removal_compute(datauri,crf,matting){
    if(!datauri){
        datauri = "data:image/png;base64,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"
    }


    datauri = datauri.substring(21)
    // var query_string = "images="+encodeURIComponent("[\""+datauri+"\"]")+"&crf="+crf+"&matting="+matting
    // var target = server_path.includes('localhost')?"http://52.74.202.226:80/":server_path + 'bg_removal'
    var target = server_path + 'bg_removal';
    

    return fetch(server_path + 'bg_removal_token',{method:'POST'}).then(function(o){
        return o.json()
    }).then(function(o){
        var form_data = new FormData();
        form_data.append("token",o.message);
        form_data.append("id",3);
        form_data.append("image","\""+datauri+"\"")
        // form_data.append("images","[\""+datauri+"\"]")
        // form_data.append("crf",0);
        // form_data.append("matting",0);
        return fetch(server_path + 'bg_removal',{method:'POST',body:form_data}).then(function(resp){
            return resp.json()
        }).then(function(data){
            return Promise.resolve(
                "data:image/png;base64,"+ JSON.parse(data).mask
            )
        })
    })

    // return fetch(target, {
    //     body: /*src*/query_string,
    //     headers: {
    //     Accept: "*/*",
    //         "Content-Type": "application/x-www-form-urlencoded"
    //     },
    //     method: "POST"
    // }).then(function(resp){
    //     return resp.json()
    // }).then(function(data){
    //     if(data.ok){
    //         return Promise.resolve(
    //             "data:image/png;base64,"+ data.masks.split('["')[1].split('"]')[0]
    //         )
    //     }else{
    //         return Promise.resolve(null);
    //     }
    //     return Promise.resolve(data)
    // })
}

function removeBG(image_raw){
    return new Promise(function(rs,rj){
        var temp_canvas = document.createElement('canvas');
        var temp_canvas2 = document.createElement('canvas');
        temp_canvas.width = image_raw.width;
        temp_canvas.height = image_raw.height;
        temp_canvas2.width = image_raw.width;
        temp_canvas2.height = image_raw.height;

        var temp_canvas3 = document.createElement('canvas');
        temp_canvas3.width = image_raw.width;
        temp_canvas3.height = image_raw.height;

        temp_canvas.getContext('2d').drawImage(image_raw,0,0,temp_canvas.width,temp_canvas.height)
        temp_canvas3.getContext('2d').drawImage(image_raw,0,0,temp_canvas3.width,temp_canvas3.height)
        bg_removal_compute(temp_canvas.toDataURL(),0,0)
        .then(function(datauri){
            var img_temp = new Image();
            img_temp.onload = function(){
                var temp_ctx = temp_canvas.getContext('2d')
                var temp_ctx2 = temp_canvas2.getContext('2d')
                var temp_ctx3 = temp_canvas3.getContext('2d')
                temp_ctx2.drawImage(img_temp,0, 0, temp_canvas2.width, temp_canvas2.height);
                var img_data = temp_ctx2.getImageData(0, 0, temp_canvas2.width, temp_canvas2.height);
                img_data = blackToTransparent(img_data);

                temp_ctx2.clearRect(0, 0, temp_canvas2.width, temp_canvas2.height);
                temp_ctx2.putImageData(img_data, 0, 0);

                temp_ctx.globalCompositeOperation = 'destination-in'
                temp_ctx.drawImage(temp_canvas2,0, 0, temp_canvas.width, temp_canvas.height);

                temp_ctx3.globalCompositeOperation = 'destination-out'
                temp_ctx3.drawImage(temp_canvas2,0, 0, temp_canvas3.width, temp_canvas3.height);
                rs({
                    foreground: temp_canvas.toDataURL(),
                    background: temp_canvas3.toDataURL()
                })
            }
            img_temp.src = datauri
        })
    })
}

function getIndicesOfSubstring(searchStr, str, caseSensitive) {
    var searchStrLen = searchStr.length;
    if (searchStrLen == 0) {
        return [];
    }
    var startIndex = 0, index, indices = [];
    if (!caseSensitive) {
        str = str.toLowerCase();
        searchStr = searchStr.toLowerCase();
    }
    while ((index = str.indexOf(searchStr, startIndex)) > -1) {
        indices.push(index);
        startIndex = index + searchStrLen;
    }
    return indices;
}

function fetchFileSrc(dom_id) {
    return new Promise(function(resolve,reject){
        var file    = document.getElementById(dom_id).files[0]
        var reader  = new FileReader();

        reader.onloadend = function () {
            resolve(reader.result)
        }

        if (file) {
            reader.readAsDataURL(file);
        } else {
            resolve("")
        }
    }).catch(function(err){
        console.log(err);
    })
}


function fetchFileSrcWithFile(file) {
    return new Promise(function(resolve,reject){
        var reader  = new FileReader();

        reader.onloadend = function () {
            resolve(reader.result)
        }

        if (file) {
            reader.readAsDataURL(file);
        } else {
            resolve("")
        }
    }).catch(function(err){
        console.log(err);
    })
}

utils = {};

utils.pointDistanceFromLineSegment  = function( x, y, x1, y1, x2, y2 ) {

    var point = utils.closestPointOnLineSegment(x, y, x1, y1, x2, y2);
    var dx = x - point.x;
    var dy = y - point.y;
    return Math.sqrt(dx * dx + dy * dy);
}

utils.uuidv4 = function() {
  return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, function(c) {
    return (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
  })
}

utils.angleOfLine = function(point1,point2){
    return Math.atan2(point2.y-point1.y,point2.x-point1.x);
}

utils.closestPointOnLineSegment = function(x, y, x1, y1, x2, y2) {
    // thanks, http://stackoverflow.com/a/6853926
    var A = x - x1;
    var B = y - y1;
    var C = x2 - x1;
    var D = y2 - y1;

    var dot = A * C + B * D;
    var len_sq = C * C + D * D;
    var param = dot / len_sq;

    var xx, yy;

    if (param < 0 || (x1 == x2 && y1 == y2)) {
        xx = x1;
        yy = y1;
    } else if (param > 1) {
        xx = x2;
        yy = y2;
    } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
    }

    return {
        x: xx,
        y: yy
    }
}

utils.arcLineIntersection = function(center,radius,a,b,c){
    //a,b,c is part of ax + by + c = 0

    var intersectionAngle1 =  Math.atan(b/a) + (Math.acos( -(a*center.x + b*center.y + c)/(radius*Math.sqrt(a*a + b*b)) ))
    var intersectionAngle2 =  Math.atan(b/a) - (Math.acos( -(a*center.x + b*center.y + c)/(radius*Math.sqrt(a*a + b*b)) ))

    var intersectionAngle3 =  Math.atan(b/a) + (Math.acos( -(a*center.x + b*center.y + c)/(radius*Math.sqrt(a*a + b*b)) )) + Math.PI
    var intersectionAngle4 =  Math.atan(b/a) - (Math.acos( -(a*center.x + b*center.y + c)/(radius*Math.sqrt(a*a + b*b)) )) + Math.PI

    var intersections = [
        {x: center.x + Math.cos(intersectionAngle1)*radius ,y: center.y + Math.sin(intersectionAngle1)*radius},
        {x: center.x + Math.cos(intersectionAngle2)*radius ,y: center.y + Math.sin(intersectionAngle2)*radius},
        {x: center.x + Math.cos(intersectionAngle3)*radius ,y: center.y + Math.sin(intersectionAngle3)*radius},
        {x: center.x + Math.cos(intersectionAngle4)*radius ,y: center.y + Math.sin(intersectionAngle4)*radius}
    ]

    intersections = intersections.filter(function(o){
        return Math.abs(a*o.x + b*o.y + c)<0.0001
    })
    return intersections
}

utils.arcArcIntersection = function(center1,r1,center2,r2) {
    var x1 = center1.x; var y1 = center1.y
    var x2 = center2.x; var y2 = center2.y

    var centerdx = x1 - x2;
    var centerdy = y1 - y2;
    var R = Math.sqrt(centerdx * centerdx + centerdy * centerdy);
    if (!(Math.abs(r1 - r2) <= R && R <= r1 + r2)) { // no intersection
        return []; // empty list of results
    }
    // intersection(s) should exist

    var R2 = R*R;
    var R4 = R2*R2;
    var a = (r1*r1 - r2*r2) / (2 * R2);
    var r2r2 = (r1*r1 - r2*r2);
    var c = Math.sqrt(2 * (r1*r1 + r2*r2) / R2 - (r2r2 * r2r2) / R4 - 1);

    var fx = (x1+x2) / 2 + a * (x2 - x1);
    var gx = c * (y2 - y1) / 2;
    var ix1 = fx + gx;
    var ix2 = fx - gx;

    var fy = (y1+y2) / 2 + a * (y2 - y1);
    var gy = c * (x1 - x2) / 2;
    var iy1 = fy + gy;
    var iy2 = fy - gy;

    // note if gy == 0 and gx == 0 then the circles are tangent and there is only one solution
    // but that one solution will just be duplicated as the code is currently written
    return [{x:ix1,y: iy1}, {x:ix2, y:iy2}];
}

// utils.arcArcIntersection = function(c1,r1,c2,r2) {
//     var a = r2;
//     var b = r1;
//     var c = Math.sqrt((c1.x-c2.x)*(c1.x-c2.x)+(c1.y-c2.y)*(c1.y-c2.y));
//     var d = (b*b+c*c-a*a)/(2*c);
//     var h = Math.sqrt(b*b-d*d);
//     x3 = (c2.x-c1.x)*d/c + (c2.y-c1.y)*h/c +  c1.x;
//     y3 = (c2.y-c1.y)*d/c - (c2.x-c1.x)*h/c +  c1.y;
//     x4 = (c2.x-c1.x)*d/c - (c2.y-c1.y)*h/c +  c1.x;
//     y4 = (c2.y-c1.y)*d/c + (c2.x-c1.x)*h/c +  c1.y;

//     return [
//      {x:x3,y:y3},
//      {x:x4,y:y4}
//     ]
// }

utils.pointDistanceFromLine = function(x,y,x1,y1,x2,y2){
    var point = utils.projectPointOnLine(x, y, x1, y1, x2, y2);
    var dx = x - point.x;
    var dy = y - point.y;
    return Math.sqrt(dx * dx + dy * dy);
}

utils.projectPointOnLine = function(x,y,x1,y1,x2,y2){
    var t=((x-x1)*(x2-x1)+(y-y1)*(y2-y1))/(Math.pow(x2-x1,2)+Math.pow(y2-y1,2))
    return {
        x:x1+t*(x2-x1),
        y:y1+t*(y2-y1)
    }
}

utils.projectPointOnGeneralLine = function(x,y,a,b,c){
    var a2b2 = Math.pow(a,2) + Math.pow(b,2)
    return {
        x: (b*(b*x - a*y) - a*c)/a2b2,
        y: (a*(-b*x + a*y) - b*c)/a2b2
    }
}

utils.getGeneralLineFromLineSegment = function(point1,point2){
    var angle = Math.atan2(point2.y-point1.y,point2.x-point1.x)
    var a = -Math.sin(angle);
    var b = Math.cos(angle);
    var c = -b*point1.y - a*point1.x
    return {
        a: a,
        b: b,
        c: c
    }
}

utils.areLinesParallel = function(a1,b1,a2,b2){
    if((Math.abs(a1-a2)<0.001 && Math.abs(b1-b2)<0.001) || (Math.abs(a1+a2)<0.001 && Math.abs(b1+b2)<0.001)){
        return true
    }else{
        return false
    }
}

utils.areLinesAlmostParallel = function(a1,b1,a2,b2){
    if((Math.abs(a1-a2)<0.2 && Math.abs(b1-b2)<0.2) || (Math.abs(a1+a2)<0.2 && Math.abs(b1+b2)<0.2)){
        return true
    }else{
        return false
    }
}

utils.angleInBetweenByRatio = function(startAngle,endAngle,direction,r){
    //r = 0 means start, r = 1 means end. gives the angle at a given ratio r
    if(direction == 'clockwise'){
        if(startAngle>endAngle){
            return (startAngle) + (r*(endAngle-startAngle));
        }else{
            if((startAngle) + r*(startAngle-endAngle)>-Math.PI){
                return (startAngle) + (r*(endAngle-startAngle-2*Math.PI))
            }else{
                return (2*Math.PI) + (startAngle) + (r*(endAngle-startAngle-2*Math.PI))
            }
        }
    }else if(direction == 'anticlockwise'){
        if(endAngle>startAngle){
            return (startAngle) + (r*(endAngle-startAngle));
        }else{
            if((startAngle) + r*(startAngle-endAngle)<Math.PI){
                return (startAngle) + (r*(endAngle - startAngle + 2*Math.PI))
            }else{
                return (-2*Math.PI) + (startAngle) + (r*(endAngle - startAngle + 2*Math.PI))
            }
        }
    }
}


utils.ratioInBetweenByAngle = function(startAngle,endAngle,direction,angle){
    if(direction == 'clockwise'){
        if(startAngle>endAngle){
            return (angle - startAngle)/(endAngle-startAngle);
        }else{
            var r = (angle - startAngle)/(endAngle-startAngle-2*Math.PI)
            if((startAngle) + r*(startAngle-endAngle)>-Math.PI){
                return r
            }else{
                return (angle - (2*Math.PI+startAngle))/(endAngle-startAngle-2*Math.PI)
            }
        }
    }else if(direction == 'anticlockwise'){
        if(endAngle>startAngle){
            return (angle - startAngle)/(endAngle-startAngle);
        }else{
            var r = (angle - startAngle)/(endAngle - startAngle + 2*Math.PI)
            if((startAngle) + r*(startAngle-endAngle)<Math.PI){
                return r
            }else{
                return (angle - (-2*Math.PI+startAngle))/(endAngle - startAngle + 2*Math.PI)
            }
        }
    }
}

utils.checkdirection = function(point1,point2,point3){//tells if point 1->3 vector is right or left wrt point 1->2 vector
    var av1 = Math.atan2(point2.y-point1.y,point2.x-point1.x);
    var av2 = Math.atan2(point3.y-point1.y,point3.x-point1.x);
    var cd = av1-av2;
    if(cd>Math.PI)return cd-2*Math.PI;
    if(cd<-Math.PI)return 2*Math.PI-Math.abs(cd);
    else return cd;
}

utils.bezierCurveSolver = function(t,bezierPoints){
    if(t == undefined || bezierPoints == undefined){
        return;
    }

    function binomial(n,k) {
        var binomials = [];
        while(n >= binomials.length) {
            var s = binomials.length;
            var nextRow = [];
            nextRow[0] = 1;
            for(var i=1, prev=s-1; i<s; i++) {
                nextRow[i] = binomials[prev][i-1] + binomials[prev][i];
            }
            nextRow[s] = 1;
            binomials.push(nextRow);
        }
        return binomials[n][k];
    }

    var n = bezierPoints.length-1;
    var point = {x:0,y:0}
    for(var i=0;i<=n;i++){
        var Pi = bezierPoints[i];
        point.x += (binomial(n,i)*Math.pow(1-t,n-i)*Math.pow(t,i)*Pi.x);
        point.y += (binomial(n,i)*Math.pow(1-t,n-i)*Math.pow(t,i)*Pi.y);
    }

    return point;
}

utils.get2dBoundingBox = function(points){
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY = -Infinity;

    if(points.length == 0){
        return null;
    }

    for(var p in points){
        var c = points[p]
        if (c.x < minX) minX = c.x;
        if (c.x > maxX) maxX = c.x;
        if (c.y < minY) minY = c.y;
        if (c.y > maxY) maxY = c.y;
    }
    
    return {
        minX: minX,
        maxX: maxX,
        minY: minY,
        maxY: maxY
    }
}

utils.get2dCenter = function(points) {
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY = -Infinity;
    for(var p in points){
        var c = points[p]
        if (c.x < minX) minX = c.x;
        if (c.x > maxX) maxX = c.x;
        if (c.y < minY) minY = c.y;
        if (c.y > maxY) maxY = c.y;
    }
    return {x:(minX + maxX) * 0.5, y: (minY + maxY) * 0.5}
}

utils.getCircleCenter = function(point1,point2,point3){
    var X0 = point1.x;var Y0 = point1.y;
    var X1 = point2.x;var Y1 = point2.y;
    var X2 = point3.x;var Y2 = point3.y;

    X1-= X0;Y1-= Y0;
    X2-= X0;Y2-= Y0;

    var Z1= X1 * X1 + Y1 * Y1;
    var Z2= X2 * X2 + Y2 * Y2;
    var D= 2 * (X1 * Y2 - X2 * Y1);

    var Xc= (Z1 * Y2 - Z2 * Y1) / D + X0;
    var Yc= (X1 * Z2 - X2 * Z1) / D + Y0;

    return {x:Xc,y:Yc};
}

utils.checkCollinearity = function(point1,point2,point3){
    if(Math.abs( point1.x * (point2.y - point3.y) + point2.x * (point3.y - point1.y) + point3.x * (point1.y - point2.y) )<1e-4){
        return true;
    }else{
        return false;
    }
}

utils.distance = function( x1, y1, x2, y2 ) {
    return Math.sqrt(
        Math.pow(x2 - x1, 2) + 
        Math.pow(y2 - y1, 2));
}

// angle between 0,0->x1,y1 and 0,0->x2,y2 (-pi to pi)
utils.angle = function( x1, y1, x2, y2 ) {
    var dot = x1 * x2 + y1 * y2;
    var det = x1 * y2 - y1 * x2;
    var angle = -Math.atan2( det, dot );
    return angle;
}

// shifts angle to be 0 to 2pi
utils.angle2pi = function( x1, y1, x2, y2 ) {
    var theta = utils.angle(x1, y1, x2, y2);
    if (theta < 0) {
        theta += 2*Math.PI;
    }
    return theta;
}

utils.arraySum = function(array1, array2) {
    if(array1.length==array2.length) {
        var arr=[];for(t=0;t<array1.length;t++){arr[t]=array1[t]+array2[t];}
        return arr; 
    }
    return 0;
}

utils.arrayDivide = function(array,n) {
    var arr=[];for(t=0;t<array.length;t++){arr[t]=array[t]/n;}
    return arr;
}

// points is array of points with x,y attributesKeys
utils.isClockwise = function( points ) {
// make positive
subX = Math.min(0, Math.min.apply(null, utils.map(points, function(p) {
    return p.x;
})))
subY = Math.min(0, Math.min.apply(null, utils.map(points, function(p) {
    return p.x;
})))
var newPoints = utils.map(points, function(p) {
    return {
        x: p.x - subX,
        y: p.y - subY
    }
})

// determine CW/CCW, based on:
// http://stackoverflow.com/questions/1165647
var sum = 0;
for ( var i = 0; i < newPoints.length; i++ ) {
    var c1 = newPoints[i];
    if (i == newPoints.length-1) {
        var c2 = newPoints[0]
    } else {
        var c2 = newPoints[i+1];
    }
    sum += (c2.x - c1.x) * (c2.y + c1.y);
}
return (sum >= 0);
}


utils.guid = (function() {
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000)
        .toString(16)
        .substring(1);
    }
    return function() {
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
        s4() + '-' + s4() + s4() + s4();
    };
})();

utils.polygonArea = function(points){
    var total = 0;
    for (var i = 0; i<points.length; i++) {
        var addX = points[i][0];
        var addY = points[i == points.length - 1 ? 0 : i + 1][1];
        var subX = points[i == points.length - 1 ? 0 : i + 1][0];
        var subY = points[i][1];
        total += (addX * addY * 0.5);
        total -= (subX * subY * 0.5);
    }

    return Math.abs(total);
}

// both arguments are arrays of corners with x,y attributes
utils.polygonPolygonIntersect = function(firstCorners, secondCorners) {
    for (var i = 0; i < firstCorners.length; i++) {
        var firstCorner = firstCorners[i],
        secondCorner;
        if (i == firstCorners.length-1) {
            secondCorner = firstCorners[0];
        } else {
            secondCorner = firstCorners[i+1];
        }

        if (utils.linePolygonIntersect(
            firstCorner.x, firstCorner.y,
            secondCorner.x, secondCorner.y,
            secondCorners)) {
            return true;
    }
}
return false;
}

// corners is an array of points with x,y attributes
utils.linePolygonIntersect = function(x1,y1,x2,y2,corners) {

    for (var i = 0; i < corners.length; i++) {
        var firstCorner = corners[i],
        secondCorner;
        if (i == corners.length-1) {
            secondCorner = corners[0];
        } else {
            secondCorner = corners[i+1];
        }

        if (utils.lineLineIntersect(x1,y1,x2,y2,
            firstCorner.x, firstCorner.y,
            secondCorner.x, secondCorner.y)) {
            return true;
    }
}
return false;
}

utils.lineLineIntersect = function(x1,y1,x2,y2, x3,y3,x4,y4) {
    function CCW(p1, p2, p3) {
        var a = p1.x,
        b = p1.y,
        c = p2.x,
        d = p2.y,
        e = p3.x,
        f = p3.y;
        return (f - b) * (c - a) > (d - b) * (e - a);
    }

    var p1 = {x:x1, y:y1},
    p2 = {x:x2, y:y2},
    p3 = {x:x3, y:y3},
    p4 = {x:x4, y:y4};
    return (CCW(p1, p3, p4) != CCW(p2, p3, p4)) && (CCW(p1, p2, p3) != CCW(p1, p2, p4)); 
}

utils.lineLineIntersection = function(x0,y0,x1,y1,x2,y2,x3,y3){
    var a = (y1-y0);
    var b = (x1-x0);
    var c = (y3-y2);
    var d = (x3-x2);
    var e = (b*y0)-(a*x0);
    var f = (d*y2)-(c*x2);

    return {x:(b*f-d*e)/(a*d-b*c),y:(a*f-c*e)/(a*d-c*b)};
}

utils.lineLineSegmentIntersection = function(x1,y1,x2,y2,x3,y3,x4,y4){
    //line formed passing through x1,y1 and x2,y2  Line segment formed from x3,y3,x4,y4
    if(((y1-y2)*(x3-x1)+(x2-x1)*(y3-y1))*((y1-y2)*(x4-x1)+(x2-x1)*(y4-y1))<0){
        return utils.lineLineIntersection(x1,y1,x2,y2,x3,y3,x4,y4);
    }else {
        return null;
    }
}

utils.getDirection = function(points){
    if(points[0].x){
        var netangle=0;
        for(u=0;u<points.length-1;u++){
            netangle+=(points[u+1].x-points[u].x)*(points[u+1].y+points[u].y);
        }
        netangle+=(points[0].x-points[points.length-1].x)*(points[0].y+points[points.length-1].y);
        if(netangle>0){
            return 'anticlockwise';
        }else{
            return 'clockwise'
        }
    }else if(points[0][0]){
        var netangle=0;
        for(u=0;u<points.length-1;u++){
            netangle+=(points[u+1][0]-points[u][0])*(points[u+1][1]+points[u][1]);
        }
        netangle+=(points[0][0]-points[points.length-1][0])*(points[0][1]+points[points.length-1][1]);
        if(netangle>0){
            return 'anticlockwise';
        }else{
            return 'clockwise'
        }
    }
}

utils.getPolygonCenter = function(vertices){
    var center = {x:0,y:0}
    for (var i = 0; i < vertices.length; i++) {
        center.x += vertices[i].x;
        center.y += vertices[i].y;
    }

    center.x /= vertices.length;
    center.y /= vertices.length;

    return center;
}

// corners is an array of points with x,y attributes
// startX and startY are start coords for raycast
utils.pointInPolygon = function(x,y,corners,startX,startY) {
    startX = startX || -1000000;
    startY = startY || -1000000;

    var intersects = 0;
    for (var i = 0; i < corners.length; i++) {
        var firstCorner = corners[i],
        secondCorner;
        if (i == corners.length-1) {
            secondCorner = corners[0];
        } else {
            secondCorner = corners[i+1];
        }

        if(corners[0].x){
            if (utils.lineLineIntersect(startX,startY,x,y,
                firstCorner.x, firstCorner.y,
                secondCorner.x, secondCorner.y)) {
                intersects++;
            }
        }else if(corners[0][0]){
            if (utils.lineLineIntersect(startX,startY,x,y,
                firstCorner[0], firstCorner[1],
                secondCorner[0], secondCorner[1])) {
                intersects++;
            }
        }
    }
    // odd intersections means the point is in the polygon
    //console.log("intersects: " + intersects);

    return ((intersects%2) == 1);
}

utils.pointInPolygonWithPadding = function(padding_percentage,x,y,corners,startX,startY) {
    var padded_vertices = [];
    var center = utils.getPolygonCenter(corners);

    for (var i = 0; i < corners.length; i++) {
        var dist = utils.distance(corners[i].x,corners[i].y,center.x,center.y);
        var angle = Math.atan2(corners[i].y - center.y, corners[i].x - center.x); 
        var shift = (padding_percentage/100)*dist;
        padded_vertices.push({
            x: corners[i].x - shift * Math.cos(angle),
            y: corners[i].y - shift * Math.sin(angle)
        });
    }


    return utils.pointInPolygon(x,y,padded_vertices,startX,startY)
}

utils.lineLineIntersectionGeneral = function(a1,b1,c1,a2,b2,c2){
    return {x:((c1*b2)-(b1*c2)) / ((b1*a2)-(a1*b2)),y:((a1*c2)-(c1*a2)) / ((b1*a2)-(a1*b2))};
}

utils.pointsInPolygon = function(points,corners,startX,startY){
    for(var p=0;p<points.length;p++){
        if(points[p].x){
            var x = points[p].x; var y = points[p].y
        }else{
            var x = points[p][0]; var y = points[p][0]
        }

        if(utils.pointInPolygon(x,y,corners,startX,startY)){
            return true;
        }
    }
    return false
}

utils.allPointsInPolygon = function(points,corners,startX,startY){
    for(var p=0;p<points.length;p++){
        if(points[p].x){
            var x = points[p].x; var y = points[p].y
        }else{
            var x = points[p][0]; var y = points[p][0]
        }

        if(!utils.pointInPolygon(x,y,corners,startX,startY)){
            return false;
        }
    }
    return true
}

utils.polygonPolygonIntersection = function(pointsA, pointsB){
    for(var i=0;i<pointsA.length;i++){
        if(utils.pointInPolygon(pointsA[i][0],pointsA[i][1],pointsB,-100000,-100000)){
            if(_.findIndex(pointsB,function(o){return Math.abs(o[0]-pointsA[i][0])<0.15 && Math.abs(o[1]-pointsA[i][1])<0.15}) == -1){
                return true;                
            }
        }
    }
    var lineTouchCounter = 0;
    var l1 = pointsA.length - 1;
    var l2 = pointsB.length - 1;
    for(var i=0;i<pointsA.length;i++){
        for(var j=0;j<pointsB.length;j++){
            if(utils.pointDistanceFromLineSegment(pointsA[i][0],pointsA[i][1],pointsB[j][0],pointsB[j][1],pointsB[j == l2 ? 0 : j+1][0],pointsB[j == l2 ? 0 : j+1][1])<0.01 
                || utils.pointDistanceFromLineSegment(pointsA[i == l1 ? 0 : i+1][0],pointsA[i == l1 ? 0 : i+1][1],pointsB[j][0],pointsB[j][1],pointsB[j == l2 ? 0 : j+1][0],pointsB[j == l2 ? 0 : j+1][1])<0.01
                || utils.pointDistanceFromLineSegment(pointsB[j][0],pointsB[j][1],pointsA[i][0],pointsA[i][1],pointsA[i == l1 ? 0 : i+1][0],pointsA[i == l1 ? 0 : i+1][1])<0.01 
                || utils.pointDistanceFromLineSegment(pointsB[j == l2 ? 0 : j+1][0],pointsB[j == l2 ? 0 : j+1][1],pointsA[i][0],pointsA[i][1],pointsA[i == l1 ? 0 : i+1][0],pointsA[i == l1 ? 0 : i+1][1])<0.01){
                    lineTouchCounter+=1
            }else {
                lineTouchCounter = 0;
            }
            if(utils.lineLineIntersect(pointsA[i][0],pointsA[i][1],pointsA[i == l1 ? 0 : i+1][0],pointsA[i == l1 ? 0 : i+1][1],  
                pointsB[j][0],pointsB[j][1],pointsB[j == l2 ? 0 : j+1][0],pointsB[j == l2 ? 0 : j+1][1])
                && utils.pointDistanceFromLineSegment(pointsA[i][0],pointsA[i][1],pointsB[j][0],pointsB[j][1],pointsB[j == l2 ? 0 : j+1][0],pointsB[j == l2 ? 0 : j+1][1])>0.1 
                && utils.pointDistanceFromLineSegment(pointsA[i == l1 ? 0 : i+1][0],pointsA[i == l1 ? 0 : i+1][1],pointsB[j][0],pointsB[j][1],pointsB[j == l2 ? 0 : j+1][0],pointsB[j == l2 ? 0 : j+1][1])>0.1
                && utils.pointDistanceFromLineSegment(pointsB[j][0],pointsB[j][1],pointsA[i][0],pointsA[i][1],pointsA[i == l1 ? 0 : i+1][0],pointsA[i == l1 ? 0 : i+1][1])>0.1 
                && utils.pointDistanceFromLineSegment(pointsB[j == l2 ? 0 : j+1][0],pointsB[j == l2 ? 0 : j+1][1],pointsA[i][0],pointsA[i][1],pointsA[i == l1 ? 0 : i+1][0],pointsA[i == l1 ? 0 : i+1][1])>0.1){
                    return true;
            }   
        }
    }
    if(lineTouchCounter == pointsA.length || lineTouchCounter == pointsB.length){
        return true;
    }
    return false;
}

utils.polygonPolygonDistance = function(polygonA, polygonB) {
    var minDistance = 100000;
    var currentDistance = 0;

    for(i = 0; i < polygonA.length; ++i) {
        for(j = 0; j < polygonB.length; ++j) {
            if(j!=polygonB.length-1){
                currentDistance = utils.pointDistanceFromLineSegment(polygonA[i][0],polygonA[i][1],polygonB[j][0],polygonB[j][1],polygonB[j+1][0],polygonB[j+1][1]);
            }else {
                currentDistance = utils.pointDistanceFromLineSegment(polygonA[i][0],polygonA[i][1],polygonB[j][0],polygonB[j][1],polygonB[0][0],polygonB[0][1]);
            }
            if(currentDistance < minDistance) {
                minDistance = currentDistance;
            }  
        } 
    }

    for(i = 0; i < polygonB.length; ++i) {
        for(j = 0; j < polygonA.length; ++j) {
            if(j!=polygonB.length-1){
                currentDistance = utils.pointDistanceFromLineSegment(polygonB[i][0],polygonB[i][1],polygonA[j][0],polygonA[j][1],polygonA[j+1][0],polygonA[j+1][1]);
            }else {
                currentDistance = utils.pointDistanceFromLineSegment(polygonB[i][0],polygonB[i][1],polygonA[j][0],polygonA[j][1],polygonA[0][0],polygonA[0][1]);
            }
            if(currentDistance < minDistance) {
                minDistance = currentDistance;
            }  
        } 
    }

    return minDistance;
}


// checks if all corners of insideCorners are inside the polygon described by outsideCorners
utils.polygonInsidePolygon = function(insideCorners, outsideCorners, startX, startY) {
    startX = startX || 0;
    startY = startY || 0;

    for (var i = 0; i < insideCorners.length; i++) {
        if (!utils.pointInPolygon(
            insideCorners[i].x, insideCorners[i].y,
            outsideCorners,
            startX, startY)) {
            return false;
        }
    }
    return true;
}

// checks if any corners of firstCorners is inside the polygon described by secondCorners
utils.polygonOutsidePolygon = function(insideCorners, outsideCorners, startX, startY) {
    startX = startX || 0;
    startY = startY || 0;

    for (var i = 0; i < insideCorners.length; i++) {
        if (utils.pointInPolygon(
            insideCorners[i].x, insideCorners[i].y,
            outsideCorners,
            startX, startY)) {
            return false;
        }
    }
    return true;
}


// arrays

utils.forEach = function(array, action) {
    for (var i = 0; i < array.length; i++) {
        action(array[i],i);
    }
}

utils.forEachIndexed = function(array, action) {
    for (var i = 0; i < array.length; i++) {
        action(i, array[i]);
    }
}

utils.map = function(array, func) {
    var result = [];
    utils.forEach(array, function (element) {
        result.push(func(element));
    });
    return result;
}

utils.moduloTwoPI = function(angle){
    return  (angle%(2*Math.PI)+(2*Math.PI))%(2*Math.PI)
}

// remove elements in array if func(element) returns true
utils.removeIf  = function(array, func) {
    var result = [];
    utils.forEach(array, function (element) {
        if (!func(element)) {
            result.push(element);
        }
    });
    return result;
}

// shift the items in an array by shift (positive integer)
utils.cycle = function(arr, shift) {
    var ret = arr.slice(0);
    for (var i = 0; i < shift; i++) {
        var tmp = ret.shift();
        ret.push(tmp);
    }
    return ret;
}

// returns in the unique elemnts in arr
utils.unique = function(arr, hashFunc) {
    var results = [];
    var map = {};
    for (var i = 0; i < arr.length; i++) {
        if (!map.hasOwnProperty(arr[i])) {
            results.push(arr[i]);
            map[hashFunc(arr[i])] = true;
        }
    }
    return results; 
}

utils.removeValue = function(arr, value) {
    for(var i = arr.length - 1; i >= 0; i--) {
        if(arr[i] === value) {
            arr.splice(i, 1);
        }
    }
}

// checks if value is in array
utils.hasValue = function(array, value) {
    for (var i = 0; i < array.length; i++) {
        if (array[i] === value) {
            return true;
        }
    }
    return false;
}

// subtracts the elements in subArray from array
utils.subtract = function(array, subArray) {
    return utils.removeIf(array, function(el) {
        return utils.hasValue(subArray, el);
    });
}





function requestGenerateMockup(mockup,inputs,params){
    // return $.post(server_path+'mockup/generate_mockup',
    //     { data:JSON.stringify({mockup:mockup,inputs:inputs,params:params})}
    // )

    return generateMockup(mockup,inputs,params)
    .then(function(output){
        return Promise.resolve({
            response_code: 1,
            data: {
                data: {
                    output: output.toDataURL()
                }
            }
        })
    })
}



// var inputs = {
//                 hue_values: [{h: 198.2142857142857, s: 1, l: 0.4392156862745098, a: 1}],
//                 user_images: [{src:image.src}]
//             }
function generatePlaceHolders(mockups,inputs,placeholder_index,crop_type){
    if(!crop_type){
        crop_type = 'zoom'
    }
    if(inputs == undefined){
        inputs =  {
            hue_values: [],
            user_images: []
        }
    }
    return syncForEach(mockups,function(mockup,index){
        console.log('Generating mockup '+index+' - '+mockup.name);
        var dynamic_layer = null;
        
        var dynamic_layers = [];
        for (var i = 0; i < mockup.layers.length; i++) {
            if(mockup.layers[i].type == 'dynamic'){
                dynamic_layers.push(mockup.layers[i])
            }
        }
        function tempCropFunction(i){
            return loadStaticImage(inputs.user_images[i].src).then(function(image){
                var aspect =  dynamic_layers[i].upload_resolution.width/dynamic_layers[i].upload_resolution.height
                var temp_crop_editor = new cropEditor(image,aspect,document.createElement('div'))
                if(crop_type == 'zoom'){
                    temp_crop_editor.zoomToScreen()
                }else{
                    temp_crop_editor.fitToScreen()
                }
                inputs.user_images[i].cropDetails = temp_crop_editor.exportCrop()
                return Promise.resolve()
            }).catch(err => {
                console.log(err);
                return Promise.reject(err)
            })
        }

        var prom_array = [];
        for (var i = 0; i < dynamic_layers.length; i++) {
            if(inputs.user_images[i] && dynamic_layers[i].upload_resolution && dynamic_layers[i].upload_resolution.width && dynamic_layers[i].upload_resolution.height){
                prom_array.push(
                    tempCropFunction(i)
                )

                
            }
        }

        return Promise.all(prom_array).then(() => {
            return requestGenerateMockup(mockup,inputs,{maxWidth: 800,maxHeight: 800,image_mime:'"image/jpeg"',image_quality:0.9})
            .then(function(output){
                if(output.response_code == -1){
                    return Promise.reject(output.error)
                }else if(output.data.error){
                    return Promise.reject(output.data.error)
                }else{
                    console.log('Generated placeholder of mockup '+index+' - '+mockup.name);
                    var imgData = output.data.data.output;
                    return new Promise(function(resolve,reject){
                         $.ajax({
                            type: 'POST', 
                            url: server_path+'mockup/add_placeholder_image',
                            data: {stringified_data:JSON.stringify({
                                mockup_id:mockup._id,
                                data:imgData,
                                index: placeholder_index
                            })}, 
                            dataType: 'json'
                        })
                        .done(function( data ) {
                            resolve();
                            console.log('Uploaded placeholder of mockup '+index+' - '+mockup.name);
                        }).fail(function(err){
                            resolve();
                            console.log('something went wrong')
                            console.log(err);
                        })
                    })
                }
            })
        })

    })
}

function cropAndGenerateMockup(mockup,inputs,crop_type){
    if(!crop_type){
        crop_type = 'zoom'
    }
    if(inputs == undefined){
        inputs =  {
            hue_values: [{h: 63.82, s: 1, l: 0.368, a: 1},{h: 198.21, s: 1, l: 0.439, a: 1},{h: 298.60, s: 1, l: 0.578, a: 1}],
            user_images: [
                {src:server_path+'uploads/design_resources/design_thumbnails/5cf02984b4ebfd540878f6dd.jpg'},
                {src:server_path+'uploads/design_resources/design_thumbnails/5cf02984b4ebfd540878f6dd.jpg'},
                {src:server_path+'uploads/design_resources/design_thumbnails/5cf02984b4ebfd540878f6dd.jpg'},
                {src:server_path+'uploads/design_resources/design_thumbnails/5cf02984b4ebfd540878f6dd.jpg'},
                {src:server_path+'uploads/design_resources/design_thumbnails/5cf02984b4ebfd540878f6dd.jpg'},
                {src:server_path+'uploads/design_resources/design_thumbnails/5cf02984b4ebfd540878f6dd.jpg'}
            ]
        }
    }

    var dynamic_layer = null;
    
    var dynamic_layers = [];
    for (var i = 0; i < mockup.layers.length; i++) {
        if(mockup.layers[i].type == 'dynamic'){
            dynamic_layers.push(mockup.layers[i])
        }
    }
    function tempCropFunction(i){
            // return Promise.resolve()
        return loadStaticImage(inputs.user_images[i].src).then(function(image){
            var aspect =  dynamic_layers[i].upload_resolution.width/dynamic_layers[i].upload_resolution.height
            var temp_crop_editor = new cropEditor(image,aspect,document.createElement('div'))
            if(crop_type == 'zoom'){
                temp_crop_editor.zoomToScreen()
            }else{
                temp_crop_editor.fitToScreen()
            }
            inputs.user_images[i].cropDetails = temp_crop_editor.exportCrop()
            return Promise.resolve()
        }).catch(err => {
            console.log(err);
            return Promise.reject(err)
        })
    }

    var prom_array = [];
    for (var i = 0; i < dynamic_layers.length; i++) {
        if(inputs.user_images[i] && dynamic_layers[i].upload_resolution && dynamic_layers[i].upload_resolution.width && dynamic_layers[i].upload_resolution.height){
            prom_array.push(
                tempCropFunction(i)
            )
        }
    }

    return Promise.all(prom_array).then(() => {
        return requestGenerateMockup(mockup,inputs,{maxWidth: 800,maxHeight: 800,image_mime:'"image/jpeg"',image_quality:0.9})
        .then(function(output){
            if(output.response_code == -1){
                return Promise.reject(output.error)
            }else if(output.data.error){
                return Promise.reject(output.data.error)
            }else{
                var imgData = output.data.data.output;
                return Promise.resolve(imgData)
            }
        })
    })

}

function obj_mtl_loader(obj_src,mtl_src){
    return new Promise(function(resolve, reject) {
        var loader = new THREE.OBJMTLLoader();
        loader.crossOrigin = '';
        loader.texture_path =  '';
        loader.load(server_path+obj_src, server_path+mtl_src,function(object){
            resolve(object);
        },undefined,function(error){
            reject(error);
        });
    }).catch(function(err){
        console.log(err)
        return Promise.reject(err);
    })
}

utils.setLayerHue = function(layer_canvas,hsl){
    var avg = utils.getLayerAverageColor(layer_canvas);
    var yiq_source = rgb2yiq(avg.r,avg.g,avg.b);

    var color = new THREE.Color()
    color.setHSL(hsl.h/360,hsl.s,hsl.l)

    var yiq_target = rgb2yiq(255*color.r,255*color.g,255*color.b);
    // yiq_target[0] = Math.min(0.8,yiq_target[0])

    var image_data = layer_canvas.getContext('2d').getImageData(0, 0, layer_canvas.width, layer_canvas.height);
    var a = convertImageData(image_data.data,'rgba','yiqa');

    var image_data = layer_canvas.getContext('2d').getImageData(0, 0, layer_canvas.width, layer_canvas.height);
    var len = a.length;

    var average_plus = 0; var average_minus = 0;
    var counter_plus = 0; var counter_minus = 0;
    for(var i=0;i<len;i+=4){
        if(a[i+3]!=0){
            var diff = a[i]-yiq_source[0]
            if(yiq_target[0] + diff > 1){
                average_plus += (yiq_target[0] + diff - 1)
                counter_plus++
            }

            if(yiq_target[0] + diff < 0){
                average_minus += (yiq_target[0] + diff)
                counter_minus++
            }
        }
    }
    if(counter_plus>0){
        average_plus /= counter_plus
    }
    if(counter_minus>0){
        average_minus /= counter_minus
    }
    console.log(average_plus)
    console.log(average_minus)

    for(var i=0;i<len;i+=4){
        if(a[i+3]!=0){
            // var diff = Math.max(-0.1,Math.min(a[i]-yiq_source[0],0.05))
            // a[i] = Math.max(0.001,Math.min(yiq_target[0] + diff,0.99))
            var diff = a[i]-yiq_source[0]
            a[i] = yiq_target[0] + diff - average_plus - average_minus

            a[i+1] = yiq_target[1]
            a[i+2] = yiq_target[2]

            if(hsl.a != undefined){
                a[i+3] = Math.floor(hsl.a*255)
            }
        }
    }

    var c = convertImageData(a,'yiqa','rgba');
    layer_canvas.getContext('2d').putImageData(new ImageData(c,image_data.width,image_data.height),0,0);
}

utils.getLayerAverageColor = function(layer_canvas){
    var image_data = layer_canvas.getContext('2d').getImageData(0, 0, layer_canvas.width, layer_canvas.height);
    var a = image_data.data
    var average_rgb = {
        r:0,g:0,b:0
    };
    var counter = 0;
    var len = a.length;
    for(var i=0;i<len;i+=4){
        if(a[i+3]!=0){
            average_rgb.r += a[i]
            average_rgb.g += a[i+1]
            average_rgb.b += a[i+2]
            counter+=1;
        }
    }

    average_rgb.r /= counter;
    average_rgb.g /= counter;
    average_rgb.b /= counter;

    var color = new THREE.Color()
    color.r = average_rgb.r/255
    color.g = average_rgb.g/255
    color.b = average_rgb.b/255
    var hsl = color.getHSL()
    hsl.h*=360    
    hsl.s*=100    
    hsl.l*=100

    return average_rgb
}

function imageRectROI(data,top_left,crop_width,crop_height){
    top_left.x = Math.floor(top_left.x)
    top_left.y = Math.floor(top_left.y)
    crop_width = Math.floor(crop_width)
    crop_height = Math.floor(crop_height)
    //image has to be 4 channeled
    var result = new Uint8ClampedArray(crop_width*crop_height*4);
    var rows = data.height;
    var cols = data.width;
    var count = 0;
    for(var i=top_left.y-1;i<top_left.y-1+crop_height;i++){
        for(var j=top_left.x-1;j<top_left.x-1+crop_width;j++){
            let current_pixel = 4*(i*cols  + j);
            result[count] = data.data[current_pixel];
            result[count+1] = data.data[current_pixel+1];
            result[count+2] = data.data[current_pixel+2];
            result[count+3] = data.data[current_pixel+3];
            count += 4
        }
    }

    return new ImageData(result,crop_width,crop_height)
}

function lightMapBlend(source,target,alpha){
    // return target
    //source and target needs to be rgba
    var a = convertImageData(target.data,'rgba','yiqa');
    var b = convertImageData(source.data,'rgba','yiqa');

    var width = target.width;
    var height = target.height;

    // b = convolutionalHaze(b.concat([]),width,height)
   
    /*var avg_a = 0; */var avg_b = 0;
    var counter = 0;
    for(let i=0,len=a.length;i<len;i+=4){
        if(a[i+3]!=0){
            // avg_a += a[i]
            avg_b += b[i]
            counter+=1;
        }
    }

    // avg_a /= counter;
    avg_b /= counter;

    // var average_plus = 0; var average_minus = 0;
    // var counter_plus = 0; var counter_minus = 0;
    // for(var i=0,len=a.length;i<len;i+=4){
    //     if(a[i+3]!=0){
    //         var diff = (b[i] - avg_b)
    //         if(a[i] + diff > 1){
    //             average_plus += (a[i] + diff - 1)
    //             counter_plus++
    //         }

    //         if(a[i] + diff < 0){
    //             average_minus += (a[i] + diff)
    //             counter_minus++
    //         }
    //     }
    // }
    // if(counter_plus>0){
    //     average_plus /= counter_plus
    // }
    // if(counter_minus>0){
    //     average_minus /= counter_minus
    // }

    // average_plus = 0;
    // average_minus = 0;


    // for(let i=0,len=a.length;i<len;i+=4){
    //     let change = (b[i] - avg_b)
    //     a[i] += (change - average_plus - average_minus)
    // }

    for(let i=0,len=a.length;i<len;i+=4){
        let change = (b[i] - avg_b)
        a[i] += (change + alpha)
    }

    var c = convertImageData(a,'yiqa','rgba');
   
    return new ImageData(new Uint8ClampedArray(c),source.width,source.height)
}

function convertImageData(pixelData,source_type,target_type){
    // var color = [];
    var result = []
    
    // for(let i=0,len = pixelData.length;i<len;i+=4){
    //     let index = i
    //     color[i/4] = [pixelData[index],pixelData[index+1],pixelData[index+2],pixelData[index+3]]
    // }

    
    if(source_type == 'rgba' && target_type == 'yiqa'){
        for(let i=0,len = pixelData.length;i<len;i+=4){
            let out = rgb2yiq(pixelData[i],pixelData[i+1],pixelData[i+2])
            result.push(out[0],out[1],out[2],pixelData[i+3])
        }
        // for(let i=0,len = color.length;i<len;i++){
        //     let out = rgb2yiq(color[i][0],color[i][1],color[i][2])
        //     result.push(out[0],out[1],out[2],color[i][3])
        // }
    }else if(source_type == 'yiqa' && target_type == 'rgba'){
        var result = new Uint8ClampedArray(pixelData.length)
        for(let i=0,len = pixelData.length;i<len;i+=4){
            let out = yiq2rgb(pixelData[i],pixelData[i+1],pixelData[i+2])
            result[i] = out[0];
            result[i+1] = out[1];
            result[i+2] = out[2];
            result[i+3] = pixelData[i+3]
            // result.push(out[0],out[1],out[2],pixelData[i+3])
        }
        // for(let i=0,len = color.length;i<len;i++){
        //     let out = yiq2rgb(color[i][0],color[i][1],color[i][2])
        //     result.push(out[0],out[1],out[2],color[i][3])
        // }
    }

    return result
}

function rgb2yiq(r,g,b){
    return [
        (0.299*r + 0.587*g + 0.114*b)/255,
        (0.5959*r - 0.2746*g - 0.3213*b)/255,
        (0.2115*r - 0.5227*g + 0.3112*b)/255,
    ]
}

function yiq2rgb(y,i,q){
    return [
        255*(y + 0.956*i + 0.619*q),
        255*(y - 0.272*i - 0.647*q),
        255*(y - 1.106*i + 1.703*q),
    ]
}

function outerGeometry(clone_geom,object,parent_mesh){
    /*********gives the outer geometry of the entire object3D by cumulating all geometries inside the object****/
    /****Don't forget to give the clone of an object so that your object doesn't get spoiled******/
    if(clone_geom == undefined){
        return;
    }

    if(object.constructor.name == 'Object3D' || object.constructor.name == 'Group'){
        if(object.visible){
            for(var i=0;i<object.children.length;i++){
                outerGeometry(clone_geom,object.children[i]);
            }
        }
    }else if(object.constructor.name == 'Mesh'){
        if(object.visible){ 
            outerGeometry(clone_geom,object.geometry,object);
        }
    }else if(object instanceof THREE.Geometry){
        var new_geom = new THREE.Geometry();
        for(var i=0;i<object.vertices.length;i++){
            new_geom.vertices.push(object.vertices[i].clone());
        }

        var globalMatrix = getMeshTransformationData(parent_mesh);
        var inverseGlobalMatrix = new THREE.Matrix4().getInverse(globalMatrix.clone());

        for(var i=0;i<new_geom.vertices.length;i++){
            new_geom.vertices[i].applyMatrix4(globalMatrix)
            clone_geom.vertices.push(new_geom.vertices[i]);
        }
        for(var i=0;i<object.faces.length;i++){ 
            var vertexIndex1 = _.findIndex(clone_geom.vertices,function(o){
                return o == new_geom.vertices[object.faces[i].a]
            });
            var vertexIndex2 = _.findIndex(clone_geom.vertices,function(o){
                return o == new_geom.vertices[object.faces[i].b]
            });
            var vertexIndex3 = _.findIndex(clone_geom.vertices,function(o){
                return o == new_geom.vertices[object.faces[i].c]
            });
            clone_geom.faces.push(new THREE.Face3(vertexIndex1,vertexIndex2,vertexIndex3));
        }
    }
}


function getMeshTransformationData(object, objectMatrix){
    if(objectMatrix==undefined){
        objectMatrix = new THREE.Matrix4()
    }
    var translationMatrix = objectMatrix.clone();
    translationMatrix.premultiply(new THREE.Matrix4().makeScale(object.scale.x,object.scale.y,object.scale.z))
    translationMatrix.premultiply(new THREE.Matrix4().makeRotationFromEuler(object.rotation.clone()))
    translationMatrix.premultiply(new THREE.Matrix4().makeTranslation(object.position.x,object.position.y,object.position.z))

    if(!object.parent){
        return  translationMatrix;
    }
    else{
        return getMeshTransformationData(object.parent, translationMatrix)
    }
}

function worldToScreen(point,camera, width, height){
    var vector = point.clone();
    camera.updateProjectionMatrix()
    camera.updateMatrixWorld()
    vector.project( camera );

    vector.x = (   vector.x + 1 ) * width  / 2
    vector.y = ( - vector.y + 1 ) * height / 2

    return {x:vector.x,y:vector.y}
}

function yAxisMirror(imageData){
    var flip_canvas = document.createElement('canvas');
    flip_canvas.width = imageData.width;
    flip_canvas.height = imageData.height;

    flip_canvas.getContext('2d').save()
    flip_canvas.getContext('2d').putImageData(imageData, 0, 0);
    flip_canvas.getContext('2d').restore()

    var canvas2 = document.createElement('canvas');
    canvas2.width = imageData.width;
    canvas2.height = imageData.height;
    canvas2.getContext('2d').translate(0, imageData.height);
    canvas2.getContext('2d').scale(1,-1);
    canvas2.getContext('2d').drawImage(flip_canvas,0,0,imageData.width,imageData.height)

    var new_data = canvas2.getContext('2d').getImageData(0, 0, imageData.width, imageData.height);

    canvas2.remove();flip_canvas.remove()
    canvas2 = undefined;flip_canvas = undefined;
    return new_data
}

function averageColor(imageData){
    var pixelData = imageData.data;
    var l = pixelData.length/4;
    var rgb = [0,0,0]

    for(let i=0,len = pixelData.length;i<len;i+=4){
        rgb[0] += pixelData[i]
        rgb[1] += pixelData[i+1]
        rgb[2] += pixelData[i+2]
    }

    rgb[0] /= l
    rgb[1] /= l
    rgb[2] /= l

    return rgb
}

function blackToTransparent(imageData){
    var pixelData = imageData.data;
    var l = pixelData.length/4;

    for(let i=0,len = pixelData.length;i<len;i+=4){
        // if(pixelData[i] == 0 && pixelData[i+1] == 0 && pixelData[i+2] == 0){
        //     pixelData[i+3] = 0
        // }

        pixelData[i+3] = Math.floor((pixelData[i] + pixelData[i+1] + pixelData[i+2])/(3));
    }

    return imageData
}

function invertColor(color){
    var font_color = chroma(color)
    var rgb = font_color.get('rgb')
    rgb = rgb.map(function(o){return 255 - o});
    font_color = font_color.set('rgb.r',rgb[0]);
    font_color = font_color.set('rgb.g',rgb[1]);
    font_color = font_color.set('rgb.b',rgb[2]);

    return font_color.get('hex');
}
function xAxisMirror(imageData){
    var data_cpy = []
    for(let row=0,len=imageData.height;row<len;++row){
        for(let col=0,len2=imageData.width;col<len2;++col){
            let opp_col = imageData.width - 1 - col
            let pix_opp = 4*(row*imageData.width + (imageData.width - col))
            data_cpy.push(imageData.data[pix_opp],imageData.data[pix_opp+1],imageData.data[pix_opp+2],imageData.data[pix_opp+3])
        }
    }

    return new ImageData(new Uint8ClampedArray(data_cpy),imageData.width,imageData.height)
}

function disposeNode (node)
{
    if (node instanceof THREE.Camera)
    {
         node = undefined;
    }
    // else if (node instanceof THREE.Light)
    // {
    //  node.dispose ();
    //  node = undefined;
    // }
    else if (node instanceof THREE.Mesh)
    {
        geometry = node.geometry;
        material = node.material;
        texture = node.material.map;

        geometry.dispose();
        if(material.constructor.name == "Array")
        {
            for (var i = 0; i < material.length; i++)
            material[i].dispose();
        }
        else
        material.dispose();

        // material.dispose();
        if(texture instanceof THREE.Texture) {
            texture.dispose();
        }
        node = undefined;
    }
    else if (node instanceof THREE.Object3D)
    {
        node = undefined;
    }
}   // disposeNode

function disposeHierarchy (node, callback)
{
    for (var i = node.children.length - 1; i >= 0; i--)
    {
        var child = node.children[i];
        disposeHierarchy (child, callback);
        callback (child);
    }
}

function dispose_scene_content(scene) {
    for( var i = scene.children.length - 1; i >= 0; i--) {
        obj = scene.children[i];
        if (!(obj instanceof THREE.Camera)) {
            scene.remove(obj);
            disposeHierarchy (obj, disposeNode);
        }
    }
}

function rgbToHsl(r, g, b) {
  r /= 255, g /= 255, b /= 255;

  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h, s, l = (max + min) / 2;

  if (max == min) {
    h = s = 0; // achromatic
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }

    h /= 6;
  }

  return [h*360,s*100,l*100]
}

function hexToHSL(hex) {
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    r = parseInt(result[1], 16);
    g = parseInt(result[2], 16);
    b = parseInt(result[3], 16);
    r /= 255, g /= 255, b /= 255;
    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2;
    if(max == min){
      h = s = 0; // achromatic
    }else{
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch(max){
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
  var HSL = new Object();

  return [h*360,s*100,l*100]
}

function hslToHex(h, s, l) {
  h /= 360;
  s /= 100;
  l /= 100;
  let r, g, b;
  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  const toHex = x => {
    const hex = Math.round(x * 255).toString(16);
    return hex.length === 1 ? '0' + hex : hex;
  };
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}