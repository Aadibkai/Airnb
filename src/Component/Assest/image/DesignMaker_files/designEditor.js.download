// // Copy off the old measurement function (we'll need it)
// CanvasRenderingContext2D.prototype._measureText = CanvasRenderingContext2D.prototype.measureText;

// // This was inspired by StackOverflow answer:
// // http://stackoverflow.com/questions/11452022/measure-text-height-on-an-html5-canvas-element
// CanvasRenderingContext2D.prototype.measureText = function(text) {
// 	var metrics = this._measureText(text);

// 	var textSpan = document.createElement('span');
// 	textSpan.innerHTML = text;
// 	textSpan.style.font = this.font;
	
// 	var block = document.createElement("div");
// 	block.style.display = 'inline-block';
// 	block.style.width = '1px';
// 	block.style.height = '0px';

// 	var div = document.createElement('div');
// 	div.appendChild(textSpan);
// 	div.appendChild(block);

// 	var body = document.body;
// 	body.appendChild(div);

// 	var ascent = -1;
// 	var descent = -1;
// 	var height = -1;

// 	try {
// 		block.style['vertical-align'] = 'baseline';
// 		ascent = block.offsetTop - textSpan.offsetTop;
// 		block.style['vertical-align'] = 'bottom';
// 		height = block.offsetTop - textSpan.offsetTop;
// 		descent = height - ascent;
// 	} finally {
// 		document.body.removeChild(div);
// 	}

// 	var new_metrics = {};

// 	// TODO This doesn't account for locale, and is guaranteed broken for those that read right-to-left
// 	switch(this.textAlign) {
// 		case "start":
// 		case "left":
// 			new_metrics.actualBoundingBoxLeft = 0;
// 			new_metrics.actualBoundingBoxRight = metrics.width;
// 			break;

// 		case "end":
// 		case "right":
// 			new_metrics.actualBoundingBoxLeft = -metrics.width;
// 			new_metrics.actualBoundingBoxRight = 0;
// 			break;

// 		case "center":
// 			// TODO This is probably just an approximation.
// 			new_metrics.actualBoundingBoxLeft = -metrics.width/2.0;
// 			new_metrics.actualBoundingBoxRight = metrics.width/2.0;
// 			break;
// 	}
// 	new_metrics.actualBoundingBoxAscent = ascent;
// 	new_metrics.actualBoundingBoxDescent = descent;
// 	new_metrics.height = height;

// 	// Copy the new metrics over, if and only if the CanvasRenderingContext2D API doesn't provide them
// 	for(var key in new_metrics) {
// 		if (new_metrics.hasOwnProperty(key) && !(key in metrics)) {
// 			metrics[key] = new_metrics[key];
// 		}
// 	}

// 	return metrics;
// };

// document.addEventListener("visibilitychange", function(e) {
//   	event.preventDefault();
//   	event.stopPropagation();

//   	if(window['design_editor']){
//   		if(document.hidden){
//   			//disable rendering
// 		  	design_editor.render_timer_destroyed = true;
// 		  	for (var i = 0; i < design_editor.pages.length; i++) {
// 		  		design_editor.pages[i].render_timer_destroyed = true;
// 		  	}

// 		  	//clearing all existing timeouts
// 		  	let id = window.setTimeout(function(){}, 0);
// 			while (id) {
// 			  window.clearTimeout(id);
// 			  id--;
// 			}

// 			id = window.setInterval(function(){}, 0);
// 			while (id) {
// 			  window.clearInterval(id);
// 			  id--;
// 			}
//   		}else{
//   			//re enabling rendering
// 		  	if(design_editor.render_timer_destroyed){
// 			  	design_editor.render_timer_destroyed = false;
// 			  	design_editor.redraw_listener();
// 			}

// 		  	for (var i = 0; i < design_editor.pages.length; i++) {
// 		  		if(design_editor.pages[i].render_timer_destroyed){
// 		  			design_editor.pages[i].render_timer_destroyed = false;
// 		  			design_editor.pages[i].redraw_listener()
// 		  		}
// 		  	}
//   		}
//   	}
// });

$.ajaxSetup({
    xhrFields: {
       withCredentials: true
    },
    crossDomain: true
});

function cloneCanvas(oldCanvas,new_width,new_height) {
    //create a new canvas
    var newCanvas = document.createElement('canvas');
    var context = newCanvas.getContext('2d');

    //set dimensions
    newCanvas.width = new_width||oldCanvas.width;
    newCanvas.height = new_height||oldCanvas.height;

    //apply the old canvas to the new one
    context.drawImage(oldCanvas, 0, 0,new_width||oldCanvas.width,new_height||oldCanvas.height);

    //return the new canvas
    return newCanvas;
}


// function refresh_ids_struct(design_file_page){
// 	design_file_page.id = utils.uuidv4();
// 	var id_map = {}
// 	for (var i = 0; i < design_file_page.objects.length; i++) {
// 		var new_id = utils.uuidv4();
// 		id_map[design_file_page.objects[i].id] = new_id
// 		design_file_page.objects[i].id = new_id;

// 		if(design_file_page.objects[i].type == 'grid'){
// 			var boxes = design_file_page.objects[i].grid_details.boxes;
// 			for(var b=0;b<boxes.length;b++){
// 				if(boxes[b].image){
// 					var new_id = utils.uuidv4();
// 					id_map[boxes[b].image.id] = new_id
// 					boxes[b].image.id = new_id;
// 				}
// 				if(boxes[b].frame){
// 					var new_id = utils.uuidv4();
// 					id_map[boxes[b].frame.id] = new_id
// 					boxes[b].frame.id = new_id;
// 				}
// 			}
// 		}
// 	}

// 	for (var i = 0; i < design_file_page.objects.length; i++) {
// 		design_file_page.objects[i].id = utils.uuidv4();
// 		design_file_page.objects[i].group_details.object_data = design_file_page.objects[i].group_details.object_data.map(function(o){
// 			o.object = id_map[o.object];
// 		})
// 	}
// }

// function refresh_ids_design(page){
// 	page.id = utils.uuidv4();
// 	var id_map = {}
// 	for (var i = 0; i < page.objects.length; i++) {
// 		var new_id = utils.uuidv4();
// 		id_map[page.objects[i].id] = new_id
// 		page.objects[i].id = new_id;

// 		if(page.objects[i].type == 'grid'){
// 			var boxes = page.objects[i].grid_details.boxes;
// 			for(var b=0;b<boxes.length;b++){
// 				if(boxes[b].image){
// 					var new_id = utils.uuidv4();
// 					id_map[boxes[b].image.id] = new_id
// 					boxes[b].image.id = new_id;
// 				}
// 				if(boxes[b].frame){
// 					var new_id = utils.uuidv4();
// 					id_map[boxes[b].frame.id] = new_id
// 					boxes[b].frame.id = new_id;
// 				}
// 			}
// 		}
// 	}

// 	for (var i = 0; i < page.objects.length; i++) {
// 		page.objects[i].id = utils.uuidv4();
// 		page.objects[i].group_details.object_data = page.objects[i].group_details.object_data.map(function(o){
// 			o.object.id = id_map[o.object];
// 		});
// 	}
// }

$(document).on('contextmenu', 'img', function() {
	return false;
})


function designEditor(design_file,doms,design_save_id,dont_activate_controller,category_id){
	var editor = this;
	var scope = this;
	this.id = utils.uuidv4();
	this.dont_activate_controller = dont_activate_controller
	this.pages = [];
	this.width = 800;
	this.height = 600;

	this.canvas_scale = Math.max(PIXEL_RATIO || 1,1.5);

	this.loader_image = null

	this.undo_stack_disabled = false

	this.category_id = category_id;

	this.dimension_units = 'px';

	this.design_save_id = design_save_id

	this.doms = doms;

	this.bulk_edit_data = {
		labels:[],
		data:[]
	};

	this.page_zoom = 'fit'

	this.active_page = null/*editor.pages[0];*/

	this.undoStack = [];
	this.redoStack = [];

	this.clipboardObject = null;

	var loaded_images = {};
	this.loaded_images = loaded_images
	var loading_images = {};
	this.loading_images = loading_images
	this.loaded_mockups = {}

	this.loading_fonts = [];
	this.font_heights = {}


	this.cropFillGapChanges = {}

	this.resource_promise_array = [];
	this.font_checking_completed = [];

	this.needs_redraw = false
	this.render_timer_destroyed = false

	this.drag_ghost_image = null;
	this.drag_details = null;

	this.clearMemory = function(){
		editor.resource_promise_array = [];
		editor.loaded_images = {};
		editor.loading_images = {};
		editor.loaded_mockups = {};
		editor.loading_fonts = []
		editor.font_checking_completed = []
	}

	this.present_next = function(){
		var current_page = editor.present_index;
		if(current_page < editor.pages.length-1){
			editor.present(current_page + 1);
		}
	}

	this.present_previous = function(){
		var current_page = editor.present_index;
		if(current_page > 0){
			editor.present(current_page - 1);
		}
	}

	this.present_index = null;
	this.fullscreen_hover_timer = null;

	var presentation_control = document.createElement('div');
	presentation_control.style.display = 'block'
	// presentation_control.style.flexFlow = 'row'
	// presentation_control.style.position = "absolute"
	// presentation_control.style.right = "5%"
	// presentation_control.style.bottom = "5%"

	var present_next_button = document.createElement('button');
	present_next_button.className = 'display_transition_delay'
	present_next_button.style.position = "fixed";
	present_next_button.style.width = "40px";
	present_next_button.style.height = "40px";
	present_next_button.style.borderRadius = "20px";
	present_next_button.style.right = "5%";
	present_next_button.style.top = "calc(50% - 20px)";
	present_next_button.style.visibility = 'hidden'
	present_next_button.innerHTML = '<span class="fa fa-chevron-right"></span>'
	present_next_button.onclick = function(){
		editor.present_next();
	}

	var present_previous_button = document.createElement('button');
	present_previous_button.className = 'display_transition_delay'
	present_previous_button.style.position = "fixed";
	present_previous_button.style.width = "40px";
	present_previous_button.style.height = "40px";
	present_previous_button.style.borderRadius = "20px";
	present_previous_button.style.left = "5%";
	present_previous_button.style.top = "calc(50% - 20px)";
	present_previous_button.style.visibility = 'hidden'
	present_previous_button.innerHTML = '<span class="fa fa-chevron-left"></span>'
	present_previous_button.onclick = function(){
		editor.present_previous();
	}

	$(presentation_control).append(present_next_button);
	$(presentation_control).append(present_previous_button);


	var fullscreen_el = document.createElement('div');
	$(fullscreen_el).append(presentation_control);

	$(fullscreen_el).mousemove(function(e){
		present_next_button.style.visibility = 'visible';
		present_previous_button.style.visibility = 'visible';
		clearTimeout(this.fullscreen_hover_timer)
		this.fullscreen_hover_timer = setTimeout(function(){
			present_next_button.style.visibility = 'hidden';
			present_previous_button.style.visibility = 'hidden';
		},2000)
	})

	this.present = function(index){
		if(editor.present_index != null){
			//was already in present mode
		}else{
			editor.deselectElements()
			editor.draw();	
		}
		
		if(index == undefined){
			index = 0
		}
		var presentation_success = false;

		var aspect = editor.pages[index].canvas.width/editor.pages[index].canvas.height;
		var new_width;
		var new_height;

		var screen_width = Math.floor(window.screen.width);
		var screen_height = Math.floor(window.screen.height);

		if((screen_width/screen_height) > aspect){
			new_height = screen_height;
			new_width = aspect*screen_height;
		}else{
			new_width = screen_width;
			new_height = screen_width/aspect;
		}


		var cloned_canvas = cloneCanvas(editor.pages[index].canvas,editor.canvas_scale*new_width,editor.canvas_scale*new_height);
		cloned_canvas.className = "presentation_canvas"

		cloned_canvas.style.position = 'absolute';
		cloned_canvas.style.left = "calc(50% - "+(new_width/2)+"px";
		cloned_canvas.style.top = "calc(50% - "+(new_height/2)+"px";
		cloned_canvas.style.width = Math.floor(new_width)+"px";
		cloned_canvas.style.height = Math.floor(new_height)+"px";

		for (var i = fullscreen_el.children.length - 1; i >= 0; i--) {
			if(fullscreen_el.children[i].className == "presentation_canvas"){
				fullscreen_el.removeChild(fullscreen_el.children[i]);
			}
		}

		$(fullscreen_el).append(cloned_canvas);

		if(!fullscreen_el.parentElement){
			document.body.appendChild(fullscreen_el);
		}

		var onchange_fn = function(){
			if(document.webkitFullscreenElement){
				fullscreen_el.style.backgroundColor = '#000000'

				console.log('Entered present mode');
			}else{
				fullscreen_el.style.backgroundColor = ''
				document.body.removeChild(fullscreen_el);

				editor.present_index = null;
				console.log('Exited present mode');
			}
		}


		fullscreen_el.onwebkitfullscreenchange = onchange_fn;
		// fullscreen_el.onmozfullscreenchange = onchange_fn;

		if (fullscreen_el.requestFullScreen) {  
			fullscreen_el.requestFullScreen();  
			presentation_success = true;
		} else if (fullscreen_el.mozRequestFullScreen) {  
			fullscreen_el.mozRequestFullScreen();  
			presentation_success = true;
		} else if (fullscreen_el.webkitRequestFullScreen) {  
			fullscreen_el.webkitRequestFullScreen();  
			presentation_success = true;
		}

		if(presentation_success){
			editor.present_index = index;		
		}
	}

	this.print = function(filename){
		var width_in_mm = editor.convert_to_units(editor.get_width(),'mm');
		var height_in_mm = editor.convert_to_units(editor.get_height(),'mm');
		var doc_def = {
			pageSize: {width:mmToPDFPoints(width_in_mm),height:mmToPDFPoints(height_in_mm)},
	        content: []
	    };

	    syncForEach(editor.pages,function(page,page_number){
	    	return new Promise(function(res,rej){
				tempPrintFunction(page,page_number).then(function(){
					res();
				})
			}) 
		}).then(function(){
			printingFinished(doc_def)
		})

	    function printingFinished(doc_def,lastActivePage){
	    	pdfMake.createPdf(doc_def).download((filename || 'design')+'.pdf');
	    }
		
	    function tempPrintFunction(page,page_number){
	    	return new Promise(function(resolveTemp,reject){
				var image = page.export('high');
				doc_def.content[page_number] = {
					pageSize: {width:mmToPDFPoints(width_in_mm),height:mmToPDFPoints(height_in_mm)},
					image:image,
					width:mmToPDFPoints(width_in_mm),
					absolutePosition: {x: 0, y: 0}
				};
				if(page_number != editor.pages.length-1){
					doc_def.content[page_number].pageBreak= 'after'
				}
				resolveTemp()
			}).catch(function(err){
				console.log(err);
			})
	    }
	}

	this.style_ghost_image = function(loader_image){
		var x = (this.drag_details.raw_x - this.drag_details.offset_x)
		var y = (this.drag_details.raw_y - this.drag_details.offset_y)
		var action = this.active_page.getDragDropAction(this.drag_details.raw_x,this.drag_details.raw_y,this.drag_details.drag_type,loader_image);
		if(this.drag_ghost_image && this.drag_details){
			this.drag_ghost_image.style.transition = 'width 0.1s, height 0.1s'
			this.drag_ghost_image.style.zIndex = '100000'
			this.drag_ghost_image.style.position = 'fixed';
			this.drag_ghost_image.style.left = x + 'px'
			this.drag_ghost_image.style.top = y + 'px'
			if(action.enlarge){
				var aspect = this.drag_details.original_width/this.drag_details.original_height
				this.drag_ghost_image.style.width = action.width + 'px'
				this.drag_ghost_image.style.height = (action.width/aspect) + 'px'
			}else{
				this.drag_ghost_image.style.width = this.drag_details.original_width + 'px';
				this.drag_ghost_image.style.height = this.drag_details.original_height + 'px';
			}

			if(this.drag_details.replace_feedback && this.drag_details.replace_feedback.obj){
				if(this.drag_details.replace_feedback.obj == 'background'){
					this.active_page.background_needs_redraw = true
				}else{
					this.drag_details.replace_feedback.obj.set_redraw()
					if(this.drag_details.replace_feedback.box){
						this.drag_details.replace_feedback.box.loaded_attached_image = null;
					}
				}
			}

			if(action.vanish){
				this.drag_ghost_image.style.display = 'none'
				this.drag_details.replace_feedback = {
					obj: action.obj,
					box: action.box,
					replace_image: action.replace_image
				}
				if(action.obj == 'background'){
					this.active_page.background_needs_redraw = true
				}else{
					action.obj.set_redraw()
				}
			}else{
				this.drag_ghost_image.style.display = 'block'
				delete this.drag_details.replace_feedback
			}

			editor.needs_redraw = true;
		}
	}

	this.getTextHeight = function(fontFamily) {
		if(editor.font_heights[fontFamily] != undefined){
			return editor.font_heights[fontFamily]
		}

		var text = $('<span>Hg</span>').css({ fontFamily: fontFamily });
		var block = $('<div style="display: inline-block; width: 1px; height: 0px;"></div>');

		var div = $('<div></div>');
		div.append(text, block);

		var body = $('body');
		body.append(div);

		try {

			var result = {};

			block.css({ verticalAlign: 'baseline' });
			result.ascent = block.offset().top - text.offset().top;

			block.css({ verticalAlign: 'bottom' });
			result.height = block.offset().top - text.offset().top;

			result.descent = result.height - result.ascent;

		} finally {
			div.remove();
		}

		editor.font_heights[fontFamily] = result.height

		return result.height;
	}

	this.handleDrop = function(loader_image){
		if(!this.drag_details){
			return
		}

		var data = this.drag_details.data;
		var action = this.active_page.getDragDropAction(this.drag_details.raw_x,this.drag_details.raw_y,this.drag_details.drag_type,loader_image);
		delete this.drag_details.replace_feedback
		if(!action.valid_drop){
			return
		}

		if(this.drag_details.drag_type == 'template'){
			editor.load(data.data.design_file,loader_image)
			.then(function(){
				rct_update_pages(editor.pages.length);
				editor.needs_redraw = true;
				editor.addUndoChange()
				editor.handleWindowResize()
			})
		}else if(this.drag_details.drag_type == 'image' && action.obj != 'background'){
			if(!action.obj){
				var position = {x:(this.drag_details.raw_x - this.drag_details.offset_x),y:(this.drag_details.raw_y - this.drag_details.offset_y)}
				position = this.active_page.get_drag_point(position)
				var aspect = loader_image.clientWidth/loader_image.clientHeight
				var width = editor.get_width()*400/800

				if(data.data.id_123rf){
					var d = {
			            type: 'image',
			            sub_type: data.sub_type,
			            image_details:{
			                id_123rf: data.data.id_123rf,
			                image_width: width,
			                image_height: width/aspect
			            },
			            position: position,
			            width:width,
			            height: width/aspect,
			            loader_image: loader_image
			        }

			        if(data.data.mockup_id && data.data.inputs){
	                    d.sub_type = 'mockup'
	                    d.mockup_details = {
	                        id: data.data.mockup_id,
	                        inputs: data.data.inputs
	                    }
	                }
					this.active_page.addObject(d)
				}else if(data.data.id_pixlr){
					var d = {
			            type: 'image',
			            sub_type: data.sub_type,
			            image_details:{
			                id_pixlr: data.data.id_pixlr,
			                image_width: width,
			                image_height: width/aspect
			            },
			            position: position,
			            width:width,
			            height: width/aspect,
			            loader_image: loader_image
			        }

			        if(data.data.mockup_id && data.data.inputs){
	                    d.sub_type = 'mockup'
	                    d.mockup_details = {
	                        id: data.data.mockup_id,
	                        inputs: data.data.inputs
	                    }
	                }
					this.active_page.addObject(d)
				}else if(data.data.id_unsplash){
					var d = {
			            type: 'image',
			            sub_type: data.sub_type,
			            image_details:{
			                id_unsplash: data.data.id_unsplash,
			                image_width: width,
			                image_height: width/aspect
			            },
			            position: position,
			            width:width,
			            height: width/aspect,
			            loader_image: loader_image
			        }

			        if(data.data.mockup_id && data.data.inputs){
	                    d.sub_type = 'mockup'
	                    d.mockup_details = {
	                        id: data.data.mockup_id,
	                        inputs: data.data.inputs
	                    }
	                }
					this.active_page.addObject(d)
				}else if(data.data.resource_id){
					var d = {
			            type: 'image',
			            sub_type: data.sub_type,
			            image_details:{
			                resource_id: data.data.resource_id,
			                image_width: width,
			                image_height: width/aspect
			            },
			            position: position,
			            width:width,
			            height: width/aspect,
			            loader_image: loader_image
			        }

			        if(data.data.mockup_id && data.data.inputs){
	                    d.sub_type = 'mockup'
	                    d.mockup_details = {
	                        id: data.data.mockup_id,
	                        inputs: data.data.inputs
	                    }
	                }
					this.active_page.addObject(d)
				}else if(data.data.src){
					var d = {
			            type: 'image',
			            sub_type: data.sub_type,
			            image_details:{
			                src: data.data.src,
			                image_width: width,
			                image_height: width/aspect
			            },
			            position: position,
			            width:width,
			            height: width/aspect,
			            loader_image: loader_image
			        }

			        if(data.data.mockup_id && data.data.inputs){
	                    d.sub_type = 'mockup'
	                    d.mockup_details = {
	                        id: data.data.mockup_id,
	                        inputs: data.data.inputs
	                    }
	                }
					this.active_page.addObject(d)
				}
			}else if(action.obj.type == 'image'){
				action.obj.image_details.id_123rf = '';
				action.obj.image_details.id_pixlr = '';
	            action.obj.image_details.id_unsplash = ''
	            action.obj.image_details.resource_id = ''
	            action.obj.image_details.src = ''
	            action.obj.image_details.image_contain = null

	            if(data.data.id_123rf){
	                action.obj.image_details.id_123rf = data.data.id_123rf
	            }else if(data.data.id_pixlr){
	                action.obj.image_details.id_pixlr = data.data.id_pixlr
	            }else if(data.data.id_unsplash){
	                action.obj.image_details.id_unsplash = data.data.id_unsplash
	            }else if(data.data.resource_id){
	                action.obj.image_details.resource_id = data.data.resource_id
	            }else if(data.data.src){
	                action.obj.image_details.src = data.data.src
	            }

	            if(data.data.mockup_id && data.data.inputs){
	                action.obj.sub_type = 'mockup'
	                action.obj.mockup_details = {
	                    id: data.data.mockup_id,
	                    inputs: data.data.inputs
	                }
	            }else if(action.obj.sub_type == 'mockup'){
	            	action.obj.sub_type = null
	            }

	            action.obj.image_details.image_needs_autoset = true
	            action.obj.loader_image = loader_image
				action.obj.set_redraw()
	            this.draw()
			}else if(action.obj.type == 'grid' && action.box){
				if(!action.box.image){
					action.box.image = new designObject(this.active_page);
					action.box.image.master = action.box;
					action.box.image.type = 'image';
				}

				action.box.image.image_details.id_123rf = '';
				action.box.image.image_details.id_pixlr = '';
	            action.box.image.image_details.id_unsplash = ''
	            action.box.image.image_details.resource_id = ''
	            action.box.image.image_details.src = ''
	            action.box.image.image_details.image_contain = null

	            if(data.data.id_123rf){
	                action.box.image.image_details.id_123rf = data.data.id_123rf
	            }else if(data.data.id_pixlr){
	                action.box.image.image_details.id_pixlr = data.data.id_pixlr
	            }else if(data.data.id_unsplash){
	                action.box.image.image_details.id_unsplash = data.data.id_unsplash
	            }else if(data.data.resource_id){
	                action.box.image.image_details.resource_id = data.data.resource_id
	            }else if(data.data.src){
	                action.box.image.image_details.src = data.data.src
	            }

	            if(data.data.mockup_id && data.data.inputs){
	                action.box.image.sub_type = 'mockup'
	                action.box.image.mockup_details = {
	                    id: data.data.mockup_id,
	                    inputs: data.data.inputs
	                }
	            }else if(action.box.image.sub_type == 'mockup'){
	            	action.box.image.sub_type = null
	            }

	            action.box.image.image_details.image_needs_autoset = true

	            action.box.loader_image = loader_image
                action.box.loaded_attached_image = null;
                action.obj.set_redraw()
                action.box.image.set_redraw()
                this.draw()
			}
		}else if(this.drag_details.drag_type == 'background' || (this.drag_details.drag_type == 'image' && action.obj == 'background')){
			this.active_page.background_image.id_123rf = '';
			this.active_page.background_image.id_pixlr = '';
	        this.active_page.background_image.id_unsplash = ''
	        this.active_page.background_image.resource_id = ''
	        this.active_page.background_image.src = ''
	        this.active_page.background_details.image_contain = null;

	        if(data.data.id_123rf){
	            this.active_page.background_image.id_123rf = data.data.id_123rf
	        }else if(data.data.id_pixlr){
	            this.active_page.background_image.id_pixlr = data.data.id_pixlr
	        }else if(data.data.id_unsplash){
	            this.active_page.background_image.id_unsplash = data.data.id_unsplash
	        }else if(data.data.resource_id){
	            this.active_page.background_image.resource_id = data.data.resource_id
	        }else if(data.data.src){
	            this.active_page.background_image.src = data.data.src
	        }

	        this.active_page.background_details.filter = null
	        this.active_page.background_filter = {
	            brightness: 0,
	            contrast:0,
	            saturation:0,
	            tint:0,
	            blur: 0,
	            vignette: 0
	        }

	        this.active_page.background_bgremoval = {
	        	enabled: false,
	        	feather: 0,
	        	offset: 0,
	        	sharpness: 0,
	        	crf: 0,
	        	matting: 0,
            	cache:""
	        }

	        if(data.data.mockup_id && data.data.inputs){
                this.active_page.background_sub_type = 'mockup'
                this.active_page.background_mockup_details = {
                    id: data.data.mockup_id,
                    inputs: data.data.inputs
                }
            }else if(this.active_page.background_sub_type == 'mockup'){
            	this.active_page.background_sub_type = null
            }

	        this.active_page.background_loader_image = loader_image
	        this.active_page.background_details.image_needs_autoset = true;
	        this.active_page.background_needs_redraw = true
	        this.draw()
		}else if(this.drag_details.drag_type == 'text'){
	        var position = {x:(this.drag_details.raw_x - this.drag_details.offset_x),y:(this.drag_details.raw_y - this.drag_details.offset_y)}

			position = this.active_page.get_drag_point(position)
		    data.data.position = position
			var aspect = data.data.width/data.data.height
			var width = editor.get_width()*data.data.width/800
			var height = width/aspect
			var oldHeight = data.data.height

			data.data.width = width
			data.data.height = height

			data.data.text_details.letterSpacing *= (height/oldHeight)
			var oldLineHeight = data.data.text_details.lineHeight
			data.data.text_details.lineHeight *= (height/oldHeight)
			data.data.text_details.fontSize = ((Number(data.data.text_details.fontSize) + Number(oldLineHeight))*height/oldHeight) - Number(data.data.text_details.lineHeight)

			data.data.loader_image = loader_image

			this.active_page.addObject(data.data)
		}else if(this.drag_details.drag_type == 'text_template'){
			data.data.design_file.group.id = utils.uuidv4();
			var id_mapping = {}
			for (var i = 0; i < data.data.design_file.objects.length; i++) {
				var old_id = data.data.design_file.objects[i].id
	            data.data.design_file.objects[i].id = window.utils.uuidv4();
	            id_mapping[old_id] = data.data.design_file.objects[i].id
			}

			for (var i = 0; i < data.data.design_file.group.group_details.object_data.length; i++) {
	            data.data.design_file.group.group_details.object_data[i].object = id_mapping[data.data.design_file.group.group_details.object_data[i].object]
	        }

	        data.data.design_file.objects = _.sortBy(data.data.design_file.objects,function(o){
		        return o.layer_index
		    })

	        var position = {x:(this.drag_details.raw_x - this.drag_details.offset_x),y:(this.drag_details.raw_y - this.drag_details.offset_y)}
		    var aspect = loader_image.clientWidth/loader_image.clientHeight;
		    var image_width; var image_height;
	       
	        if(action.enlarge){
		    	image_width = action.width
		    	image_height = action.width/aspect
		    }else{
		    	image_width = loader_image.clientWidth
		    	image_height = loader_image.clientHeight
		    }

		    var group_aspect = data.data.design_file.group.width/data.data.design_file.group.height;
		    if(group_aspect > aspect){
		    	var group_height = image_width/group_aspect
		    	position.y += ((image_height - group_height)/2)
		    }else{
		    	var group_width = image_height*group_aspect
		    	position.x += ((image_width - group_width)/2)
		    }

			position = this.active_page.get_drag_point(position)
		    data.data.design_file.group.position = position
			
			var width = editor.get_width()*400/800
			var height = width/group_aspect
			var oldHeight = data.data.design_file.group.height

			data.data.design_file.group.width = width
			data.data.design_file.group.height = height

			for (var i = 0; i < data.data.design_file.objects.length; i++) {
				var child = data.data.design_file.objects[i]
				if(child.type == 'text'){
					child.text_details.letterSpacing *= (height/oldHeight)
					var oldLineHeight = child.text_details.lineHeight
					child.text_details.lineHeight *= (height/oldHeight)
					child.text_details.fontSize = ((Number(child.text_details.fontSize) + Number(oldLineHeight))*height/oldHeight) - Number(child.text_details.lineHeight)
				}
			}

			this.active_page.addGroup(data.data.design_file,undefined,true)
		}else if(this.drag_details.drag_type == 'grid'){
			var position = {x:(this.drag_details.raw_x - this.drag_details.offset_x),y:(this.drag_details.raw_y - this.drag_details.offset_y)}
			position = this.active_page.get_drag_point(position)
			var width = editor.get_width()*600/800
	        var file = deref(data.data.design_file);
	        file.position = position
	        file.width = width
	        file.height = width;

			this.active_page.addObject(file)
		}else if(this.drag_details.drag_type == 'frame'){
			var position = {x:(this.drag_details.raw_x - this.drag_details.offset_x),y:(this.drag_details.raw_y - this.drag_details.offset_y)}
			position = this.active_page.get_drag_point(position)
			var width = editor.get_width()*400/800
	        var file = deref(data.data);
	        file.position = position
	        file.width = width
	        file.height = width;

	        file.grid_details.boxes[0].loader_image_frame = loader_image

			this.active_page.addObject(file)
		}
	}

	function redraw_listener() {

	    if (editor.needs_redraw) {
	        editor.draw()
	        editor.needs_redraw = false
	        redraw_listener()
	    }else if(!editor.render_timer_destroyed){
	    	clearTimeout(editor.render_timer);
	        editor.render_timer = setTimeout(redraw_listener, 20)
	    }
	}

	if(!this.dont_activate_controller){
		redraw_listener()
	}

	this.redraw_listener = redraw_listener

	this.destroy = function(){
		editor.render_timer_destroyed = true
		for (var i = 0; i < editor.pages.length; i++) {
			editor.pages[i].deactivateController();
			editor.pages[i].render_timer_destroyed = true;
		}
	}

	this.get_width = function(){
		if(editor.dimension_units == 'px'){
			return editor.width
		}else{
			return this.convert_to_px(editor.width,editor.dimension_units)
		}
	}

	this.get_height = function(){
		if(editor.dimension_units == 'px'){
			return editor.height
		}else{
			return this.convert_to_px(editor.height,editor.dimension_units)
		}
	}

	this.set_redraw_all_objects = function(type){
		var all_objects = []
		for (var i = 0; i < editor.pages.length; i++) {
			all_objects = all_objects.concat(editor.pages[i].objects);
		}

		if(type == 'text'){
			all_objects = all_objects.filter(function(o){
				return o.type == 'text'
			})
		}

		for (var i = 0; i < all_objects.length; i++) {
			all_objects[i].set_redraw();
		}
	}

	this.getAllFonts = function(){
		var result = [];
		for (var i = 0; i < editor.pages.length; i++) {
			for (var j = 0; j < editor.pages[i].objects.length; j++) {
				var obj = editor.pages[i].objects[j];
				if(obj.type == 'text'){
					result.push({
						font: obj.text_details.font,
						font_src: obj.text_details.font_src
					})
				}
			}
		}

		return _.uniqWith(result,function(a, b){
			return a.font == b.font;
		})
	}

	this.getAllResources = function(){
		var result = []
		for (var i = 0; i < editor.pages.length; i++) {
			if(editor.pages[i].background_image.id_123rf){
				result.push({
					id: editor.pages[i].background_image.id_123rf,
					type: '123rf',
					object_id: 'background_'+i,
					src: editor.pages[i].background_image.src
				})
			}else if(editor.pages[i].background_image.resource_id){
				result.push({
					id: editor.pages[i].background_image.resource_id,
					type: 'design_resource',
					object_id: 'background_'+i
				})
			}else if(editor.pages[i].background_image.id_pixlr){
				result.push({
					id: editor.pages[i].background_image.id_pixlr,
					type: 'pixlr',
					object_id: 'background_'+i
				})
			}

			for (var j = 0; j < editor.pages[i].objects.length; j++) {
				if(editor.pages[i].objects[j].type == 'image'){
					if(editor.pages[i].objects[j].image_details.id_123rf){
						result.push({
							id: editor.pages[i].objects[j].image_details.id_123rf,
							type: '123rf',
							object_id: editor.pages[i].objects[j].id
						})
					}else if(editor.pages[i].objects[j].image_details.resource_id){
						result.push({
							id: editor.pages[i].objects[j].image_details.resource_id,
							type: 'design_resource',
							object_id: editor.pages[i].objects[j].id
						})
					}else if(editor.pages[i].objects[j].image_details.id_pixlr){
						result.push({
							id: editor.pages[i].objects[j].image_details.id_pixlr,
							type: 'pixlr',
							object_id: editor.pages[i].objects[j].id
						})
					}
				}else if(editor.pages[i].objects[j].type == 'grid'){
					var boxes = editor.pages[i].objects[j].grid_details.boxes
					for (var b = 0; b < boxes.length; b++) {
						if(boxes[b].image && boxes[b].image.image_details.id_123rf){
							result.push({
								id: boxes[b].image.image_details.id_123rf,
								type: '123rf',
								object_id: boxes[b].image.id,
								src: boxes[b].image.image_details.src
							})
						}else if(boxes[b].image && boxes[b].image.image_details.resource_id){
							result.push({
								id: boxes[b].image.image_details.resource_id,
								type: 'design_resource',
								object_id: boxes[b].image.id
							})
						}else if(boxes[b].image && boxes[b].image.image_details.id_pixlr){
							result.push({
								id: boxes[b].image.image_details.id_pixlr,
								type: 'pixlr',
								object_id: boxes[b].image.id
							})
						}
					}
				}
			}
		}

		result = result.filter(function(o){
			return o.type != 'design_resource';
		})

		return _.uniqWith(result,function(a, b){
			return a.type == b.type && a.id == b.id;
		})
	}

	this.handlePurchaseRedraw = function(id_array){
		return new Promise(function(res,rej){
			var dummy_src = design_editor.pages[0].export('low')
			editor.loaded_images = {}
			editor.loading_images = []


			for (var i = 0; i < editor.pages.length; i++) {
				for (var j = 0; j < editor.pages[i].objects.length; j++) {
					var obj = editor.pages[i].objects[j]
					if(obj.type == 'grid'){
						var boxes = obj.grid_details.boxes
						for(var b=0;b<boxes.length;b++){
							if(boxes[b].loaded_attached_frame){
								delete boxes[b].loaded_attached_frame
							}

							if(boxes[b].loaded_attached_image){
								delete boxes[b].loaded_attached_image
							}
						}
					}
					obj.set_redraw()
				}
			}

			var dummy_image = new Image();
			dummy_image.onload = function(){
				editor.loader_image = dummy_image
				editor.draw()
				editor.wait_to_load()
				.then(function(){
					editor.loader_image = null;
					editor.draw();	
					res()
				})
			}
			dummy_image.src = dummy_src
		})
			
	}

	this.getImageObjectById = function(id){
		for (var i = 0; i < editor.pages.length; i++) {
			for (var j = 0; j < editor.pages[i].objects.length; j++) {
				if(editor.pages[i].objects[j].id == id){
					return editor.pages[i].objects[j].id
				}else if(editor.pages[i].objects[j].type == 'grid'){
					var boxes = editor.pages[i].objects[j].grid_details.boxes
					for (var i = 0; i < boxes.length; i++) {
						if(boxes[i].image && boxes[i].image.id == id){
							return boxes[i].image
						}
					}
				}
			}
		}

		return null
	}

	this.convert_to_px = function(d,units){
        if(units == 'mm'){
        	return d*3.78
        }else if(units == 'cm'){
        	return d*37.8
        }else if(units == 'in'){
        	return d*96
        }
    }

    this.convert_to_units = function(d,units){
        if(units == 'mm'){
        	return d/3.78
        }else if(units == 'cm'){
        	return d/37.8
        }else if(units == 'in'){
        	return d/96
        }
    }

    this.findDominantColorObjects = function(){
	    var selected_seed_objects = [];
    	var max_area = -Infinity;

	    for (var s = 0; s < editor.pages[0].objects.length+1; s++) {
	    	if(s!=0 && !selected_seed_objects[s-1]){
	    		break;
	    	}

	    	if(!editor.pages[0].background_image_exists() && !selected_seed_objects.find(function(o){return o.object == 'background'})){
		    	var area = editor.pages[0].getBackgroundExposedArea();
	    		max_area = area;
	    		selected_seed_objects[s] = {
	    			object: 'background',
    				max_area: max_area
	    		}
	    	}else{
	    		max_area = -Infinity
	    	}

	    	for (var i = 0; i < editor.pages[0].objects.length; i++) {
	    		if(editor.pages[0].objects[i].type == 'grid'){
	    			var boxes = editor.pages[0].objects[i].grid_details.boxes
	    			for(var b=0;b<boxes.length;b++){
	    				if(!boxes[b].image && boxes[b].color && !selected_seed_objects.find(function(o){return o.ref == boxes[b]}) ){
	    					var area = editor.pages[0].getGridBoxExposedArea(boxes[b])
	    					if(area > max_area){
	    						max_area = area;
	    						selected_seed_objects[s] = {
	    							object: 'grid_box',
	    							ref: boxes[b],
    								max_area: max_area
	    						}
	    					}
	    				}
	    			}
	    		}else if(editor.pages[0].objects[i].type == 'image' && editor.pages[0].objects[i].sub_type == 'icon'){
					if(editor.pages[0].objects[i].image_details.svg_colors.length>0 && !selected_seed_objects.find(function(o){return o.ref == editor.pages[0].objects[i]})){
						var area = editor.pages[0].getObjectExposedArea(editor.pages[0].objects[i])
						if(area > max_area){
							max_area = area;
							selected_seed_objects[s] = {
								object: 'icon',
								ref: editor.pages[0].objects[i],
    							max_area: max_area
							}
						}
					}
	    		}
	    	}
	    }
	
	    return selected_seed_objects;
    }

    this.findDominantColors = function(){
    	var seed_objects = editor.findDominantColorObjects();
    	var r = []

    	for (var i = 0; i < seed_objects.length; i++) {
    		if(seed_objects[i] && seed_objects[i].max_area>0){
	    		if(seed_objects[i].object == 'background'){
					r.push(editor.pages[0].background_color)
	    		}else if(seed_objects[i].object == 'grid_box'){
	    			r.push(seed_objects[i].ref.color)
	    		}else if(seed_objects[i].object == 'icon'){
	    			r.push(seed_objects[i].ref.image_details.svg_colors[0].color)
	    		}
	    	}
    	}
	    
    	return _.uniq(r);
    }

    this.fixTextContrast = function(available_colors){
    	try{
    		return new Promise(function(res,rej){
    			editor.draw();
				editor.wait_to_load()
				.then(function(){
					editor.draw();
					var texts = []
			    	for (var i = 0; i < editor.pages.length; i++){
			    		for(var j=0;j < editor.pages[i].objects.length;j++){
			    			if(editor.pages[i].objects[j].type == 'text'){
			    				editor.pages[i].objects[j].old_opacity = editor.pages[i].objects[j].opacity
						    	editor.pages[i].objects[j].opacity = 0
						    	editor.pages[i].objects[j].set_redraw();
			    			}
			    		}
			    		editor.pages[i].draw();

			    		for(var j=0;j < editor.pages[i].objects.length;j++){
			    			if(editor.pages[i].objects[j].type == 'text'){
			    				var obj = editor.pages[i].objects[j]
			    				var color_behind = editor.getColorBehindText(obj)
			    				var hex = chroma('rgb('+Math.round(color_behind[0])+','+Math.round(color_behind[1])+','+Math.round(color_behind[2])+')' ).get('hex')
			    				var contrast = chroma.contrast(obj.text_details.fontColor,hex);
			    				if(contrast < 3.75){
			    					var test_colors = [
			    						chroma.average([obj.text_details.fontColor,'black']).get('hex'),
			    						chroma.average([obj.text_details.fontColor,'white']).get('hex')
		    						].concat(available_colors)
			    					for(var c = 0;c < test_colors.length;c++){
			    						var test_contrast = chroma.contrast(test_colors[c],hex)
			    						if(test_contrast > 3.75){
			    							var new_color = test_colors[c]
					    					obj.text_details.fontColor = new_color
					    					obj.set_redraw()
					    					obj.master.drawText(obj);
					    					break;
			    						}
			    					}
			    				}
			    			}
			    		}

			    		for(var j=0;j < editor.pages[i].objects.length;j++){
			    			if(editor.pages[i].objects[j].type == 'text'){
			    				editor.pages[i].objects[j].opacity = editor.pages[i].objects[j].old_opacity
			    				delete editor.pages[i].objects[j].old_opacity
						    	editor.pages[i].objects[j].set_redraw();
			    			}
			    		}

			    		editor.pages[i].draw();
			    	}

			    	res()
				})
    		})
	    }catch(err){
	    	return Promise.resolve()
	    	console.log(err);
	    }
    }

    this.getColorBehindText = function(obj){
    	try{
	    	var page = obj.master;
	    	var bbox = utils.get2dBoundingBox(obj.getVertices().map(function(o){
	    		return {x: page.convertX(o.x),y: page.convertY(o.y)}
	    	}))
	    	var image_data = page.canvas.getContext('2d').getImageData(bbox.minX, bbox.minY, bbox.maxX - bbox.minX, bbox.maxY - bbox.minY);
	    	return averageColor(image_data)
	    }catch(err){
	    	console.log(err);
	    	return [0,0,0];
	    }
    }

    this.colorSwap = function(index,seed_colors){
    	if(!seed_colors || seed_colors.length < 1){
    		console.log('no seed colors were provided to color swap. returning without any changes.');
    		return Promise.resolve()
    	}

    	return new Promise(function(resolve,reject){
	    	var prom_array = []
	    	
	    	//detecting colors
	    	var colors_detected = []
	    	for(var i = 0; i < editor.pages.length; i++) {
	    		for (var j = 0; j < editor.pages[i].objects.length; j++) {
					if(editor.pages[i].objects[j].type == 'grid'){
						for(var b=0;b<editor.pages[i].objects[j].grid_details.boxes.length;b++){
							if(!editor.pages[i].objects[j].grid_details.boxes[b].image && editor.pages[i].objects[j].grid_details.boxes[b].color){
								colors_detected.push({
									color: editor.pages[i].objects[j].grid_details.boxes[b].color
								})
							}
						}
					}else if(editor.pages[i].objects[j].type == 'image' && editor.pages[i].objects[j].sub_type == 'icon'){
						for(var b=0;b<editor.pages[i].objects[j].image_details.svg_colors.length;b++){
							colors_detected.push({
								color: editor.pages[i].objects[j].image_details.svg_colors[b].color
							})
						}
					}else if(editor.pages[i].objects[j].type == 'text'){
						colors_detected.push({
							color: editor.pages[i].objects[j].text_details.fontColor
						})

						colors_detected.push({
							color: editor.pages[i].objects[j].text_details.glowColor
						})

						colors_detected.push({
							color: editor.pages[i].objects[j].text_details.strokeColor
						})

						for(var b=0;b<editor.pages[i].objects[j].text_details.shadows.length;b++){
							colors_detected.push({
								color: editor.pages[i].objects[j].text_details.shadows[b].shadowColor
							})
						}
					}
	    		}

				if(!(editor.pages[i].background_image_exists())){
					colors_detected.push({
						color: editor.pages[i].background_color
					})
				}else if(editor.pages[i].background_details.filter_color){
					colors_detected.push({
						color: editor.pages[i].background_details.filter_color
					})
				}
	    	}

	    	// colors_detected = colors_detected.map(function(o){
	    	// 	o.color = o.color.toLowerCase();
	    	// 	return o
	    	// })

	    	colors_detected = colors_detected.filter(function(o){
	    		return o.color.length == 7
	    	})

	    	colors_detected = _.uniqBy(colors_detected,function(o){return o.color})

	    	colors_detected = colors_detected.map(function(o){
	    		return {
	    			new_color: chroma(o.color.toLowerCase()).get('hsl'),
	    			old_color: o.color
	    		}
	    	})

	    	for (var i = 0; i < colors_detected.length; i++) {
	    		if(isNaN(colors_detected[i].new_color[0])){
	    			colors_detected[i].new_color[0] = 0
	    		}
	    	}

	    	//setting_seed_colors
	    	var initial_colors = [];
	    	var target_colors = [];

	    	if(index>0){
		    	var mod = (index-1)%4
		    	if(mod == 0){
		    		for (var i = 0; i < seed_colors.length; i++) {
			    		target_colors[i] = chroma(seed_colors[i]).get('hsl');
			    	}
		    		// target_colors[0] = chroma(seed_colors[0]).get('hsl');
			    	// target_colors[1] = chroma(seed_colors[1]).get('hsl');
			    }else if(mod == 1){
			    	target_colors[0] = chroma(seed_colors[1]).get('hsl');
			    	target_colors[1] = chroma(seed_colors[0]).get('hsl');
			    }else if(mod == 2){
		    		target_colors[0] = chroma(seed_colors[0]).get('hsl');
			    }else if(mod == 3){
			    	target_colors[0] = chroma(seed_colors[1]).get('hsl');
			    }

			    if(index>3 && index < 8){
			    	for (var i = 0; i < target_colors.length; i++) {
			    		target_colors[i][0] = (target_colors[i][0] - 15);
			    	}
			    }
			    if(index > 7 && index < 12){
			    	for (var i = 0; i < target_colors.length; i++) {
			    		target_colors[i][0] = (target_colors[0][0] + 15);
			    	}
			    }

			    if(index > 11 && index < 16){
			    	for (var i = 0; i < target_colors.length; i++) {
			    		target_colors[i][0] = (target_colors[0][0] - 25);
			    	}
			    }

			    if(index > 15 && index < 20){
			    	for (var i = 0; i < target_colors.length; i++) {
			    		target_colors[i][0] = (target_colors[0][0] + 25);
			    	}
			    }

			    if(index > 19 && index < 24){
			    	for (var i = 0; i < target_colors.length; i++) {
			    		target_colors[i][0] = (target_colors[0][0] - 45);
			    	}
			    }

			    if(index > 23 && index < 28){
			    	for (var i = 0; i < target_colors.length; i++) {
			    		target_colors[i][0] = (target_colors[0][0] + 45);
			    	}
			    }
			}else{
				if(index == 0){
					resolve()
					return
				}
			}

			for (var i = 0; i < target_colors.length; i++) {
				if(target_colors[i] && isNaN(target_colors[i][0])){
		    		target_colors[i][0] = 0
		    	}
			}


	    	var dominant_colors = editor.findDominantColors();

	    	for (var i = 0; i < target_colors.length; i++) {
	    		if(dominant_colors[i]){
		    		initial_colors[i] = dominant_colors[i]
	    		}else{
	    			break;
	    		}
	    	}

	    	var hue_angle_shifts = [];
	    	var saturation_angle_shifts = [];
	    	var light_angle_shifts = [];

	    	for (var i = 0; i < initial_colors.length; i++) {
	    		initial_colors[i] = chroma(initial_colors[i]).get('hsl');

	    		if(initial_colors[i] && isNaN(initial_colors[i][0])){
		    		initial_colors[i][0] = 0
		    	}
	    		
	    		hue_angle_shifts[i] = target_colors[i][0] - initial_colors[i][0];
	    		saturation_angle_shifts[i] = target_colors[i][1] - initial_colors[i][1];
	    		light_angle_shifts[i] = target_colors[i][2] - initial_colors[i][2];
	    	}

	    	colors_detected = colors_detected.map(function(o){
	    		var matched_index = _.findIndex(initial_colors, function(p){
	    			return Math.abs(o.new_color[0] - p[0])<1 && Math.abs(o.new_color[1] - p[1])<0.01 && Math.abs(o.new_color[2] - p[2])<0.01
	    		})

	    		if(matched_index != -1){
	    			o.new_color[0] = target_colors[matched_index][0];
	    			o.new_color[1] = target_colors[matched_index][1];
	    			o.new_color[2] = target_colors[matched_index][2];
	    		}else{
	    			var least_distance_index;
	    			var least_distance = _.minBy(initial_colors, function(p){
	    				return Math.abs(o.new_color[0] - p[0]);
	    			})

	    			least_distance_index = initial_colors.indexOf(least_distance);

	    			o.new_color[0] += hue_angle_shifts[least_distance_index];
			    		
		    		var old_s = o.new_color[1]
	    			o.new_color[1] += saturation_angle_shifts[least_distance_index]
	    			if(old_s < 0.15 && o.new_color[1]>0.15){
	    				o.new_color[1] = 0.15
	    			}else if(old_s > 0.85 && o.new_color[1]<0.85){
	    				o.new_color[1] = 0.85
	    			}else if(old_s < 0.85 && old_s > 0.15){
	    				if(o.new_color[1]>0.85){
	    					o.new_color[1] = 0.85
	    				}else if(o.new_color[1]<0.15){
	    					o.new_color[1] = 0.15
	    				}
	    			}

	    			var old_l = o.new_color[2]
		    		o.new_color[2] += light_angle_shifts[least_distance_index]
		    		if(old_l < 0.15 && o.new_color[2]>0.15){
	    				o.new_color[2] = 0.15
	    			}else if(old_l > 0.85 && o.new_color[2]<0.85){
	    				o.new_color[2] = 0.85
	    			}else if(old_l < 0.85 && old_l > 0.15){
	    				if(o.new_color[2]>0.85){
	    					o.new_color[2] = 0.85
	    				}else if(o.new_color[2]<0.15){
	    					o.new_color[2] = 0.15
	    				}
	    			}

		    		if(o.new_color[0] > 360){
		    			o.new_color[0] -= 360
		    		}else if(o.new_color[0]<0){
		    			o.new_color[0] += 360
		    		}

		    		if(o.new_color[1] > 1){
		    			o.new_color[1] = 1 - saturation_angle_shifts[least_distance_index]
		    		}

		    		if(o.new_color[2] > 1){
		    			o.new_color[2] = 1 - light_angle_shifts[least_distance_index]
		    		}

		    		if(o.new_color[1] < 0){
		    			o.new_color[1] = 0.15
		    		}

		    		if(o.new_color[2] < 0){
		    			o.new_color[2] = 0.15
		    		}
	    		}

	    		o.new_color = chroma('hsl('+Math.round(o.new_color[0])+','+(o.new_color[1]*100).toFixed(2)+'%,'+(o.new_color[2]*100).toFixed(2)+'%)').get('hex')
	    		return o
	    	})

	    	for (var i = 0; i < editor.pages.length; i++) {
	    		for (var j = 0; j < editor.pages[i].objects.length; j++) {
					if(editor.pages[i].objects[j].type == 'grid'){
						for(var b=0;b<editor.pages[i].objects[j].grid_details.boxes.length;b++){
							if(!editor.pages[i].objects[j].grid_details.boxes[b].image && editor.pages[i].objects[j].grid_details.boxes[b].color){
								var find = colors_detected.find(function(o){return o.old_color == editor.pages[i].objects[j].grid_details.boxes[b].color});
								if(find){
									editor.pages[i].objects[j].grid_details.boxes[b].color = find.new_color
									editor.pages[i].objects[j].set_redraw()
								}
							}
						}
					}else if(editor.pages[i].objects[j].type == 'image' && editor.pages[i].objects[j].sub_type == 'icon'){
						for(var b=0;b<editor.pages[i].objects[j].image_details.svg_colors.length;b++){
							var find = colors_detected.find(function(o){return o.old_color == editor.pages[i].objects[j].image_details.svg_colors[b].color});
							if(find){
								editor.pages[i].objects[j].image_details.svg_colors[b].color = find.new_color
								editor.pages[i].objects[j].set_redraw()
							}
						}
						prom_array.push(
							editor.pages[i].objects[j].updateColors()
						)
					}else if(editor.pages[i].objects[j].type == 'text'){
						var find = colors_detected.find(function(o){return o.old_color == editor.pages[i].objects[j].text_details.fontColor});
						if(find){
							editor.pages[i].objects[j].text_details.fontColor = find.new_color
							editor.pages[i].objects[j].set_redraw()
						}

						var find = colors_detected.find(function(o){return o.old_color == editor.pages[i].objects[j].text_details.glowColor});
						if(find){
							editor.pages[i].objects[j].text_details.glowColor = find.new_color
							editor.pages[i].objects[j].set_redraw()
						}

						var find = colors_detected.find(function(o){return o.old_color == editor.pages[i].objects[j].text_details.strokeColor});
						if(find){
							editor.pages[i].objects[j].text_details.strokeColor = find.new_color
							editor.pages[i].objects[j].set_redraw()
						}

						for(var b=0;b<editor.pages[i].objects[j].text_details.shadows.length;b++){
							var find = colors_detected.find(function(o){return o.old_color == editor.pages[i].objects[j].text_details.shadows[b].shadowColor});
							if(find){
								editor.pages[i].objects[j].text_details.shadows[b].shadowColor = find.new_color
								editor.pages[i].objects[j].set_redraw()
							}
						}
					}
	    		}

				if(!(editor.pages[i].background_image_exists())){
					var find = colors_detected.find(function(o){return o.old_color == editor.pages[i].background_color});
					if(find){
			    		editor.pages[i].background_color = find.new_color
			    		editor.pages[i].background_needs_redraw = true;
					}
				}else if(editor.pages[i].background_details.filter_color){
					var find = colors_detected.find(function(o){return o.old_color == editor.pages[i].background_details.filter_color});
					if(find){
			    		editor.pages[i].background_details.filter_color = find.new_color
			    		editor.pages[i].background_needs_redraw = true;
					}
				}
	    	}

	    	Promise.all(prom_array).then(function(){
	    		editor.fixTextContrast(colors_detected.map(function(o){return o.new_color}).concat(['#ffffff','#000000']))
	    		.then(function(){
	    			resolve()
	    		})
	    	})
    	})
    }

    this.wait_to_load = function(){
    	return Promise.all(editor.resource_promise_array)
    	.then(function(){
    		return Promise.resolve()
    	}).catch(function(){
    		return Promise.resolve()
    	})
    }

    this.first_unequal_index = function(str1,str2){
    	for(var c=0;c<str1.length;c++){
    		if(str1[c] != str2[c]){
    			return c
    		}
    	}

    	return undefined
    }

    this.fontSwapWithFontTriplets = function(given_fonts){
    	var changed = [];
    	var prom_array = [];
    	editor.undo_stack_disabled = true;
    	for (var i = 0; i < this.pages.length; i++) {
    		var texts = this.pages[i].objects.filter(function(o){
    			return o.type == 'text'
    		});

    		var largest_box = _.maxBy(texts,function(o){return o.text_details.fontSize});

    		if(largest_box){
    			largest_box.old_line = _.maxBy(largest_box.lines,function(o){return o.length});
	    		if(!largest_box.old_line){
	    			console.log('SOMETHING WENT WRONG IN FONT SWAP')
	    			largest_box.old_line = largest_box.text_details.text
	    		}
	    		largest_box.old_width = largest_box.getStringWidth(largest_box.old_line);
	    		largest_box.old_height = largest_box.height;
    			largest_box.text_details.font = given_fonts[0].font;
    			largest_box.text_details.font_src = given_fonts[0].font_src;
    			largest_box.set_redraw();
    			changed.push(largest_box)
    			this.pages[i].drawText(largest_box);
	    		prom_array.push(editor.wait_to_load());

    			_.pull(texts,largest_box);

    			var second_largest_box = _.maxBy(texts,function(o){return o.text_details.fontSize});

    			if(second_largest_box){
    				second_largest_box.old_line = _.maxBy(second_largest_box.lines,function(o){return o.length});
		    		if(!second_largest_box.old_line){
		    			console.log('SOMETHING WENT WRONG IN FONT SWAP')
		    			second_largest_box.old_line = second_largest_box.text_details.text
		    		}
		    		second_largest_box.old_width = second_largest_box.getStringWidth(second_largest_box.old_line);
		    		second_largest_box.old_height = second_largest_box.height;

    				second_largest_box.text_details.font = given_fonts[1].font;
    				second_largest_box.text_details.font_src = given_fonts[1].font_src;
    				second_largest_box.set_redraw();
    				changed.push(second_largest_box);
    				this.pages[i].drawText(second_largest_box);
	    			prom_array.push(editor.wait_to_load());

    				_.pull(texts,second_largest_box);
    				for(var o=0;o<texts.length;o++){
    					texts[o].old_line = _.maxBy(texts[o].lines,function(o){return o.length});
			    		if(!texts[o].old_line){
			    			console.log('SOMETHING WENT WRONG IN FONT SWAP')
			    			texts[o].old_line = texts[o].text_details.text
			    		}
			    		texts[o].old_width = texts[o].getStringWidth(texts[o].old_line);
			    		texts[o].old_height = texts[o].height;

    					texts[o].text_details.font = given_fonts[2].font;
    					texts[o].text_details.font_src = given_fonts[2].font_src;
    					texts[o].set_redraw();
    					changed.push(texts[o]);
    					this.pages[i].drawText(texts[o]);
	    				prom_array.push(editor.wait_to_load());
    				}
    			}
    		}
    	}

    	return Promise.all(prom_array).then(function(){
    		for (var i = 0; i < changed.length; i++) {
	    		var obj = changed[i];
	    		if(obj.old_line){
	    			obj.set_redraw()
	    			editor.pages[0].drawText(obj);
	    			var old_line = obj.old_line

	    			var new_width = obj.getStringWidth(obj.old_line);

					obj.text_details.letterSpacing += ((obj.old_width - new_width - 1)/(old_line.length-1))
							    			
	    			delete obj.old_line
	    			delete obj.old_width
	    			delete obj.old_height
	    			obj.set_redraw()
	    		}
    		}
			
			editor.undo_stack_disabled = false;
			editor.addUndoChange();
			return Promise.resolve();
    	}).catch(function(err){
    		console.log(err);
    		editor.undo_stack_disabled = false;
    	})

    	editor.needs_redraw = true;
    }

    this.fontSwap = function(index){
    	var prom_array = [];
    	var object_mapper = [];
    	for (var i = 0; i < this.pages.length; i++) {
    		for (var j = 0; j < this.pages[i].objects.length; j++) {
    			if(this.pages[i].objects[j].type == 'text'){
    				this.pages[i].objects[j].set_redraw()
    				this.pages[i].drawText(this.pages[i].objects[j])
    				prom_array.push(
    					fetch(
    						server_path + 'design_resource/font_pairer', {method: 'POST','credentials': 'include',headers: {'Content-Type':'application/json'}, body:JSON.stringify({font_name: this.pages[i].objects[j].text_details.font})}
						).then(function(r){
							return r.json()
						})
					)


    				object_mapper.push([i,j]);

    			}
    		}
    	}

    	return Promise.all(prom_array).then(function(resps){
    		var prom_array2 = [];
    		for (var i = 0; i < resps.length; i++) {
    			if(resps[i].response_code == 1 && resps[i].data){
		    		var obj = editor.pages[object_mapper[i][0]].objects[object_mapper[i][1]];

		    		obj.old_line = _.maxBy(obj.lines,function(o){return o.length});
		    		if(!obj.old_line){
		    			console.log('SOMETHING WENT WRONG IN FONT SWAP')
		    			obj.old_line = obj.text_details.text
		    		}
		    		obj.old_width = obj.getStringWidth(obj.old_line);
		    		obj.old_height = obj.height;

		    		if(resps[i].data[index] && resps[i].data[index].name && resps[i].data[index].src){
			    		obj.text_details.font = resps[i].data[index].name;
			    		obj.text_details.font_src = resps[i].data[index].src;
			    	}

		    		obj.set_redraw()
    				editor.pages[0].drawText(obj);
		    		prom_array2.push(editor.wait_to_load());
		    	}
    		}


    		return Promise.all(prom_array2).then(function(){
    			for (var i = 0; i < resps.length; i++) {
		    		var obj = editor.pages[object_mapper[i][0]].objects[object_mapper[i][1]];
		    		if(obj.old_line){
		    			obj.set_redraw()
		    			editor.pages[0].drawText(obj);
		    			var old_line = obj.old_line

		    			var new_width = obj.getStringWidth(obj.old_line);

						// obj.text_details.fontSize *= obj.old_height/obj.height
						// obj.set_redraw()
						// editor.pages[0].drawText(obj);

						obj.text_details.letterSpacing += ((obj.old_width - new_width - 1)/(old_line.length-1))
						// obj.text_details.lineHeight += ((obj.old_height - obj.height)/obj.lines.length)
								    			
		    			delete obj.old_line
		    			delete obj.old_width
		    			delete obj.old_height
		    			obj.set_redraw()
		    		}
	    		}
    			return Promise.resolve();
    		})
    	})
    }

    this.magicResizeOld = function(target_width,target_height,target_dimension_units){
		var new_width = target_width;
		var new_height = target_height;

		if(target_dimension_units != 'px'){
			new_width = this.convert_to_px(new_width,target_dimension_units)
			new_height = this.convert_to_px(new_height,target_dimension_units)
		}

		for (var i = 0; i < this.pages.length; i++) {
			this.pages[i].groups = []
			var objs = this.pages[i].objects.slice()
			var textboxes = objs.filter(function(o){return o.type == 'text'});
			var already_colliding = {}
			this.pages[i].background_details.image_needs_autoset = true
			this.pages[i].background_needs_redraw = true;
			for(var j=0;j<textboxes.length;j++){
				for(var k=0;k<textboxes.length;k++){
					if(j!=k){
						var tj = textboxes[j];
						var tk = textboxes[k];
						if((tj.position.y+tj.height)>tk.position.y && (tj.position.y+tj.height)<(tk.position.y+tk.height)){
							already_colliding[j] = k
							already_colliding[k] = j
						}

						if((tk.position.y+tk.height)>tj.position.y && (tk.position.y+tk.height)<(tj.position.y+tj.height)){
							already_colliding[j] = k
							already_colliding[k] = j
						}
					}
				}
			}

			for(var j=0; j< objs.length;j++){
				var o = objs[j]

				if(objs[j].type == 'grid'){
					for(var b=0;b<objs[j].grid_details.boxes.length;b++){
						if(objs[j].grid_details.boxes[b].image){
							objs[j].grid_details.boxes[b].image.image_details.image_needs_autoset = true
						}
					}
				}

				//positioning
				var center = o.getCenter();
				var center_x_ratio = (center.x/this.get_width());
				var center_y_ratio = (center.y/this.get_height());
				var new_center = {x:center.x,y:center.y};
				new_center.x = center_x_ratio*new_width
				new_center.y = center_y_ratio*new_height

				//resizing
				var width_ratio = (o.width/this.get_width())
				var height_ratio = (o.height/this.get_height())

				var old_width = o.width;var old_height = o.height;
				var old_aspect = o.width/o.height;
				var new_aspect = (width_ratio*new_width)/(height_ratio*new_height);
				if(o.type == 'text'){
					if(new_aspect < old_aspect){
						o.width = width_ratio*new_width
						o.height = o.width/old_aspect
					}else{
						o.height = height_ratio*new_height
						o.width = o.height*old_aspect
					}
				}else{
					if(new_aspect > old_aspect){
						o.width = width_ratio*new_width
						o.height = o.width/old_aspect
					}else{
						o.height = height_ratio*new_height
						o.width = o.height*old_aspect
					}
				}

				//ensuring text boxes are not out of screen
				if(o.type == 'text' && o.width > new_width){
					o.width = 0.8*new_width
					o.height = o.width/old_aspect
				}

				if(o.type == 'text' && o.height > new_height){
					o.height = 0.8*new_height
					o.width = o.height*old_aspect
				}

				var change_ratio = o.width/old_width

				if(o.type == 'image'){
					o.image_details.contentDisplacement.x *= change_ratio
					o.image_details.contentDisplacement.y *= change_ratio
					o.image_details.image_width *= change_ratio
					o.image_details.image_height *= change_ratio
				}else if(o.type == 'text'){
					o.text_details.letterSpacing *= change_ratio
					var oldLineHeight = o.text_details.lineHeight
					o.text_details.lineHeight *= change_ratio
					o.text_details.fontSize = ((Number(o.text_details.fontSize) + Number(oldLineHeight))*o.height/old_height) - Number(o.text_details.lineHeight)
				}

				//applying positioning
				var center = o.getCenter();
				o.position.x += (new_center.x - center.x)
				o.position.y += (new_center.y - center.y)
			}

			//text box collissions
			for(var j=0;j<textboxes.length;j++){
				for(var k=0;k<textboxes.length;k++){
					if(j!=k && already_colliding[j]==undefined && already_colliding[k]==undefined){
						var tj = textboxes[j];
						var tk = textboxes[k];
						if((tj.position.y+tj.height)>tk.position.y && (tj.position.y+tj.height)<(tk.position.y+tk.height)){
							var diff = tj.position.y + tj.height - tk.position.y
							var available_space = tj.position.y;
							if(available_space>diff+5){
								tj.position.y -= (diff+5)
							}else{
								tj.position.y -= (available_space - 5)
							}
						}

						if((tk.position.y+tk.height)>tj.position.y && (tk.position.y+tk.height)<(tj.position.y+tj.height)){
							var diff = tk.position.y + tk.height - tj.position.y
							var available_space = tk.position.y;
							if(available_space>diff+5){
								tk.position.y -= (diff+5)
							}else{
								tk.position.y -= (available_space - 5)
							}
						}
					}
				}
			}
		}



		this.width = target_width
		this.height = target_height
		this.dimension_units = target_dimension_units
		this.handleWindowResize()
	}

	function resizeCalculator(old_box,new_box){
		var rc = this
		var length_ratio = (new_box[1].x - new_box[0].x)/(old_box[1].x - old_box[0].x);
		
		this.convertLength = function(length){
			return length*length_ratio
		}

		this.convertX = function(x){
			var x_relative_to_origin = x - old_box[0].x
			var x_relative_to_origin_to_new_length = rc.convertLength(x_relative_to_origin);
			return new_box[0].x + x_relative_to_origin_to_new_length
		}

		this.convertY = function(y){
			var y_relative_to_origin = y - old_box[0].y
			var y_relative_to_origin_to_new_length = rc.convertLength(y_relative_to_origin);
			return new_box[0].y + y_relative_to_origin_to_new_length
		}
	}

	this.magicResize = function(target_width,target_height,target_dimension_units){
		try{
			var old_width = editor.get_width();
			var old_height = editor.get_height();
			var new_width = target_width;
			var new_height = target_height;

			if(target_dimension_units != 'px' && target_dimension_units != ''){
				new_width = this.convert_to_px(new_width,target_dimension_units)
				new_height = this.convert_to_px(new_height,target_dimension_units)
			}

			var old_aspect = old_width/old_height;
			var new_aspect = new_width/new_height

			var old_box = [
				{x:0,y:0},
				{x: old_width,y:0},
				{x: old_width,y:old_height},
				{x: 0,y:old_height}

			]
			var new_box = [];
			var minX;var minY;var maxX;var maxY;
			
			if(new_aspect > old_aspect){
				minY = 0;
				maxY = new_height

				var old_equivalent_width = old_aspect*new_height
				var new_equivalent_width = new_width

				minX = (new_equivalent_width - old_equivalent_width)/2
				maxX = minX + old_equivalent_width
			}else{
				minX = 0;
				maxX = new_width

				var old_equivalent_height = new_width/old_aspect
				var new_equivalent_height = new_height

				minY = (new_equivalent_height - old_equivalent_height)/2
				maxY = minY + old_equivalent_height
			}

			var new_box = [
				{x:minX,y:minY},
				{x:maxX,y:minY},
				{x:maxX,y:maxY},
				{x:minX,y:maxY}
			]

			var resize_calc = new resizeCalculator(old_box,new_box);


			for (var i = 0; i < this.pages.length; i++) {
				// var bg_vertices = [
				// 	{x: this.pages[i].background_details.contentDisplacement.x,y: this.pages[i].background_details.contentDisplacement.y},
				// 	{x: this.pages[i].background_details.contentDisplacement.x + this.pages[i].background_details.image_width,y: this.pages[i].background_details.contentDisplacement.y},
				// 	{x: this.pages[i].background_details.contentDisplacement.x + this.pages[i].background_details.image_width,y: this.pages[i].background_details.contentDisplacement.y + this.pages[i].background_details.image_height},
				// 	{x: this.pages[i].background_details.contentDisplacement.x,y: this.pages[i].background_details.contentDisplacement.y + this.pages[i].background_details.image_height}
				// ]

				// bg_vertices = bg_vertices.map(function(o){
    //                 o.x==0?o.x +=0.0001:null;
    //                 return o
    //             })

    //             var page_vertices = [
			 //        {x:0.001,y:0.001},
			 //        {x:new_width - 0.001,y:0.001},
			 //        {x:new_width - 0.001,y:new_height - 0.001},
			 //        {x:0.001,y:new_height - 0.001}
			 //    ]

			 //    var test = true
    //             for(var v=0;v<page_vertices.length;v++){
    //                 if(!utils.pointInPolygon(page_vertices[v].x,page_vertices[v].y,bg_vertices,100000,100000)){
    //                     test = false;
    //                     break
    //                 }
    //             }

                // if(!test){
					// this.pages[i].background_details.image_needs_autoset = true
                // }

                if(Math.abs((new_width/new_height) - (old_width/old_height)) > 0.001){
                	this.pages[i].background_details.image_needs_autoset = true
                }

				this.pages[i].background_needs_redraw = true;
				if(this.pages[i].background_color == '#ffffff' && !this.pages[i].background_image_exists()){
					var average_color = editor.findDominantColors()[0];
					this.pages[i].background_color = average_color || '#ffffff'
				}

				var groups = this.pages[i].groups;
				var objects = this.pages[i].objects;
				for (var j = 0; j < objects.length; j++) {
					var obj = objects[j]

					obj.width = resize_calc.convertLength(obj.width)
					obj.height = resize_calc.convertLength(obj.height)
					obj.position.x = resize_calc.convertX(obj.position.x)
					obj.position.y = resize_calc.convertY(obj.position.y)

					//TEXT
					if(obj.type == 'text'){
						obj.text_details.fontSize = resize_calc.convertLength(obj.text_details.fontSize)
						obj.text_details.letterSpacing = resize_calc.convertLength(obj.text_details.letterSpacing)
						obj.text_details.lineHeight = resize_calc.convertLength(obj.text_details.lineHeight)
					}

					//IMAGE
					if(obj.type == 'image'){
						obj.image_details.image_width = resize_calc.convertLength(obj.image_details.image_width)
						obj.image_details.image_height = resize_calc.convertLength(obj.image_details.image_height)
						obj.image_details.contentDisplacement.x = resize_calc.convertLength(obj.image_details.contentDisplacement.x)
						obj.image_details.contentDisplacement.y = resize_calc.convertLength(obj.image_details.contentDisplacement.y)
					}

					//GRIDS AND MASKS
					if(obj.type == 'grid'){
						var boxes = obj.grid_details.boxes
						for(var b=0;b<boxes.length;b++){
							if(boxes[b].image){
								boxes[b].image.width = resize_calc.convertLength(boxes[b].image.width)
								boxes[b].image.height = resize_calc.convertLength(boxes[b].image.height)

								boxes[b].image.image_details.image_width = resize_calc.convertLength(boxes[b].image.image_details.image_width)
								boxes[b].image.image_details.image_height = resize_calc.convertLength(boxes[b].image.image_details.image_height)
								boxes[b].image.image_details.contentDisplacement.x = resize_calc.convertLength(boxes[b].image.image_details.contentDisplacement.x)
								boxes[b].image.image_details.contentDisplacement.y = resize_calc.convertLength(boxes[b].image.image_details.contentDisplacement.y)
							}

							if(boxes[b].frame){
								boxes[b].frame.width = resize_calc.convertLength(boxes[b].frame.width)
								boxes[b].frame.height = resize_calc.convertLength(boxes[b].frame.height)

								boxes[b].frame.image_details.image_width = resize_calc.convertLength(boxes[b].frame.image_details.image_width)
								boxes[b].frame.image_details.image_height = resize_calc.convertLength(boxes[b].frame.image_details.image_height)
								boxes[b].frame.image_details.contentDisplacement.x = resize_calc.convertLength(boxes[b].frame.image_details.contentDisplacement.x)
								boxes[b].frame.image_details.contentDisplacement.y = resize_calc.convertLength(boxes[b].frame.image_details.contentDisplacement.y)
							}
						}
					}
				}

				for (var j = 0; j < groups.length; j++) {
					var group = groups[j]

					group.width = resize_calc.convertLength(group.width)
					group.height = resize_calc.convertLength(group.height)
					group.position.x = resize_calc.convertX(group.position.x)
					group.position.y = resize_calc.convertY(group.position.y)
				}
			}

			this.width = target_width
			this.height = target_height
			this.dimension_units = target_dimension_units
			this.handleWindowResize()
		}catch(err){
			console.log(err);
		}
	}


	function init(design_file,thumbnail){
		if(thumbnail && thumbnail.constructor.name == "String"){
			return loadStaticImage(thumbnail,true)
			.then(function(image){
				editor.load(design_file,image)
				editor.undoStack.push(editor.save());
				return Promise.resolve();
			}).catch(function(image){
				editor.load(design_file)
				editor.undoStack.push(editor.save());
				return Promise.resolve();
			})
		}else{
			editor.load(design_file,thumbnail)
			editor.undoStack.push(editor.save());
			return Promise.resolve();
		}
	}

	this.save = function(){
		var data = {
			id: editor.id,
			pages: [],
			width: editor.width,
			height: editor.height,
			bulk_edit_data: deref(editor.bulk_edit_data),
			category_id: editor.category_id,
			dimension_units: editor.dimension_units
		}
		for (var i = 0; i < editor.pages.length; i++) {
			data.pages[i] = editor.pages[i].save()
		}


		return data
	}

	this.load = function(editor_file,loader_image){

		if(editor_file.id){
			editor.id = editor_file.id
		}

		if(editor_file.category_id){
			editor.category_id = editor_file.category_id;
		}

		if(editor_file.width){
			editor.width = Number(editor_file.width)
		}

		if(editor_file.height){
			editor.height = Number(editor_file.height)
		}

		if(editor_file.dimension_units){
			editor.dimension_units = editor_file.dimension_units
		}

		editor_file.bulk_edit_data!=undefined?editor.bulk_edit_data=deref(editor_file.bulk_edit_data):null;



		for (var i = 0; i < editor_file.pages.length; i++) {
			if(editor.pages[i]){
				editor.pages[i].load(editor_file.pages[i]);
				editor.pages[i].handleWindowResize()
			}else{
				editor.pages[i] = new designPage(editor,editor_file.pages[i],doms[i]||window.document.createElement('div'))
			}
			
		}

		if(editor.pages.length > editor_file.pages.length){
			var start = editor_file.pages.length;
			var len = editor.pages.length - editor_file.pages.length
			for(var i=start + len-1;i>=start;i--){
				editor.pages[i].remove()
			}
		}

		editor.setActivePage(editor.pages[0])

		if(loader_image){
			editor.loader_image = loader_image;
			editor.draw()
			return editor.wait_to_load()
			.then(function(){
				editor.loader_image = null;
				editor.draw();	
				return Promise.resolve()
			})
		}else{
			return Promise.resolve()
		}
	}

	this.addNewPage = function (new_doms,page_to_clone){
		var data = {}
		if(page_to_clone){
			data = page_to_clone.save();
			//cloning ids
			refresh_ids_struct(data);
		}

		editor.pages.push(new designPage(editor,data,new_doms[new_doms.length-1]))

		editor.setActivePage(editor.pages[editor.pages.length-1])
		editor.addUndoChange()
		editor.deselectElements();
		this.updateDoms(new_doms)
	}

	this.deletePage = function(page_to_remove){
		page_to_remove.remove();
		editor.setActivePage(editor.pages[editor.pages.length-1])
		editor.addUndoChange()
		editor.deselectElements();
	}

	this.updateDoms = function(new_doms){
		try{
			if(new_doms){
				editor.doms = new_doms
			}

			for (var i = 0; i < editor.pages.length; i++) {
				editor.pages[i].dom = editor.doms[i];
				if(editor.pages[i].dom && editor.pages[i].dom.children[2]){
					editor.pages[i].dom.children[2].parentElement.removeChild(editor.pages[i].dom.children[1])
				}

				if(editor.pages[i].dom && editor.pages[i].dom.children[1]){
					editor.pages[i].dom.children[1].parentElement.removeChild(editor.pages[i].dom.children[1])
				}

				$(editor.pages[i].dom).append(editor.pages[i].canvas);
				$(editor.pages[i].dom).append(editor.pages[i].canvas_outer);
			}
			editor.handleWindowResize()
		}catch(err){
			console.log(err);
		}
	}

	this.setActivePage = function(page){
		if(page.constructor.name == 'String' || page.constructor.name == 'Number'){
			page = editor.pages[page]
		}

		editor.active_page = page
	}

	this.addUndoChange = function(){
		if(editor.undo_stack_disabled){
			return
		}

		var new_save = editor.save()
		var last_version = _.last(editor.undoStack)
		if(!_.isEqual(last_version,new_save)){
			if(editor.undoStack.length>50){
				editor.undoStack.shift();
			}
			editor.undoStack.push(new_save);
			editor.redoStack = [];
			if(window['setDesignStatusText']){
				setDesignStatusText('Saving Changes...')
			}
			editor.save_backend();
		}
	}

	this.handleWindowResize = function(){
		for (var i = 0; i < editor.pages.length; i++) {
			editor.pages[i].handleWindowResize()
		}
	}

	this.undo = function(){
		if(editor.undoStack.length>1){
			editor.redoStack.push(editor.undoStack.pop());
			var old_count = editor.pages.length;
			editor.load(_.last(editor.undoStack));
			editor.needs_redraw = true;

			if(window['setDesignStatusText']){
				setDesignStatusText('Saving Changes...')
			}
			editor.save_backend();

			if(editor.pages.length!=old_count && window['rct_update_pages']){
				rct_update_pages(editor.pages.length)
			}
		}
	}

	this.redo = function(){
		if(editor.redoStack.length>0){
			editor.undoStack.push(editor.redoStack.pop());
			var old_count = editor.pages.length;
			editor.load(_.last(editor.undoStack));
			editor.needs_redraw = true;

			if(window['setDesignStatusText']){
				setDesignStatusText('Saving Changes...')
			}
			
			editor.save_backend();

			if(editor.pages.length!=old_count && window['rct_update_pages']){
				rct_update_pages(editor.pages.length)
			}
		}
	}

	this.draw = function(){
		for (var i = 0; i < editor.pages.length; i++) {
			editor.pages[i].draw();
		}
	}

	this.deselectElements = function(){
		for (var i = 0; i < editor.pages.length; i++) {
			editor.pages[i].deselectElements();
		}
	}

	this.applyBrandKit = function(brand_kit){
		for (var i = 0; i < editor.pages.length; i++) {
			editor.pages[i].applyBrandKit(brand_kit);
		}
	}

	this.proceduralGeneration = function(json,use_user_labels){
		var prom_array_pages = []
		for (var i = 0; i < editor.pages.length; i++) {
			prom_array_pages.push(editor.pages[i].proceduralGeneration(json,use_user_labels));
		}

		return Promise.all(prom_array_pages)
	}

	this.save_text_template_admin = function(text_template_id){
		if(text_template_id == undefined){
			console.log('text_template_id not provided');
			return Promise.reject('text_template_id not provided');
		}
		if(!editor.active_page.selection || editor.active_page.selection.object.type!='group'){
			console.log('no selection or selection is not a group');
			return Promise.reject('no selection or selection is not a group');
		}
		var data = {
			id: text_template_id,
			design_file: editor.active_page.selection.object.copy(),
			thumbnail_data: editor.active_page.selection.object.exportThumbnail('high',true,10)
		}

		return fetch(server_path + 'text_template/update', {method: 'POST','credentials': 'include',headers: {'Content-Type':'application/json'}, body:JSON.stringify(data)})
	    .then(function(resp) {
	    	console.log(resp)
	    	return Promise.resolve(resp);
	    })
	    .catch(function(err) {
	    	console.log(err);
	    	return Promise.reject(err);
	    })
	}

	this.save_design_template_admin = function(design_id){
		if(design_id == undefined){
			console.log('design_id not provided');
			return Promise.reject('design_id not provided');
		}
		var data = {
			id: design_id,
			design_file: editor.save(),
			thumbnail_data: editor.pages[0].export('low')
		}

		return fetch(server_path + 'design/update', {method: 'POST','credentials': 'include',headers: {'Content-Type':'application/json'}, body:JSON.stringify(data)})
		.then(function(resp) {
		   console.log(resp)
		   return Promise.resolve(resp);
		})
	    .catch(function(err) {
	    	console.log(err);
	    	return Promise.reject(err);
	    })
	}

	this.save_snapshot_debounced = _.debounce(function(data_snapshot){
		fetch(server_path + 'saved_design/update_thumbnail', {method: 'POST','credentials': 'include',headers: {'Content-Type':'application/json'}, body:JSON.stringify(data_snapshot)})
		// .then(() => {
		// 	console.log("snapshot updated")
		// })
	},2000);

	this.save_snapshot_debounced.cancel();

	this.save_snapshot = function(data_snapshot){
		return fetch(server_path + 'saved_design/update_thumbnail', {method: 'POST','credentials': 'include',headers: {'Content-Type':'application/json'}, body:JSON.stringify(data_snapshot)})
		.then(() => {
			// console.log("snapshot updated")
			return Promise.resolve()
		})
	}

	this.save_data_debounced = _.debounce(function(data){
		fetch(server_path + 'saved_design/update', {method: 'POST','credentials': 'include',headers: {'Content-Type':'application/json'}, body:JSON.stringify(data)})
		.then(() => {
			// console.log("data updated");
			if(window['setDesignStatusText']){
				setDesignStatusText('All changes saved')
			}
		})
	},2000);

	this.save_data_debounced.cancel();

	this.save_data = function(data){
		return fetch(server_path + 'saved_design/update', {method: 'POST','credentials': 'include',headers: {'Content-Type':'application/json'}, body:JSON.stringify(data)})
		.then(() => {
			// console.log("data updated")
			if(window['setDesignStatusText']){
				setDesignStatusText('All changes saved')
			}
			return Promise.resolve();
		})
	}


	this.save_backend = function(dont_debounce){
		return new Promise(function(resolve,reject){
			if(!editor.design_save_id){
				resolve();
			}

			function continueSave(){
				var data = {
					id: editor.design_save_id,
					design_file: editor.save()
				}

				var data_snapshot = {
					id: editor.design_save_id,
					thumbnail_data: editor.pages[0].export('low')
				}

				var prom_save;
				var prom_snapshot;
				if(dont_debounce){
					prom_save = editor.save_data(data);
					prom_snapshot = editor.save_snapshot(data_snapshot);
				}else{
					editor.save_data_debounced(data);
					prom_save = Promise.resolve();

					editor.save_snapshot_debounced(data_snapshot);
					prom_snapshot = Promise.resolve();
				}

			    Promise.all([prom_save,prom_snapshot])
			    .then(function(){
			    	resolve();
			    })
			}

			var temp_promise_timer

			var promise_timeout = new Promise(function(res_timeout,rej_timeout){
				temp_promise_timer = setTimeout(function(){
					res_timeout();
					clearTimeout(temp_promise_timer)
				},10000)
			})

			return Promise.race([editor.wait_to_load(),promise_timeout])
			.then(function(){
				editor.draw();
				clearTimeout(temp_promise_timer)
				return continueSave()
			}).catch(function(err){
				console.log('could not save design',err)
				clearTimeout(temp_promise_timer)
			})
		})
	}

	editor.init_promise = init(design_file,design_file.thumbnail);
}

function designPage(editor,page_file,dom){
	var design = this;
	this.dom = dom
	this.canvas = null;

	this.master = editor

	this.id = utils.uuidv4();

	this.objects = [];
	this.groups = [];
	this.background_labels = {
		text:'',
		image:'',
		colors: []
	}

	this.user_background_labels = {
		text:'',
		image:'',
		colors: []
	}

	this.background_color = '#ffffff';
	this.background_image = {
		id_123rf: '',
		id_pixlr: '',
		id_unsplash: '',
		resource_id: '',
		src: ''
	};

	this.background_filter = {
		brightness: 0,
		contrast:0,
		saturation:0,
		tint:0,
		blur: 0,
		vignette:0
	}

	this.background_bgremoval = {
    	enabled: false,
    	feather: 0,
    	offset: 0,
    	sharpness: 0,
    	crf: 0,
    	matting: 0,
        cache:""
    }

	this.background_details = {
		filter:null,
		filter_color: '',
		contentDisplacement: {x:0,y:0},
		image_width: 100,
		image_height: 100,
		flip_horizontal: 1,
		flip_vertical: 1,
		image_needs_autoset: false,
		image_contain: null
	}

	this.background_sub_type = ''
	this.background_mockup_details = {
		id:null,
		inputs: null
	}

	var textarea_dom = document.createElement('textarea')
	this.textarea_dom = textarea_dom
	textarea_dom.setAttribute('style','position:fixed;left:500px;top: 500px;background: transparent;border:none')

	this.initialObject = null;
	this.initialCropObject = null;

	this.mode = 'default';
	this.activeCropImage = null;

	this.background_crop_corner = {
		top_left_crop_2: false,
		top_right_crop_2: false,
		bottom_right_crop_2: false,
		bottom_left_crop_2: false
	}

	this.temporary_group = null;

	var scope = this;

	if(this.dom.parentElement){
		$(this.dom.parentElement).contextmenu(function(o){
			o.preventDefault();
		});
	}

	this.needs_redraw = false

	this.render_timer_destroyed = false

	function redraw_listener() {

	    if (scope.needs_redraw) {
	        scope.draw();
	        scope.needs_redraw = false
	        redraw_listener();
	    }
	    else if(!scope.render_timer_destroyed){
	    	clearTimeout(scope.render_timer);
	        scope.render_timer = setTimeout(redraw_listener, 20)
	    }
	}

	if(!editor.dont_activate_controller){
		redraw_listener()
	}

	this.redraw_listener = redraw_listener

	this.activeElement = null;
	this.selection = null;
	var initialMouseX = null;
	var initialMouseY = null;
	var mouseX = null;
	var mouseY = null;
	var rawMouseX = null;
	var rawMouseY = null;
	var lastMouseX = null;
	var lastMouseY = null;
	this.originX = 0;
	this.originY = 0;

	this.originXOuter = 0;
	this.originYOuter = 0;

	this.grid_selected_box = null;
	this.group_selected_object = null;

	var leftClick = false;
	var rightClick = false;
	var mouseDown = false;
	var objectMoved = false;
	var areaMoved = false;

	var pixelsPerCm = 1; //original value was 25.0
	var cmPerPixel = 1.0 / pixelsPerCm;


	this.rotate_svg = null;
	loadStaticImage('uploads/refresh.svg')
	.then(function(image) {
		scope.rotate_svg = image
		scope.needs_redraw = true;
	})

	this.grid_background = null;
	var load_grid_promise = loadStaticImage('public/icons/scenery.svg')
	.then(function(image) {
		scope.grid_background = image
		scope.needs_redraw = true;
		return Promise.resolve()
	})

	this.snapping_lines = [];

	this.snapping_lines_to_draw = null


	function init(page_file){
		design.load(page_file)
		var canvas = document.createElement('canvas')
		var canvas_outer = document.createElement('canvas')
		scope.canvas = canvas
		scope.canvas_outer = canvas_outer

		scope.canvas.style.position = 'relative'

		scope.canvas_outer.style.position = 'absolute'
		scope.canvas_outer.style.left = '0px'
		scope.canvas_outer.style.top = '-10px'
		scope.canvas_outer.style.width = (scope.dom.clientWidth)+'px'
		scope.canvas_outer.style.height = (scope.dom.clientHeight+20)+'px'

		scope.canvas_outer.width = (scope.dom.clientWidth)
		scope.canvas_outer.height = (scope.dom.clientHeight+20)
		scope.canvas_outer.style.zIndex = '0'
		scope.canvas.style.zIndex = '0'

		$(scope.dom).append(canvas_outer);
		$(scope.dom).append(canvas);
		
		scope.canvas.style.border = "none"
		if(!editor.dont_activate_controller){
			$(window).resize(scope.handleWindowResize);
			scope.activateController();
		}
		scope.handleWindowResize();
		scope.updateSnappingLines()
	}

	this.remove = function(){
		_.pull(editor.pages,scope);
	}

	this.init = init

	this.save = function(){
		var data = {
			id: design.id,
			objects: [],
			groups: [],
			background_color: design.background_color,
			background_sub_type: design.background_sub_type,
			background_image: deref(design.background_image),
			background_filter: deref(design.background_filter),
			background_bgremoval: deref(design.background_bgremoval),
			background_details: deref(design.background_details),
			background_mockup_details: deref(design.background_mockup_details),
			background_labels: deref(design.background_labels),
			user_background_labels: deref(design.user_background_labels)
		}

		for(var i=0;i<design.objects.length;i++){
			data.objects.push(design.objects[i].save())
		}

		for(var i=0;i<design.groups.length;i++){
			data.groups.push(design.groups[i].save())
		}

		return data;
	}

	this.load = function(page_file){
		var old_bg = {
			background_color: design.background_color,
			background_image: design.background_image,
			background_details: design.background_details,
			background_filter: design.background_filter,
			background_bgremoval: design.background_bgremoval
		}
		design.objects = []
		if(page_file.objects){
			for (var i = 0; i < page_file.objects.length; i++) {
				design.objects[i] = new designObject(design);
				design.objects[i].load(page_file.objects[i]);
			}
		}

		var sorted_objects = _.sortBy(design.objects,function(o){
	        return o.layer_index
	    })

	    for (var i = 0; i < sorted_objects.length; i++) {
	    	sorted_objects[i].layer_index = i
	    }

		design.groups = []
		if(page_file.groups){
			for (var i = 0; i < page_file.groups.length; i++) {
				design.groups[i] = new designObject(design);
				design.groups[i].load(page_file.groups[i]);
			}
		}

		page_file.id!=undefined?design.id=page_file.id:null;
		page_file.background_labels!=undefined?design.background_labels=deref(page_file.background_labels):null;
		page_file.user_background_labels!=undefined?design.user_background_labels=deref(page_file.user_background_labels):null;
		page_file.background_color!=undefined?design.background_color=page_file.background_color:null;
		page_file.background_sub_type!=undefined?design.background_sub_type=page_file.background_sub_type:null;
		if(page_file.background_image){
			if(page_file.background_image.constructor.name == 'String'){
				design.background_image.src = page_file.background_image
			}else{
				for(var key in page_file.background_image){
					if(page_file.background_image[key] != undefined){
						design.background_image[key] = page_file.background_image[key] 
					}
				}
			}
		}else{
			design.background_image = {
				id_123rf: '',
				id_pixlr: '',
				id_unsplash: '',
				resource_id: '',
				src: ''
			};
		}

		if(page_file.background_filter){
			for(var key in design.background_filter){
				if(page_file.background_filter[key]!=undefined){
					if(page_file.background_filter[key].constructor.name == 'Object' || page_file.background_filter[key].constructor.name == 'Array'){
						design.background_filter[key] = deref(page_file.background_filter[key])
					}else{
						design.background_filter[key] = page_file.background_filter[key]
					}
				}
			}
		}

		if(page_file.background_bgremoval){
			for(var key in design.background_bgremoval){
				if(page_file.background_bgremoval[key]!=undefined){
					if(page_file.background_bgremoval[key].constructor.name == 'Object' || page_file.background_bgremoval[key].constructor.name == 'Array'){
						design.background_bgremoval[key] = deref(page_file.background_bgremoval[key])
					}else{
						design.background_bgremoval[key] = page_file.background_bgremoval[key]
					}
				}
			}
		}

		if(page_file.background_details){
			for(var key in design.background_details){
				if(page_file.background_details[key]!=undefined){
					if(page_file.background_details[key].constructor.name == 'Object' || page_file.background_details[key].constructor.name == 'Array'){
						design.background_details[key] = deref(page_file.background_details[key])
					}else{
						design.background_details[key] = page_file.background_details[key]
					}
				}
			}
		}

		if(page_file.background_mockup_details){
			for(var key in design.background_mockup_details){
				if(page_file.background_mockup_details[key]!=undefined){
					if(page_file.background_mockup_details[key].constructor.name == 'Object' || page_file.background_mockup_details[key].constructor.name == 'Array'){
						design.background_mockup_details[key] = deref(page_file.background_mockup_details[key])
					}else{
						design.background_mockup_details[key] = page_file.background_mockup_details[key]
					}
				}
			}
		}

		if(design.background_details.filter_color){
			var hsl = hexToHSL(design.background_details.filter_color)
			var hue = hsl[0];
			var saturation = hsl[1];
			var light = hsl[2];
			design.background_filter.tint = (hue - 180)*(200/360)
			delete design.background_details.filter_color
		}

		design.background_needs_redraw = true

		design.updateSnappingLines()
	}

	this.background_image_exists = function(){
		return scope.background_image.id_123rf || scope.background_image.id_pixlr || scope.background_image.id_unsplash || scope.background_image.resource_id || scope.background_image.src || (scope.background_sub_type == 'mockup' && scope.background_mockup_details.id)
	}

	this.get_drag_point = function(point){
		return {
			x: (point.x - $(scope.canvas).offset().left) * cmPerPixel*editor.canvas_scale + scope.originX * cmPerPixel,
			y: (point.y - $(scope.canvas).offset().top) * cmPerPixel*editor.canvas_scale + scope.originY * cmPerPixel
		}
	}

	this.getDragDropAction = function(x,y,drag_type,replace_image){
		var drag_mouse_x = (x - $(scope.canvas).offset().left) * cmPerPixel*editor.canvas_scale + scope.originX * cmPerPixel;
		var drag_mouse_y = (y - $(scope.canvas).offset().top) * cmPerPixel*editor.canvas_scale + scope.originY * cmPerPixel;

		if(drag_type == 'template'){
			var vertices = [
				{x:0.0001,y:0}, //0.0001 because pip fails at exact 0
				{x:editor.get_width(),y:0},
				{x:editor.get_width(),y:editor.get_height()},
				{x:0.0001,y:editor.get_height()}
			]
			if(utils.pointInPolygon(drag_mouse_x,drag_mouse_y,vertices,100000,100000)){
				return {
					enlarge:true,
					width: 0.9*scope.convertCmToPixel(editor.get_width())/editor.canvas_scale,
					valid_drop:true
				}
			}
		}else if(drag_type == 'image'){
			var data
			if(editor.drag_details){
				data = editor.drag_details.data;
			}
			var vertices = [
				{x:0.0001,y:0}, //0.0001 because pip fails at exact 0
				{x:editor.get_width(),y:0},
				{x:editor.get_width(),y:editor.get_height()},
				{x:0.0001,y:editor.get_height()}
			]
			if(utils.pointInPolygon(drag_mouse_x,drag_mouse_y,vertices,100000,100000)){
				var sorted_objects = _.sortBy(scope.objects,function(o){
			        return -o.layer_index
			    })

			    //background replace check
			    if(data.sub_type != 'icon'){
				    var w = editor.get_width(); var h = editor.get_height();
					var background_edge_lines = [
						[{x:0,y:0},{x:w,y:0}],
						[{x:w,y:0},{x:w,y:h}],
						[{x:w,y:h},{x:0,y:h}],
						[{x:0,y:h},{x:0,y:0}]
					]

					for (var i = 0; i < background_edge_lines.length; i++) {
						var threshold
						if(i==0 || i==2){
							threshold = 0.1*editor.get_height()
						}else{
							threshold = 0.1*editor.get_width()
						}
						var distance = utils.pointDistanceFromLine(drag_mouse_x,drag_mouse_y,background_edge_lines[i][0].x,background_edge_lines[i][0].y,background_edge_lines[i][1].x,background_edge_lines[i][1].y)

						if(distance < threshold){
							return {
								vanish: true,
								valid_drop: true,
								obj: 'background',
								replace_image: replace_image
							}
						}
					}
				}

			    for (var i = 0; i < sorted_objects.length; i++) {
			    	//images replace check
			    	if((data.sub_type!='icon' && sorted_objects[i].sub_type != 'icon' && sorted_objects[i].type == 'image') || (data.sub_type=='icon' && sorted_objects[i].sub_type == 'icon' && sorted_objects[i].type == 'image')){
			    		var vertices = sorted_objects[i].getVertices();
			    		vertices = vertices.map(function(o){
							o.x==0?o.x +=0.001:null;
							return o
						})
						if(utils.pointInPolygon(drag_mouse_x,drag_mouse_y,vertices,100000,100000)){
							return {
								vanish: true,
								valid_drop: true,
								obj: sorted_objects[i],
								replace_image: replace_image
							}
								
						}
			    	}

			    	//grids and masks replace check
			    	if(data.sub_type!='icon' && sorted_objects[i].type == 'grid'){
			    		for(var b=0;b<sorted_objects[i].grid_details.boxes.length;b++){
			    			var box = sorted_objects[i].grid_details.boxes[b];
			    			var vertices = box.vertices
				    		vertices = vertices.map(function(o){
								o.x==0?o.x +=0.001:null;
								return o
							})

							if(utils.pointInPolygonWithPadding(40,drag_mouse_x,drag_mouse_y,vertices,100000,100000)){
								return {
									vanish: true,
									valid_drop: true,
									obj: sorted_objects[i],
									box: box,
									replace_image: replace_image
								}
							}
			    		}	
			    	}
			    }
				return {
					enlarge:true,
					width: scope.convertCmToPixel(editor.get_width()*400/800)/editor.canvas_scale,
					valid_drop:true
				}
			}
		}else if(drag_type == 'text_template'){
			var vertices = [
				{x:0.0001,y:0}, //0.0001 because pip fails at exact 0
				{x:editor.get_width(),y:0},
				{x:editor.get_width(),y:editor.get_height()},
				{x:0.0001,y:editor.get_height()}
			]
			if(utils.pointInPolygon(drag_mouse_x,drag_mouse_y,vertices,100000,100000)){
				return {
					enlarge:true,
					width: scope.convertCmToPixel(editor.get_width()*400/800)/editor.canvas_scale,
					valid_drop:true
				}
			}
		}else if(drag_type == 'background'){
			var vertices = [
				{x:0.0001,y:0}, //0.0001 because pip fails at exact 0
				{x:editor.get_width(),y:0},
				{x:editor.get_width(),y:editor.get_height()},
				{x:0.0001,y:editor.get_height()}
			]
			if(utils.pointInPolygon(drag_mouse_x,drag_mouse_y,vertices,100000,100000)){
				return {
					vanish: true,
					valid_drop: true,
					obj: 'background',
					replace_image: replace_image
				}
			}
		}else if(drag_type == 'text'){
			var data
			if(editor.drag_details){
				data = editor.drag_details.data;
			}
			var vertices = [
				{x:0.0001,y:0}, //0.0001 because pip fails at exact 0
				{x:editor.get_width(),y:0},
				{x:editor.get_width(),y:editor.get_height()},
				{x:0.0001,y:editor.get_height()}
			]
			if(utils.pointInPolygon(drag_mouse_x,drag_mouse_y,vertices,100000,100000)){
				return {
					enlarge:true,
					width: scope.convertCmToPixel(editor.get_width()*data.data.width/800)/editor.canvas_scale,
					valid_drop:true
				}
			}
		}else if(drag_type == 'grid'){
			var vertices = [
				{x:0.0001,y:0}, //0.0001 because pip fails at exact 0
				{x:editor.get_width(),y:0},
				{x:editor.get_width(),y:editor.get_height()},
				{x:0.0001,y:editor.get_height()}
			]
			if(utils.pointInPolygon(drag_mouse_x,drag_mouse_y,vertices,100000,100000)){
				return {
					enlarge:true,
					width: scope.convertCmToPixel(editor.get_width()*600/800)/editor.canvas_scale,
					valid_drop:true
				}
			}
		}else if(drag_type == 'frame'){
			var vertices = [
				{x:0.0001,y:0}, //0.0001 because pip fails at exact 0
				{x:editor.get_width(),y:0},
				{x:editor.get_width(),y:editor.get_height()},
				{x:0.0001,y:editor.get_height()}
			]
			if(utils.pointInPolygon(drag_mouse_x,drag_mouse_y,vertices,100000,100000)){
				return {
					enlarge:true,
					width: scope.convertCmToPixel(editor.get_width()*400/800)/editor.canvas_scale,
					valid_drop:true
				}
			}
		}

		return {}
	}

	this.positionObject = function(object,position){
		var boundingVertices;var objects_to_position
		if(object == design.temporary_group){
			boundingVertices = object.getVertices()
			objects_to_position = object.group_details.object_data.map(function(o){return o.object});
		}else{
			boundingVertices = [
				{x:0,y:0},
				{x:editor.get_width(),y:0},
				{x:editor.get_width(),y:editor.get_height()},
				{x:0,y:editor.get_height()}
			]
			if(object.getGroup()){
				objects_to_position = [object.getGroup()]
			}else{
				objects_to_position = [object]
			}
		}

		for (var i = 0; i < objects_to_position.length; i++) {
			var vertices = objects_to_position[i].getVertices();
			var center = objects_to_position[i].getCenter();
			var bbox = utils.get2dBoundingBox(vertices);

			if(position == 'position_top'){
				var diff = boundingVertices[0].y - bbox.minY
				objects_to_position[i].applyVertices(vertices.map(function(o){
					o.y += diff
					return o
				}))
				objects_to_position[i].set_redraw()
			}else if(position == 'position_right'){
				var diff = boundingVertices[1].x - bbox.maxX
				objects_to_position[i].applyVertices(vertices.map(function(o){
					o.x += diff
					return o
				}))
				objects_to_position[i].set_redraw()
			}else if(position == 'position_bottom'){
				var diff = boundingVertices[3].y - bbox.maxY
				objects_to_position[i].applyVertices(vertices.map(function(o){
					o.y += diff
					return o
				}))
				objects_to_position[i].set_redraw()
			}else if(position == 'position_left'){
				var diff = boundingVertices[0].x - bbox.minX
				objects_to_position[i].applyVertices(vertices.map(function(o){
					o.x += diff
					return o
				}))
				objects_to_position[i].set_redraw()
			}else if(position == 'position_middle'){
				var diff = ((boundingVertices[0].y+boundingVertices[3].y)/2) - center.y
				objects_to_position[i].applyVertices(vertices.map(function(o){
					o.y += diff
					return o
				}))
				objects_to_position[i].set_redraw()
			}else if(position == 'position_center'){
				var diff = ((boundingVertices[0].x+boundingVertices[1].x)/2) - center.x
				objects_to_position[i].applyVertices(vertices.map(function(o){
					o.x += diff
					return o
				}))
				objects_to_position[i].set_redraw()
			}
		}

		if(object == design.temporary_group){
			object.setGroupFromObjects(objects_to_position,true)
		}else if(object.type == 'group' || object.getGroup()){
			if(object.type == 'group'){
				object.updateGroupObjects()
				object.set_redraw()
			}else{
				object.getGroup().updateGroupObjects()
				object.getGroup().set_redraw()
			}
		}

		design.needs_redraw = true
	}

	this.getBackgroundExposedArea = function(){
		var w = editor.get_width();var h = editor.get_height()
		var area = w*h;
		var already_filled_polygons = []
		var sorted_objects = _.sortBy(scope.objects,function(o){
	        return o.layer_index
	    })

	    var vertices_background = [[0,0],[w,0],[w,h],[0,h],[0,0]];
	    var vertices_background_turf = turf.polygon([vertices_background]);

		for (var i = 0; i < sorted_objects.length; i++) {
			if(sorted_objects[i].type != 'text'){
				var vertices = sorted_objects[i].getVertices().map(function(o){
					return [o.x,o.y]
				})
				vertices.push(vertices[0])

				vertices_turf = turf.polygon([vertices])

				var intersection = turf.intersect(vertices_turf, vertices_background_turf);
				if(intersection && !isNaN(utils.polygonArea(intersection.geometry.coordinates[0])) ){
					area -= utils.polygonArea(intersection.geometry.coordinates[0]);

					for(var j=0;j<already_filled_polygons.length;j++){
						var intersection_extra = turf.intersect(already_filled_polygons[j], intersection);
						if(intersection_extra && !isNaN(utils.polygonArea(intersection_extra.geometry.coordinates[0])) ){
							area += utils.polygonArea(intersection_extra.geometry.coordinates[0]);
						}
					}
				}

				already_filled_polygons.push(vertices_turf)				
			}
		}

		return area;
	}


	this.getGridBoxExposedArea = function(box){
		var grid = box.master;

		var vertices_grid = box.vertices.map(function(o){
			return [o.x,o.y]
		})
		vertices_grid.push(vertices_grid[0])
	    var vertices_grid_turf = turf.polygon([vertices_grid]);

		var w = editor.get_width();var h = editor.get_height()
		var vertices_background = [[0,0],[w,0],[w,h],[0,h],[0,0]];
	    var vertices_background_turf = turf.polygon([vertices_background]);

	    var intersection = turf.intersect(vertices_grid_turf, vertices_background_turf);
	    if(intersection){
	    	area = utils.polygonArea(intersection.geometry.coordinates[0]);
	    }else{
	    	return 0;
	    }

		var already_filled_polygons = [];

		var sorted_objects = _.sortBy(scope.objects,function(o){
	        return o.layer_index
	    })

	    var index = _.findIndex(sorted_objects,function(o){return o == grid});

	    sorted_objects = sorted_objects.slice(index + 1);

		for (var i = 0; i < sorted_objects.length; i++) {
			if(sorted_objects[i].type != 'text'){
				var vertices = sorted_objects[i].getVertices().map(function(o){
					return [o.x,o.y]
				})
				vertices.push(vertices[0])

				vertices_turf = turf.polygon([vertices])

				var intersection = turf.intersect(vertices_turf, vertices_grid_turf);
				if(intersection){
					area -= utils.polygonArea(intersection.geometry.coordinates[0]);

					for(var j=0;j<already_filled_polygons.length;j++){
						var intersection_extra = turf.intersect(already_filled_polygons[j], intersection);
						if(intersection_extra){
							area += utils.polygonArea(intersection_extra.geometry.coordinates[0]);
						}
					}
				}

				already_filled_polygons.push(vertices_turf)				
			}
		}

		return area;
	}

	this.getObjectExposedArea = function(object){
		var vertices_object = object.getVertices().map(function(o){
			return [o.x,o.y]
		})
		vertices_object.push(vertices_object[0])
	    var vertices_object_turf = turf.polygon([vertices_object]);

		var w = editor.get_width();var h = editor.get_height()
		var vertices_background = [[0,0],[w,0],[w,h],[0,h],[0,0]];
	    var vertices_background_turf = turf.polygon([vertices_background]);

	    var intersection = turf.intersect(vertices_object_turf, vertices_background_turf);
	    if(intersection){
	    	area = utils.polygonArea(intersection.geometry.coordinates[0]);
	    }else{
	    	return 0;
	    }

		var already_filled_polygons = [];

		var sorted_objects = _.sortBy(scope.objects,function(o){
	        return o.layer_index
	    })

	    var index = _.findIndex(sorted_objects,function(o){return o == object});

	    sorted_objects = sorted_objects.slice(index + 1);

		for (var i = 0; i < sorted_objects.length; i++) {
			if(sorted_objects[i].type != 'text'){
				var vertices = sorted_objects[i].getVertices().map(function(o){
					return [o.x,o.y]
				})
				vertices.push(vertices[0])

				vertices_turf = turf.polygon([vertices])

				var intersection = turf.intersect(vertices_turf, vertices_object_turf);
				if(intersection){
					area -= utils.polygonArea(intersection.geometry.coordinates[0]);

					for(var j=0;j<already_filled_polygons.length;j++){
						var intersection_extra = turf.intersect(already_filled_polygons[j], intersection);
						if(intersection_extra){
							area += utils.polygonArea(intersection_extra.geometry.coordinates[0]);
						}
					}
				}

				already_filled_polygons.push(vertices_turf)				
			}
		}

		return area;
	}

	this.shiftLayerIndex = function(objects,direction){
		if(direction == 'up'){
			for (var i = 0; i < objects.length; i++) {
				objects[i].layer_index += 2
			}
		}else if(direction == 'down'){
			for (var i = 0; i < objects.length; i++) {
				objects[i].layer_index -= 2
			}
		}else if(direction == 'top'){
			var local_min_index = Infinity
			for (var i = 0; i < objects.length; i++) {
				if(objects[i].layer_index<local_min_index){
					local_min_index = objects[i].layer_index
				}
			}

			var global_max_index = -Infinity
			for (var i = 0; i < scope.objects.length; i++) {
				if(objects.indexOf(scope.objects[i])==-1 && scope.objects[i].layer_index>global_max_index){
					global_max_index = scope.objects[i].layer_index
				}
			}

			var jump = (global_max_index - local_min_index) + 1

			for (var i = 0; i < objects.length; i++) {
				objects[i].layer_index += jump
			}
		}else if(direction == 'bottom'){
			var local_max_index = -Infinity
			for (var i = 0; i < objects.length; i++) {
				if(objects[i].layer_index>local_max_index){
					local_max_index = objects[i].layer_index
				}
			}

			var global_min_index = Infinity
			for (var i = 0; i < scope.objects.length; i++) {
				if(objects.indexOf(scope.objects[i])==-1 && scope.objects[i].layer_index<global_min_index){
					global_min_index = scope.objects[i].layer_index
				}
			}

			var jump = (global_min_index - local_max_index) - 1

			for (var i = 0; i < objects.length; i++) {
				objects[i].layer_index += jump
			}
		}

		var layer_array = []
        for (var k = 0; k < scope.objects.length; k++) {
            var l = scope.objects[k].layer_index;
            if(!layer_array[l]){layer_array[l] = []}

            layer_array[l].push(scope.objects[k])
        }

        var min_index = Infinity
        var max_index = -Infinity

        for (var k = 0; k < scope.objects.length; k++) {
            if(scope.objects[k].layer_index<min_index){
                min_index = scope.objects[k].layer_index
            }

            if(scope.objects[k].layer_index>max_index){
                max_index = scope.objects[k].layer_index
            }
        }

        for(var k=max_index;k>=min_index;k--){
            var sum = 0;
            for(var n=k-1;n>=min_index;n--){
                if(layer_array[n]){
                    sum += layer_array[n].length
                }
            }

            if(layer_array[k]){
                for(var kl=0;kl<layer_array[k].length;kl++){
                    layer_array[k][kl].layer_index = (sum+kl)
                }
            }
        }
	}

	this.areObjectsAtTop = function(objects){
		var global_min_index = Infinity
		var global_max_index = -Infinity
		for (var i = 0; i < scope.objects.length; i++) {
			if(objects.indexOf(scope.objects[i])==-1 && scope.objects[i].layer_index<global_min_index){
				global_min_index = scope.objects[i].layer_index
			}

			if(objects.indexOf(scope.objects[i])==-1 && scope.objects[i].layer_index>global_max_index){
				global_max_index = scope.objects[i].layer_index
			}
		}

		for (var i = 0; i < objects.length; i++) {
			if(objects[i].layer_index<global_max_index){
				return false
			}
		}

		return true
	}

	this.areObjectsAtBottom = function(objects){
		var global_min_index = Infinity
		var global_max_index = -Infinity
		for (var i = 0; i < scope.objects.length; i++) {
			if(objects.indexOf(scope.objects[i])==-1 && scope.objects[i].layer_index<global_min_index){
				global_min_index = scope.objects[i].layer_index
			}

			if(objects.indexOf(scope.objects[i])==-1 && scope.objects[i].layer_index>global_max_index){
				global_max_index = scope.objects[i].layer_index
			}
		}

		for (var i = 0; i < objects.length; i++) {
			if(objects[i].layer_index>global_min_index){
				return false
			}
		}

		return true
	}

	this.findObjectById = function(id){
		var found = design.objects.find(function(o){
			return o.id == id
		})

		if(found){
			return found
		}else{
			var found = design.groups.find(function(o){
				return o.id == id
			})

			return found
		}
	}

	this.detectLabelRules = function(object){
		if(object == 'background'){
			return 'image'
		}else if(object.type == 'image' || (object.type == 'grid' && object.selected_box && object.selected_box.image)){
			return 'image'
		}else if(object.type == 'text'){
			return 'text'
		}

		return ''
	}

	this.findImageByLabelId = function(id,use_user_labels){
		var labels_key = "labels";
		if(use_user_labels){
			labels_key = "user_labels";
		}

		for (var i = 0; i < scope.objects.length; i++) {
			if(scope.objects[i].type == 'image' && scope.objects[i][labels_key].image == id){
				scope.objects[i].set_redraw()
				return {
					o: scope.objects[i],
					o_to_redraw: scope.objects[i],
					o_width: scope.objects[i].width,
					o_height: scope.objects[i].height,
					image_cache_id: scope.objects[i].image_cache_id(),
					extra_append: ''

				}
			}else if(scope.objects[i].type == 'grid'){
				for(var j=0;j<scope.objects[i].grid_details.boxes.length;j++){
					var box = scope.objects[i].grid_details.boxes[j];
					if(box.image && box.image[labels_key].image == id){
						scope.objects[i].set_redraw()
						delete box.loaded_attached_image
						return {
							o:box.image,
							o_to_redraw: scope.objects[i],
							o_width: scope.objects[i].grid_details.boxes[j].width*scope.objects[i].width/100,
							o_height: scope.objects[i].grid_details.boxes[j].height*scope.objects[i].height/100,
							image_cache_id: box.image.image_cache_id(scope.objects[i].id),
							extra_append: scope.objects[i].id
						}
					}
				}
			}
		}

		var background_labels_key = "background_labels";
		if(use_user_labels){
			background_labels_key = "user_background_labels";
		}

		if(scope[background_labels_key].image == id){
			var image_cache_id = image_cache_id = scope.background_image.id_unsplash||scope.background_image.id_pixlr||scope.background_image.id_123rf||scope.background_image.resource_id||scope.background_image.src||scope.background_mockup_details.id
            image_cache_id += ('background_' + scope.id + '_')
			return {
				o:'background',
				o_to_redraw: null,
				o_width: editor.get_width(),
				o_height: editor.get_height(),
				image_cache_id: image_cache_id,
				extra_append: scope.objects[i].id
			}
		}
	}

	this.findTextByLabelId = function(id,use_user_labels){
		var labels_key = "labels";
		if(use_user_labels){
			labels_key = "user_labels";
		}

		for (var i = 0; i < scope.objects.length; i++) {
			if(scope.objects[i].type == 'text' && scope.objects[i][labels_key].text == id){
				return scope.objects[i]
			}
		}
	}

	this.proceduralGeneration = function(json,use_user_labels){
		return new Promise(function(resolve,reject){
			function exec_pg_image(json_image){
				if(json_image.src){
					var object = scope.findImageByLabelId(json_image.label_id,use_user_labels);
					if(object && object.o){
						if(object.o == 'background'){
							scope.background_image.src = json_image.src
							scope.background_image.id_123rf = ''
							scope.background_image.id_pixlr = ''
							scope.background_image.id_unsplash = ''
							scope.background_image.resource_id = ''
							scope.background_details.image_needs_autoset = true;
							scope.background_needs_redraw = true;
							var old_contain = scope.background_details.image_contain
							if(json_image.image_fit == 'contain'){
								scope.background_details.image_contain = object.o_width/object.o_height
							}else{
								scope.background_details.image_contain = null
							}

							var image_cache_id = object.image_cache_id

							delete editor.loaded_images[image_cache_id]
							editor.loading_images[image_cache_id] = false

							var details = deref(scope.background_image);
							details.image_contain = scope.background_details.image_contain
							
							var image_cache_id = object.o.image_cache_id()
							var load_promise = scope.loadImage({sub_type:scope.background_sub_type,mockup_details: scope.background_mockup_details,bgremoval: scope.background_bgremoval,image_details:details,image_cache_id: function(){return image_cache_id} },object.extra_append)
							editor.resource_promise_array.push(load_promise);
							return load_promise
							.then(function(){
								object.o_to_redraw.set_redraw();
								drawBackground()
								return Promise.resolve()
							})
						}else{
							object.o.image_details.src = json_image.src
							object.o.image_details.id_123rf = ''
							object.o.image_details.id_pixlr = ''
							object.o.image_details.id_unsplash = ''
							object.o.image_details.resource_id = ''
							object.o.image_details.image_needs_autoset = true;
							object.o_to_redraw.set_redraw();
							var old_contain = object.o.image_details.image_contain
							if(json_image.image_fit == 'contain'){
								object.o.image_details.image_contain = object.o_width/object.o_height
							}else{
								object.o.image_details.image_contain = null
							}

							var image_cache_id = object.image_cache_id

							delete editor.loaded_images[image_cache_id]
							editor.loading_images[image_cache_id] = false

							var load_promise = scope.loadImage(object.o,object.extra_append)
							editor.resource_promise_array.push(load_promise);
							return load_promise
							.then(function(){
								object.o_to_redraw.set_redraw();
								if(object.o_to_redraw.type == 'grid'){
									drawGrid(object.o_to_redraw)
								}else if(object.o_to_redraw.type == 'image'){
									drawImage(object.o_to_redraw)
								}

								return Promise.resolve()
							})
						}
					}
				}else{
					return Promise.resolve()
				}
			}

			var image_promise_array = [];
			var text_promise_array = [];

			//image replacement
			for (var i = 0; i < json.images.length; i++) {
				image_promise_array.push(exec_pg_image(json.images[i]));
			}

			//text replacement
			for (var i = 0; i < json.text.length; i++) {
				if(json.text[i].text && json.text[i].text != '' && json.text[i].text.length){
					var object = scope.findTextByLabelId(json.text[i].label_id,use_user_labels);
					if(object){
						// var old_length = object.text_details.text.length
						// var new_length = json.text[i].text.length
						// if(old_length!=0 && new_length > old_length){
						// 	var old_font_size = object.text_details.fontSize
						// 	// object.text_details.fontSize = (old_length/new_length)*object.text_details.fontSize + ((old_length/new_length) - 1)*(object.text_details.letterSpacing)
						// 	object.text_details.fontSize *= old_length/new_length

						// 	object.text_details.lineHeight *= (object.text_details.fontSize/old_font_size) 
						// 	object.text_details.letterSpacing *= (object.text_details.fontSize/old_font_size) 
						// }

						object.old_text = object.text_details.text
						object.old_height = object.height
						object.text_details.text = json.text[i].text
						object.text_replaced = true;
						object.set_redraw()
						scope.drawText(object);
		    			text_promise_array.push(editor.wait_to_load());
					}
				}
			}

			//text size and position adjustments
			var all_promise = Promise.all(image_promise_array,text_promise_array)
			.then(function(){return Promise.resolve()})
			.catch(function(err){console.log(err);return Promise.resolve();})
			
			
			all_promise.then(function(){
				for (var i = scope.objects.length - 1; i >= 0; i--) {
					if(scope.objects[i].type == 'text' && scope.objects[i].text_replaced){
						var old_height = scope.objects[i].old_height;
						var old_length = scope.objects[i].old_text.length
						var new_length = scope.objects[i].text_details.text.length
						if(old_length!=0 && new_length > old_length){
							var old_font_size = scope.objects[i].text_details.fontSize
							// scope.objects[i].text_details.fontSize = (old_length/new_length)*scope.objects[i].text_details.fontSize + ((old_length/new_length) - 1)*(scope.objects[i].text_details.letterSpacing)
							scope.objects[i].text_details.fontSize *= old_length/new_length

							scope.objects[i].text_details.lineHeight *= (scope.objects[i].text_details.fontSize/old_font_size) 
							scope.objects[i].text_details.letterSpacing *= (scope.objects[i].text_details.fontSize/old_font_size) 
						}

						scope.objects[i].set_redraw();
						scope.drawText(scope.objects[i]);
						// if(scope.objects[i].text_details.textAlign == 'center'){
							scope.objects[i].position.y += (old_height - scope.objects[i].height)/2
							scope.objects[i].set_redraw();
						// }
						delete scope.objects[i].text_replaced
						delete scope.objects[i].old_text
						delete scope.objects[i].old_height
					}
				}

				scope.draw();
				resolve();
			})

			// for (var i = scope.objects.length - 1; i >= 0; i--) {
			// 	if(scope.objects[i].type == 'text' && !scope.objects[i].text_replaced){
			// 		scope.objects[i].remove();
			// 	}
			// }
		})
	}

	this.updateSnappingLines = function(){
		var w = editor.get_width(); var h = editor.get_height();
		scope.snapping_lines = [
			[{x:0,y:h/2},{x:w,y:h/2}],
			[{x:w/2,y:0},{x:w/2,y:h}],
			[{x:0.1*w,y:0.1*h},{x:0.9*w,y:0.1*h}],
			[{x:0.9*w,y:0.1*h},{x:0.9*w,y:0.9*h}],
			[{x:0.9*w,y:0.9*h},{x:0.1*w,y:0.9*h}],
			[{x:0.1*w,y:0.9*h},{x:0.1*w,y:0.1*h}],
			[{x:0,y:0},{x:w,y:0}],
			[{x:w,y:0},{x:w,y:h}],
			[{x:w,y:h},{x:0,y:h}],
			[{x:0,y:h},{x:0,y:0}]
		]

		for (var i = 0; i < design.objects.length; i++) {
			var vertices = design.objects[i].getVertices();
			scope.snapping_lines.push(
				[vertices[0],vertices[1],design.objects[i]],
				[vertices[1],vertices[2],design.objects[i]],
				[vertices[2],vertices[3],design.objects[i]],
				[vertices[3],vertices[0],design.objects[i]]
			)
		}
	}

	this.checkSnapWithObject = function(object,corner,single_line_only){
		var vertices = object.getVertices();
		var dx = 0; var dy = 0;

		var corner_line

		if(corner == 'top_left'){
			var points = [vertices[0]]
			corner_line = utils.getGeneralLineFromLineSegment(
				vertices[2],vertices[0]
			);
		}else if(corner == 'top_right'){
			var points = [vertices[1]]
			corner_line = utils.getGeneralLineFromLineSegment(
				vertices[1],vertices[3]
			);
		}else if(corner == 'bottom_right'){
			var points = [vertices[2]]
			corner_line = utils.getGeneralLineFromLineSegment(
				vertices[2],vertices[0]
			);
		}else if(corner == 'bottom_left'){
			var points = [vertices[3]]
			corner_line = utils.getGeneralLineFromLineSegment(
				vertices[1],vertices[3]
			);
		}else if(corner == 'top'){
			var points = [{x:(vertices[0].x+vertices[1].x)/2,y:(vertices[0].y+vertices[1].y)/2}]
			corner_line = utils.getGeneralLineFromLineSegment(
				{x:(vertices[0].x+vertices[1].x)/2,y:(vertices[0].y+vertices[1].y)/2},
				{x:(vertices[2].x+vertices[3].x)/2,y:(vertices[2].y+vertices[3].y)/2}
			);
		}else if(corner == 'right'){
			var points = [{x:(vertices[1].x+vertices[2].x)/2,y:(vertices[1].y+vertices[2].y)/2}]
			corner_line = utils.getGeneralLineFromLineSegment(
				{x:(vertices[2].x+vertices[1].x)/2,y:(vertices[2].y+vertices[1].y)/2},
				{x:(vertices[0].x+vertices[3].x)/2,y:(vertices[0].y+vertices[3].y)/2}
			);
		}else if(corner == 'bottom'){
			var points = [{x:(vertices[2].x+vertices[3].x)/2,y:(vertices[2].y+vertices[3].y)/2}]
			corner_line = utils.getGeneralLineFromLineSegment(
				{x:(vertices[0].x+vertices[1].x)/2,y:(vertices[0].y+vertices[1].y)/2},
				{x:(vertices[2].x+vertices[3].x)/2,y:(vertices[2].y+vertices[3].y)/2}
			);
		}else if(corner == 'left'){
			var points = [{x:(vertices[0].x+vertices[3].x)/2,y:(vertices[0].y+vertices[3].y)/2}]
			corner_line = utils.getGeneralLineFromLineSegment(
				{x:(vertices[2].x+vertices[1].x)/2,y:(vertices[2].y+vertices[1].y)/2},
				{x:(vertices[0].x+vertices[3].x)/2,y:(vertices[0].y+vertices[3].y)/2}
			);
		}else{
			var points = vertices.concat([
				{x:(vertices[0].x+vertices[1].x)/2,y:(vertices[0].y+vertices[1].y)/2},
				{x:(vertices[1].x+vertices[2].x)/2,y:(vertices[1].y+vertices[2].y)/2},
				{x:(vertices[2].x+vertices[3].x)/2,y:(vertices[2].y+vertices[3].y)/2},
				{x:(vertices[3].x+vertices[0].x)/2,y:(vertices[3].y+vertices[0].y)/2}
			])
		}

		scope.snapping_lines_to_draw = [];
		var lines_already_snapped = [];

		for (var i = 0; i < points.length; i++) {
			var break_loop = false
			for (var j = 0; j < scope.snapping_lines.length; j++) {
				if(scope.snapping_lines[j][2] && scope.snapping_lines[j][2] == object){
					continue
				}
				if(lines_already_snapped.indexOf(scope.snapping_lines[j])==-1){
					var distance = utils.pointDistanceFromLine(
						points[i].x, points[i].y,
						scope.snapping_lines[j][0].x, scope.snapping_lines[j][0].y,
						scope.snapping_lines[j][1].x, scope.snapping_lines[j][1].y
					)
					distance = scope.convertCmToPixel(distance)
					if(distance<5){
						if(corner && corner_line){
							var snap_line = utils.getGeneralLineFromLineSegment(
								scope.snapping_lines[j][0],scope.snapping_lines[j][1]
							);
							
							if(utils.areLinesAlmostParallel(snap_line.a,snap_line.b,corner_line.a,corner_line.b)){
								continue;
							}
						}
						var closestPoint = utils.projectPointOnLine(
							points[i].x, points[i].y,
							scope.snapping_lines[j][0].x, scope.snapping_lines[j][0].y,
							scope.snapping_lines[j][1].x, scope.snapping_lines[j][1].y
						)

						if(dx==0){
							dx += (closestPoint.x - points[i].x)
						}

						if(dy==0){
							dy += (closestPoint.y - points[i].y)
						}

						if(j<2){
							scope.snapping_lines_to_draw.push(scope.snapping_lines[j])
						}else if (j<6){
							scope.snapping_lines_to_draw.push(scope.snapping_lines[2],scope.snapping_lines[3],scope.snapping_lines[4],scope.snapping_lines[5])
						}else if(j<10){
							scope.snapping_lines_to_draw.push(scope.snapping_lines[6],scope.snapping_lines[7],scope.snapping_lines[8],scope.snapping_lines[9])
						}else if(scope.snapping_lines[j][2]){
							scope.snapping_lines_to_draw.push(scope.snapping_lines[j])
							var distance0 = utils.distance(scope.snapping_lines[j][0].x,scope.snapping_lines[j][0].y,closestPoint.x,closestPoint.y);
							var distance1 = utils.distance(scope.snapping_lines[j][1].x,scope.snapping_lines[j][1].y,closestPoint.x,closestPoint.y);
							if(distance0<distance1){
								scope.snapping_lines_to_draw.push([closestPoint,scope.snapping_lines[j][0],object])
							}else{
								scope.snapping_lines_to_draw.push([closestPoint,scope.snapping_lines[j][1],object])
							}
						}else{
							scope.snapping_lines_to_draw.push(scope.snapping_lines[j])
						}

						if(single_line_only){
							return {x:dx,y:dy,snapping_line:scope.snapping_lines[j]}
						}

						lines_already_snapped.push(scope.snapping_lines[j])
						// break_loop = true
						// break;
					}
				}
			}

			// if(break_loop){
			// 	break;
			// }
		}

		scope.snapping_lines_to_draw = _.uniq(scope.snapping_lines_to_draw)


		return {x:dx,y:dy}
	}

	this.checkSnapWithMouse = function(){
		var vertices = object.getVertices();
		var bbox = utils.get2dBoundingBox(vertices)
		var dx = 0; var dy = 0

		scope.snapping_lines_to_draw = [];
		var lines_already_snapped = []

		var break_loop = false
		for (var j = 0; j < scope.snapping_lines.length; j++) {
			if(lines_already_snapped.indexOf(scope.snapping_lines[j])==-1){
				var distance = utils.pointDistanceFromLine(
					points[i].x, points[i].y,
					scope.snapping_lines[j][0].x, scope.snapping_lines[j][0].y,
					scope.snapping_lines[j][1].x, scope.snapping_lines[j][1].y
				)
				if(distance<scope.convertCmToPixel(10)){
					var closestPoint = utils.projectPointOnLine(
						points[i].x, points[i].y,
						scope.snapping_lines[j][0].x, scope.snapping_lines[j][0].y,
						scope.snapping_lines[j][1].x, scope.snapping_lines[j][1].y
					)

					dx += (closestPoint.x - points[i].x)
					dy += (closestPoint.y - points[i].y)

					if(j<2){
						scope.snapping_lines_to_draw.push(scope.snapping_lines[j])
					}else if (j<6){
						scope.snapping_lines_to_draw.push(scope.snapping_lines[2],scope.snapping_lines[3],scope.snapping_lines[4],scope.snapping_lines[5])
					}else{
						scope.snapping_lines_to_draw.push(scope.snapping_lines[6],scope.snapping_lines[7],scope.snapping_lines[8],scope.snapping_lines[9])
					}

					lines_already_snapped.push(scope.snapping_lines[j])
				}
			}
		}


		return {x:dx,y:dy}
	}

	this.loadImage = function(image,extra_append){
		var image_cache_id = image.image_cache_id(extra_append)

		var quality = 'm'

		if(editor.is_wizard){
			quality = 's'
		}

		
		if(image.sub_type == 'mockup' && image.mockup_details && image.mockup_details.id && image.mockup_details.inputs){
			editor.loading_images[image_cache_id] = true
			return scope.generateMockup(image.mockup_details)
		    .then(function(src) {
	    		return scope.finishLoadImage(image,src,image_cache_id)
		    })
		}else if(image.image_details.id_123rf){
			editor.loading_images[image_cache_id] = true
			return fetch(server_path + 'design_resource/load_123rf_resource', {method: 'POST','credentials': 'include',headers: {'Content-Type':'application/json'}, body:JSON.stringify({id:image.image_details.id_123rf,design_id:editor.design_save_id,quality:quality})})
		    .then(function(resp) {
		    	return resp.json().then(function(data) {
			    	if(data.response_code == 1){
			    		var src = data.data.src
			    		if(src.indexOf('.svg')>-1){
							image.sub_type = 'icon';
						}
			    		return scope.finishLoadImage(image,src,image_cache_id)
			    	}else{
			    		console.log('failed to load 123rf resource',data);
			    		return Promise.reject()
			    	}
			    })
		    })
		}else if(image.image_details.id_pixlr){
			editor.loading_images[image_cache_id] = true
			return fetch(server_path + 'design_resource/load_pixlr_resource', {method: 'POST','credentials': 'include',headers: {'Content-Type':'application/json'}, body:JSON.stringify({id:image.image_details.id_pixlr,design_id:editor.design_save_id,quality:quality})})
		    .then(function(resp) {
		    	return resp.json().then(function(data) {
			    	if(data.response_code == 1){
			    		var src = data.data.src
			    		if(src.indexOf('.svg')>-1){
							image.sub_type = 'icon';
						}
			    		return scope.finishLoadImage(image,src,image_cache_id)
			    	}else{
			    		console.log('failed to load pixlr resource',data);
			    		return Promise.reject()
			    	}
			    })
		    })
		}else if(image.image_details.id_unsplash){
			editor.loading_images[image_cache_id] = true
			return fetch(server_path + 'design_resource/load_unsplash_resource', {method: 'POST','credentials': 'include',headers: {'Content-Type':'application/json'}, body:JSON.stringify({id:image.image_details.id_unsplash,design_id:editor.design_save_id,quality:quality})})
		    .then(function(resp) {
		    	return resp.json().then(function(data) {
			    	if(data.response_code == 1){
			    		var src = data.data.src
			    		if(src.indexOf('.svg')>-1){
							image.sub_type = 'icon';
						}
			    		return scope.finishLoadImage(image,src,image_cache_id)
			    	}else{
			    		console.log('failed to load unsplash resource',data);
			    		return Promise.reject()
			    	}
			    })
		    })
		}else if(image.image_details.resource_id){
			editor.loading_images[image_cache_id] = true
			return fetch(server_path + 'design_resource/load_design_resource', {method: 'POST','credentials': 'include',headers: {'Content-Type':'application/json'}, body:JSON.stringify({id:image.image_details.resource_id,design_id:editor.design_save_id,quality:quality})})
		    .then(function(resp){
		    	return resp.json().then(function(data) {
			    	if(data.response_code == 1){
			    		var src = data.data.src
			    		if(src.indexOf('.svg')>-1){
							image.sub_type = 'icon';
						}
			    		return scope.finishLoadImage(image,src,image_cache_id)
			    	}else{
			    		console.log('failed to load design_resource',data);
			    		return Promise.reject()
			    	}
			    })
		    })
		}else{
			editor.loading_images[image_cache_id] = true
			var src = image.image_details.src
			if(src.indexOf('.svg')>-1){
				image.sub_type = 'icon';
			}
			return scope.finishLoadImage(image,src,image_cache_id)
		}
	}

	this.imageContain = function(image_raw,aspect_ratio){
		return new Promise(function(rs,rj){
			var cnvs = document.createElement('canvas');
			var ct = cnvs.getContext('2d');

			var image_aspect = image_raw.width/image_raw.height;

			if(aspect_ratio > image_aspect){
				cnvs.height = image_raw.height;
				cnvs.width = image_raw.height*aspect_ratio;
			}else{
				cnvs.width = image_raw.width;
				cnvs.height = image_raw.width/aspect_ratio;
			}

			ct.drawImage(image_raw,(cnvs.width - image_raw.width)/2,(cnvs.height - image_raw.height)/2,image_raw.width,image_raw.height);

			var im = new Image();
			im.onload = function(){
				rs(im);
			}
			im.src = cnvs.toDataURL();
		})
	}

	this.generateMockup = function(mockup_details){
		return new Promise(function(rs,rj){
			if(!editor.loaded_mockups[mockup_details.id]){
				fetch(server_path+'mockup/get_one/', {method: 'POST', headers: {'Content-Type':'application/json'}, 'credentials': 'include', body: JSON.stringify({id:mockup_details.id})})
		        .then(resp => resp.json())
		        .then((resp) => {
		        	editor.loaded_mockups[mockup_details.id] = resp.data;
		        	generateMockup(resp.data,mockup_details.inputs,{maxWidth: 800,maxHeight: 800,image_mime:'"image/jpeg"',image_quality:0.9})
			    	.then(function(output){
			    		rs(output.toDataURL());
			    	})
		        })
		    }else{
		    	generateMockup(editor.loaded_mockups[mockup_details.id],mockup_details.inputs,{maxWidth: 800,maxHeight: 800,image_mime:'"image/jpeg"',image_quality:0.9})
		    	.then(function(output){
		    		rs(output.toDataURL());
		    	})
		    }
		})
	}

	this.bg_removal = function(image_raw,bgremoval){
		var temp_canvas = document.createElement('canvas');
		var temp_canvas2 = document.createElement('canvas');
		temp_canvas.width = image_raw.width;/*Math.ceil(image_raw.width/2);*/
		temp_canvas.height = image_raw.height;/*Math.ceil(image_raw.height/2);*/
		temp_canvas2.width = image_raw.width;
		temp_canvas2.height = image_raw.height;

		temp_canvas.getContext('2d').drawImage(image_raw,0,0,temp_canvas.width,temp_canvas.height)
		return bg_removal_compute(temp_canvas.toDataURL(),bgremoval.crf,bgremoval.matting)
		.then(function(datauri){
			return new Promise(function(resolve,reject){
				var img_temp = new Image();
				img_temp.onload = function(){
					var temp_ctx = temp_canvas.getContext('2d')
					var temp_ctx2 = temp_canvas2.getContext('2d')
					temp_ctx2.drawImage(img_temp,0, 0, temp_canvas2.width, temp_canvas2.height);
					var img_data = temp_ctx2.getImageData(0, 0, temp_canvas2.width, temp_canvas2.height);
					img_data = blackToTransparent(img_data);

					temp_ctx2.clearRect(0, 0, temp_canvas2.width, temp_canvas2.height);
					temp_ctx2.putImageData(img_data, 0, 0);

					temp_ctx.globalCompositeOperation = 'destination-in'
					temp_ctx.drawImage(temp_canvas2,0, 0, temp_canvas.width, temp_canvas.height);
					var img_temp2 = new Image();
					img_temp2.onload = function(){
						resolve(img_temp2)
					}
					img_temp2.onerror = function(err){
						reject(err);
					}
					img_temp2.src = temp_canvas.toDataURL()
				}

				img_temp.onerror = function(err){
					reject(err);
				}

				img_temp.src = datauri
			})
		})
	}

	this.finishLoadImage = function(image,src,image_cache_id){
		if(image.sub_type == 'icon' && src.indexOf('.svg')>-1){
			if(image.image_details.svg_colors.length==0){
				return fetch(server_path + src)
				.then(function(response){
					return response.text()
				}).then(function(svgXml) {
					image.svgXml = svgXml
					var colors = image.getSvgColors()
					image.image_details.svg_colors = colors;
					return image.applySvgColors().then(function(image_raw){
						// editor.loading_images[image_cache_id] = false
						editor.loaded_images[image_cache_id] = image_raw
						return Promise.resolve(image_raw)
					})
				})	
			}else if(image.svgXml){
				return image.applySvgColors().then(function(image_raw){
					// editor.loading_images[image_cache_id] = false
					editor.loaded_images[image_cache_id] = image_raw
					return Promise.resolve(image_raw)
				})
			}else {
				return fetch(server_path + src)
				.then(function(response){
					return response.text()
				}).then(function(svgXml) {
					image.svgXml = svgXml
					return image.applySvgColors().then(function(image_raw){
						// editor.loading_images[image_cache_id] = false
						editor.loaded_images[image_cache_id] = image_raw
						return Promise.resolve(image_raw)
					})
				})
			}
		}else{
			return loadStaticImage(src).then(function(image_raw) {
				// order: bgremoval -> image_contain
				if(image.bgremoval && image.bgremoval.enabled){
					if(!image.bgremoval.cache){
						return scope.bg_removal(image_raw,image.bgremoval)
						.then(function(img){
							image.bgremoval.cache = img.src;
							if(image.image_details.image_contain){
								return scope.imageContain(img,image.image_details.image_contain)
								.then(function(img_contain){
									// editor.loading_images[image_cache_id] = false
									editor.loaded_images[image_cache_id] = img_contain
									return Promise.resolve(img_contain)
								})
							}else{
								// editor.loading_images[image_cache_id] = false
								editor.loaded_images[image_cache_id] = img
								return Promise.resolve(img)
							}
						})
					}else{
						return loadStaticImage(image.bgremoval.cache)
						.then(function(img){
							if(image.image_details.image_contain){
								return scope.imageContain(img,image.image_details.image_contain)
								.then(function(img_contain){
									// editor.loading_images[image_cache_id] = false
									editor.loaded_images[image_cache_id] = img_contain
									return Promise.resolve(img_contain)
								})
							}else{
								// editor.loading_images[image_cache_id] = false
								editor.loaded_images[image_cache_id] = img
								return Promise.resolve(img)
							}
						})
					}
				}else{
					if(image.image_details.image_contain){
						return scope.imageContain(image_raw,image.image_details.image_contain)
						.then(function(img_contain){
							// editor.loading_images[image_cache_id] = false
							editor.loaded_images[image_cache_id] = img_contain
							return Promise.resolve(img_contain)
						})
					}else{
						// editor.loading_images[image_cache_id] = false
						editor.loaded_images[image_cache_id] = image_raw
						return Promise.resolve(image_raw)
					}		
				}
			})
		}
	}

	this.addGroup = function(file,dont_add_undo_and_selection,copy_and_paste){
		var object_files = file.objects;
		var group_file = file.group;

		var objects = []
		for (var i = 0; i < object_files.length; i++) {
			if(object_files[i].group && object_files[i].objects){
				objects.push(scope.addGroup(object_files[i],true,copy_and_paste));
			}else{
				objects.push(scope.addObject(object_files[i],true,copy_and_paste));
			}
		}

		var new_group = new designObject(design);
		new_group.load(group_file);
		design.groups.push(new_group);

		if(!copy_and_paste){
			var center = new_group.getCenter();
			var design_center = {x:editor.get_width()/2,y:editor.get_height()/2}
			var diff = {x:design_center.x - center.x,y:design_center.y - center.y}
			new_group.position.x += diff.x
			new_group.position.y += diff.y
		}
		new_group.updateGroupObjects();

		if(!dont_add_undo_and_selection){
			scope.setSelection({object:new_group})
		}
		scope.needs_redraw = true;
		
		design.draw();
		if(!dont_add_undo_and_selection){
			editor.addUndoChange();
		}

		return new_group
	}

	this.addObject = function(object_file,dont_add_undo_and_selection,copy_and_paste){
		var new_obj = new designObject(design);
		new_obj.load(object_file);

		new_obj.layer_index = design.objects.length
		try{
			scope.objects.push(new_obj);
			if(!copy_and_paste && !object_file.position){
				var center = new_obj.getCenter();
				var design_center = {x:editor.get_width()/2,y:editor.get_height()/2}
				var diff = {x:design_center.x - center.x,y:design_center.y - center.y}
				new_obj.position.x += diff.x
				new_obj.position.y += diff.y
			}

			if(!dont_add_undo_and_selection){
				if(new_obj.type == 'image'){
					var image_cache_id = new_obj.image_cache_id()
					var loadable = new_obj.image_details.id_unsplash||new_obj.image_details.id_pixlr||new_obj.image_details.id_123rf||new_obj.image_details.resource_id||new_obj.image_details.src

					if(loadable){
						if(editor.loaded_images[image_cache_id]){
							scope.setSelection({object:new_obj})
						}else if(!editor.loading_images[image_cache_id]){
							editor.loading_images[image_cache_id] = true
							var load_promise = scope.loadImage(new_obj);
							editor.resource_promise_array.push(load_promise);
							load_promise.then(function(image_raw){
								scope.setSelection({object:new_obj})
								new_obj.loader_image = null;
								new_obj.set_redraw()
								scope.needs_redraw = true;
							})
						}
					}else{
						scope.setSelection({object:new_obj})
					}
				}else{
					scope.setSelection({object:new_obj})
				}
			}
			new_obj.set_redraw()
			scope.needs_redraw = true;
	        
	        design.draw();
			if(!dont_add_undo_and_selection){
	        	editor.addUndoChange()
	        }

	        return new_obj
		}catch(err){
			console.log(err);
		}
	}

	var isSameSet = function( arr1, arr2 ) {
		return  $( arr1 ).not( arr2 ).length === 0 && $( arr2 ).not( arr1 ).length === 0 && arr1.length==arr2.length;  
	}

	this.group_already_exists = function(group){
		var objs = group.group_details.object_data.map(function(o){return o.object});
		for (var i = 0; i < scope.groups.length; i++) {
			var objs_i = scope.groups[i].group_details.object_data.map(function(o){return o.object});
			if(isSameSet(objs_i,objs)){
				return true
			}
		}

		return false
	}

	this.groupTemporaryGroup = function(){
		scope.groups.push(scope.temporary_group);
		scope.temporary_group = null;
		scope.lastSelection = null
	}

	this.addObjectToTemporaryGroup = function(element){
		if(element.constructor.name != 'Array' && element.object.locked){
			return
		}

		if(element.constructor.name == 'Array'){
			element = element.filter(function(o){return !o.locked})
		}

		var all_objects = []
		if(!scope.temporary_group){
			scope.temporary_group = new designObject(design);
			scope.temporary_group.type = 'group';
			if(scope.lastSelection){
				if(scope.lastSelection.object.type == 'group'){
					all_objects = all_objects.concat( scope.lastSelection.object.group_details.object_data.map(function(o){return o.object}) );
				}else{
					all_objects.push(scope.lastSelection.object);
				}
			}
		}

		var concat_array = []
		if(element.constructor.name == 'Array'){
			for (var i = 0; i < element.length; i++) {
				if(element[i].type == 'group'){
					concat_array = concat_array.concat(element[i].group_details.object_data.map(function(o){return o.object}));
				}else{
					concat_array = concat_array.concat(element[i]);
				}
			}
		}else if(element.object.type == 'group'){
			concat_array = element.object.group_details.object_data.map(function(o){return o.object})
		}else{
			concat_array = [element.object]
		}

		all_objects = all_objects.concat(scope.temporary_group.group_details.object_data.map(function(o){
			return o.object
		})).concat(concat_array);

		all_objects = _.uniq(all_objects)

		scope.temporary_group.setGroupFromObjects(all_objects,true);
		scope.temporary_group.set_redraw()
	}

	this.setSelection = function(element,multi_selection,crop_mode_doubleclick){
		if(element){
			scope.selection = element
			scope.initialObject = element.object.save();
			if(multi_selection && (scope.temporary_group || (!scope.temporary_group && scope.lastSelection && scope.lastSelection.object != scope.selection.object)) && !(scope.temporary_group && element.object == scope.temporary_group) ){
				scope.addObjectToTemporaryGroup(element);
				scope.selection = {object: scope.temporary_group}
			}else if(!multi_selection && element.object!=scope.temporary_group && (!element.object.getGroup() || (element.object.getGroup() && element.object.getGroup()!= scope.temporary_group))){
				scope.temporary_group = null;
			}

			scope.mode = 'default'
    		scope.activeCropImage = null;
			
			scope.group_selected_object = scope.selection.object.selected_object;
			
			var old_box = scope.grid_selected_box
			
			if(scope.group_selected_object){
				scope.grid_selected_box = scope.group_selected_object.selected_box;
			}else{
				scope.grid_selected_box = scope.selection.object.selected_box;
			}

			if(!scope.grid_selected_box){
				scope.grid_selected_box = null;
			}

			var force_update = false
			if(scope.grid_selected_box != old_box){
				force_update = true
			}

			scope.needs_redraw = true;


			var object_to_set = scope.selection.object
			if(scope.selection.object.type == 'group' && scope.selection.object.selected_object){
				object_to_set = scope.selection.object.selected_object
			}

			if(crop_mode_doubleclick){
				if(scope.selection){
					var object_found = false;
			        var crop_image = null;

			        if(scope.selection.background&&scope.background_image_exists()){
			            crop_image = 'background'
			            object_found = true;
			        }else if(scope.selection.object && scope.selection.object.type == 'grid' && scope.grid_selected_box && scope.grid_selected_box.image){
		                crop_image = scope.grid_selected_box.image;
		                object_found = true;
			        }else if(scope.selection.object && scope.selection.object.type == 'image'){
			        	crop_image = scope.selection.object
		                object_found = true;
			        }

			        if(object_found){
			            scope.mode = 'crop';
			            scope.activeCropImage = crop_image
			            scope.needs_redraw = true;

			            if(scope.activeCropImage != 'background'){
			            	if(scope.activeCropImage.master && scope.activeCropImage.master.master && scope.activeCropImage.master.master.type == 'grid'){
			            		scope.activeCropImage.master.master.set_redraw()
			            	}else{
			            		scope.activeCropImage.set_redraw()
			            	}
			            }else if(scope.activeCropImage == 'background'){
			            	scope.background_needs_redraw = true;
			            }
			        }
				}
			}


			if(window['set_design_variables']){
				set_design_variables(object_to_set.type,object_to_set,scope.detectLabelRules(object_to_set),scope.mode=='crop',force_update)
			}

			scope.lastSelection = element
			if(!element.object.locked){
				scope.area_selection = null
			}else{
				scope.area_selection = {
					start: {x:mouseX,y:mouseY},
					end: {x:mouseX,y:mouseY}
				}
			}
		}else{
			scope.selection = {background:true}
			scope.temporary_group = null
			scope.needs_redraw = true;

			scope.initialObject = deref(scope.background_details);
			
			scope.mode = 'default'
    		scope.activeCropImage = null;

    		if(crop_mode_doubleclick){
				if(scope.selection){
					var object_found = false;
			        var crop_image = null;

			        if(scope.selection.background&&scope.background_image_exists()){
			            crop_image = 'background'
			            object_found = true;
			        }else if(scope.selection.object && scope.selection.object.type == 'grid' && scope.grid_selected_box && scope.grid_selected_box.image){
		                crop_image = scope.grid_selected_box.image;
		                object_found = true;
			        }else if(scope.selection.object && scope.selection.object.type == 'image'){
			        	crop_image = scope.selection.object
		                object_found = true;
			        }

			        if(object_found){
			            scope.mode = 'crop';
			            scope.activeCropImage = crop_image

			            if(scope.activeCropImage == 'background'){
			            	scope.background_needs_redraw = true;
			            }
			            scope.needs_redraw = true;
			        }
				}
			}

			if(window['set_design_variables']){
				set_design_variables('background',null,scope.detectLabelRules('background'),scope.mode=='crop')
			}

			scope.area_selection = {
				start: {x:mouseX,y:mouseY},
				end: {x:mouseX,y:mouseY}
			}
			scope.lastSelection = null
		}

		if(scope.mode == 'crop' && scope.selection){
			if(scope.selection.background){
				scope.initialCropObject = deref(scope.background_details);
			}else if(scope.selection.object){
				var cr = scope.getCropObject()
				if(cr){
					scope.initialCropObject = cr.save();	
				}
				
			}
		}
	}

	this.setAreaSelection = function(elements){
		scope.temporary_group = null
		scope.lastSelection = null
		scope.area_selection = null
		scope.group_selected_object = null
		scope.grid_selected_box = null
		scope.activeElement = null;
    	scope.lastMouseUpSelection = null;

		scope.addObjectToTemporaryGroup(elements);
		scope.selection = {object: scope.temporary_group}
		scope.initialObject = scope.temporary_group.save();

		var object_to_set = scope.selection.object

		if(window['set_design_variables']){
			set_design_variables(object_to_set.type,object_to_set,scope.detectLabelRules(object_to_set),scope.mode=='crop')
		}
		scope.needs_redraw = true;
	}


	this.activateController = function(){
		$(scope.canvas).off();
		$(scope.canvas).mousedown(mouseDownControl)
		$(scope.canvas).mouseup(mouseUpControl)
		$(scope.canvas).mousemove(mouseMoveControl)
		$(scope.canvas).dblclick(mouseDoubleClickControl);

		scope.canvas.addEventListener("touchstart",mouseDownControl);
		scope.canvas.addEventListener("touchend",mouseUpControl);
		scope.canvas.addEventListener("touchmove",mouseMoveControl);


		$(document).mousemove(mouseMoveControlParent)
		$(document).mouseup(mouseUpControlParent)
		document.addEventListener("touchmove",mouseMoveControlParent);
		document.addEventListener("touchend",mouseUpControlParent);
		$(document).keydown(keyDownControl);

		if(scope.dom.parentElement){
			$(scope.dom).dblclick(mouseDoubleClickControlParent)
			$(scope.dom).mousedown(mouseDownControlParent)
			scope.dom.addEventListener("touchstart",mouseDownControlParent);
		}
	}

	this.deactivateController = function(){
		$(scope.canvas).off();
		$(document).off('mousemove', mouseMoveControlParent);
		$(document).off('mouseup', mouseUpControlParent);
		$(document).off('keydown', keyDownControl);
		document.removeEventListener("touchmove",mouseMoveControlParent);
		document.removeEventListener("touchend",mouseUpControlParent);

		if(scope.dom && scope.dom.parentElement){
			$(scope.dom).off('dblclick', mouseDoubleClickControlParent);
			$(scope.dom).off('mousedown', mouseDownControlParent);
			scope.dom.removeEventListener("touchstart",mouseDownControlParent);
		}
	}

	function keyDownControl(event){
		if(event.target.type=="text" || event.target.type=="textarea"){
			return;
		}

		if(editor.active_page != scope){
			return
		}

		var valid_case_in_presentation = (event.key == 'ArrowRight' || event.key == 'ArrowLeft') && !(event.ctrlKey||event.metaKey||event.shiftKey)
		if(editor.present_index != null && !valid_case_in_presentation){
			return
		}

		if( (event.key == 'z' || event.key == 'Z') && (event.ctrlKey||event.metaKey) ){
		    event.preventDefault();
		    design.deselectElements()
		    editor.undo()
		}else if( (event.key == 'y' || event.key == 'Y') && (event.ctrlKey||event.metaKey) ){
		    event.preventDefault();
		    design.deselectElements()
	    	editor.redo()
	    }else if( (event.key == 'a' || event.key == 'A') && (event.ctrlKey||event.metaKey) ){
		    event.preventDefault();
		    design.setAreaSelection(design.objects)
	    	editor.redo()
	    }else if(event.key == 'Backspace' || event.key == 'Delete'){
		    event.preventDefault();
		    if(scope.selection  && scope.selection.object){
		    	if(scope.selection.object.type == 'grid' && scope.selection.object.selected_box && scope.selection.object.selected_box.image){
		    		scope.selection.object.selected_box.image = null;
		    		scope.selection.object.selected_box.loaded_attached_image = null;
		    		scope.selection.object.set_redraw()
		    	}else if(scope.selection.object.type == 'grid' && scope.selection.object.selected_box && scope.selection.object.selected_box.color){
		    		scope.selection.object.selected_box.color = null;
		    		scope.selection.object.set_redraw()
		    	}else{
		    		scope.selection.object.remove()
		    	}
		    	editor.addUndoChange()
		    	design.deselectElements()
			}else if(scope.selection  && scope.selection.background && scope.background_image){
	    		scope.background_image = {
					id_123rf: '',
					id_pixlr: '',
					id_unsplash: '',
					resource_id: '',
					src: ''
				};
				scope.background_details.filter = null
				scope.background_filter = {
					brightness: 0,
					contrast:0,
					saturation:0,
					tint:0,
					blur: 0,
					vignette: 0
				}
				scope.background_bgremoval = {
		        	enabled: false,
		        	feather: 0,
		        	offset: 0,
		        	sharpness: 0,
		        	crf: 0,
		        	matting: 0,
            		cache:""
		        }
		        scope.background_mockup_details = {
		        	id: null,
		        	inputs: []
		        }
		        scope.background_sub_type = null
				scope.background_needs_redraw = true
	    		editor.addUndoChange()
	    		design.deselectElements()
			}
	    }else if(event.key == 'Enter'){
		    event.preventDefault();
		    if(scope.mode == 'crop'){
		    	scope.deselectElements();
		    }
	    }else if(event.key == 'Escape'){
		    event.preventDefault();
	    	scope.deselectElements(true);
	    }else if( (event.key == 't' || event.key == 'T') && !(event.ctrlKey||event.metaKey||event.shiftKey) ){
		    event.preventDefault();
		    switch_nav_tab('text')
	    }else if( (event.key == 'g' || event.key == 'G') && (event.ctrlKey||event.metaKey) ){
		    event.preventDefault();
		    if( design.selection.object && design.selection.object!=design.temporary_group && (design.selection.object.type == 'group' || (design.selection.object.getGroup() && design.selection.object.getGroup()!=design.temporary_group)) ){
	    		update_inputs_general(null,'ungroup');
			}else if( design.selection.object && (design.selection.object==design.temporary_group || (design.selection.object.getGroup()==design.temporary_group && design.temporary_group!=null)) && (!design.group_already_exists(design.temporary_group)) ){
				update_inputs_general(null,'group');
			}
	    }else if( (event.key == 'c' || event.key == 'C') && (event.ctrlKey||event.metaKey) ){
		    event.preventDefault();
		    if(scope.selection){
	    		editor.clipboardObject = scope.selection.object
			}
	    }else if( (event.key == 'v' || event.key == 'V') && (event.ctrlKey||event.metaKey) ){
		    event.preventDefault();
	    	if(editor.clipboardObject){
	    		var copy = editor.clipboardObject.copy();
	    		if(copy.group && copy.objects){
	    			copy.group.position.x += 40;
	    			copy.group.position.y += 40;
    				design.addGroup(JSON.parse(JSON.stringify(copy)),undefined,true)
	    		}else{
	    			copy.position.x += 40;
	    			copy.position.y += 40;
    				design.addObject(JSON.parse(JSON.stringify(copy)),undefined,true)
	    		}
	    		
	    	}
	    }else if((event.key == 'ArrowRight') && !(event.ctrlKey||event.metaKey||event.shiftKey)){
	    	event.preventDefault();
	    	event.stopPropagation();
	    	if(editor.present_index != null){
	    		editor.present_next();
	    	}else if(design.selection && design.selection.object){
	    		design.selection.object.moveArrows(5,0);
	    		design.needs_redraw = true;
	    	}
	    }else if((event.key == 'ArrowLeft') && !(event.ctrlKey||event.metaKey||event.shiftKey)){
	    	event.preventDefault();
	    	event.stopPropagation();
	    	if(editor.present_index != null){
	    		editor.present_previous();
	    	}else if(design.selection && design.selection.object){
	    		design.selection.object.moveArrows(-5,0);
	    		design.needs_redraw = true;
	    	}
	    }else if((event.key == 'ArrowUp') && !(event.ctrlKey||event.metaKey||event.shiftKey)){
	    	event.preventDefault();
	    	event.stopPropagation();
	    	if(design.selection && design.selection.object){
	    		design.selection.object.moveArrows(0,-5);
	    		design.needs_redraw = true;
	    	}
	    }else if((event.key == 'ArrowDown') && !(event.ctrlKey||event.metaKey||event.shiftKey)){
	    	event.preventDefault();
	    	event.stopPropagation();
	    	if(design.selection && design.selection.object){
	    		design.selection.object.moveArrows(0,5);
	    		design.needs_redraw = true;
	    	}
	    }else if((event.key == 'ArrowUp') && event.shiftKey){
	    	event.preventDefault();
	    	event.stopPropagation();
	    	if(design.selection && design.selection.object){
	    		var objects_to_edit = []
	            if(design.selection.object.type == 'group'){
	                objects_to_edit = design.selection.object.group_details.object_data.map(o => o.object);
	            }else{
	                objects_to_edit = [design.selection.object]
	            }

	            design.shiftLayerIndex(objects_to_edit,'up')
	    		design.needs_redraw = true;
	    	}
	    }else if((event.key == 'ArrowDown') && event.shiftKey){
	    	event.preventDefault();
	    	event.stopPropagation();
	    	if(design.selection && design.selection.object){
	    		var objects_to_edit = []
	            if(design.selection.object.type == 'group'){
	                objects_to_edit = design.selection.object.group_details.object_data.map(o => o.object);
	            }else{
	                objects_to_edit = [design.selection.object]
	            }

	            design.shiftLayerIndex(objects_to_edit,'down')
	    		design.needs_redraw = true;
	    	}
	    }
	}

	this.deselectElements = function(cancel_crop){
		if(cancel_crop && scope.mode == 'crop'){
			if(scope.activeCropImage == 'background' && scope.initialCropObject && scope.initialCropObject.contentDisplacement){
	            scope.background_details = scope.initialCropObject
	            scope.background_needs_redraw = true;
	        }else if(scope.initialCropObject){
	            scope.selection.object.load(scope.initialCropObject)
	        }
		}
		scope.selection = null;
		scope.temporary_group = null;
		scope.group_selected_object = null
		scope.grid_selected_box = null
		scope.lastSelection = null
    	scope.activeElement = null;
    	scope.lastMouseUpSelection = null;
    	scope.initialObject = null;
    	scope.initialCropObject = null;

    	scope.mode = 'default'
    	scope.activeCropImage = null;

    	if(window['set_design_variables']){
			set_design_variables(null,null,null,scope.mode=='crop',undefined,true)
		}

		$(textarea_dom).off()
		if(textarea_dom.parentElement){
			textarea_dom.parentElement.removeChild(textarea_dom)
		}
		design.needs_redraw = true;
	}

	this.getCropObject = function(){
		var object_found
	    if(scope.mode == 'crop' && scope.activeCropImage && scope.activeCropImage.constructor.name != 'String'){
			var image_found = scope.objects.find(function(o){return o.type == 'image' && o==scope.activeCropImage});
			if(image_found){
				return scope.activeCropImage
			}else{
				var master = scope.activeCropImage.master;
				if(master){
					var grid_found = scope.objects.find(function(o){
						return o.type == 'grid' && o.grid_details.boxes.indexOf(master)>-1
					})
					if(grid_found){
						return grid_found;
					}
				}
			}
		}

		return null
	}

	function mouseUpControlParent(event){
		if(event.target!=scope.canvas){
			mouseUpControl(event)
		}
	}

	function mouseDownControlParent(event){
		if(event.target!=scope.canvas && event.target.constructor.name != 'HTMLImageElement'){
			mouseDownControl(event)
		}
	}

	function mouseMoveControlParent(event){
		if(event.target!=scope.canvas){
			mouseMoveControl(event)
		}
	}

	function mouseDoubleClickControlParent(event){
		if(event.target!=scope.canvas){
			mouseDoubleClickControl(event)
		}
	}

	function mouseDoubleClickControl(event){
		if(editor.present_index != null){
			return;
		}
		if(leftClick && scope.mode != 'crop'){
			scope.findActiveElement();
			scope.setSelection(scope.activeElement,event.shiftKey||event.ctrlKey||event.metaKey,true);
		}
	}

	function mouseDownControl(event){
		if(editor.present_index != null){
			return;
		}
		// event.preventDefault();
		event.stopPropagation();
		editor.setActivePage(scope);
		mouseDown = true;
		objectMoved = false;
		areaMoved = false;

		scope.cropFillGapChanges = {}
		if(event.type == "touchstart"){
			rawMouseX = event.touches[0].pageX;
			rawMouseY = event.touches[0].pageY;

			mouseX = (event.touches[0].pageX - $(scope.canvas).offset().left) * cmPerPixel*editor.canvas_scale + scope.originX * cmPerPixel;
			mouseY = (event.touches[0].pageY - $(scope.canvas).offset().top) * cmPerPixel*editor.canvas_scale + scope.originY * cmPerPixel;
		}else{
			rawMouseX = event.pageX;
			rawMouseY = event.pageY;

			mouseX = (event.pageX - $(scope.canvas).offset().left) * cmPerPixel*editor.canvas_scale + scope.originX * cmPerPixel;
			mouseY = (event.pageY - $(scope.canvas).offset().top) * cmPerPixel*editor.canvas_scale + scope.originY * cmPerPixel;
		}

		lastX = rawMouseX;
		lastY = rawMouseY; 

		if(event.which == 3 || event.button == 2){
			rightClick = true;
			leftClick = false;
		}else if(event.which == 1 || event.button == 0){
			rightClick = false;
			leftClick = true;
		}
		mouseDown = true;
		initialMouseX = mouseX;
		initialMouseY = mouseY;

		if(leftClick && scope.mode != 'crop'){
			scope.setSelection(scope.activeElement,event.shiftKey||event.ctrlKey||event.metaKey);
		}

		if(scope.mode == 'crop' && scope.selection){
			if(scope.selection.background){
				scope.initialObject = deref(scope.background_details);
			}else if(scope.selection.object){
				var cr = scope.getCropObject()
				if(cr){
					scope.initialObject = cr.save();	
				}
				
			}
		}
	}


	function mouseUpControl(event){
		if(editor.present_index != null){
			return;
		}
		if(scope.area_selection && areaMoved){
			var overlapped_objects = []
			var area_vertices = [
				{x: scope.area_selection.start.x,y:scope.area_selection.start.y},
				{x: scope.area_selection.end.x,y:scope.area_selection.start.y},
				{x: scope.area_selection.end.x,y:scope.area_selection.end.y},
				{x: scope.area_selection.start.x,y:scope.area_selection.end.y}
			]
			for (var i = 0; i < scope.objects.length; i++) {
				if(!scope.objects[i].getGroup() && 
					(
						utils.polygonPolygonIntersect(area_vertices,scope.objects[i].getVertices()) ||
						utils.polygonInsidePolygon(scope.objects[i].getVertices(), area_vertices)
					)
				){
					overlapped_objects.push(scope.objects[i])
				}
			}

			for (var i = 0; i < scope.groups.length; i++) {
				if(
					utils.polygonPolygonIntersect(area_vertices,scope.groups[i].getVertices()) ||
					utils.polygonInsidePolygon(scope.groups[i].getVertices(), area_vertices)
				){
					overlapped_objects.push(scope.groups[i])
				}
			}

			if(overlapped_objects.length>0){
				scope.setAreaSelection(overlapped_objects)
			}/*else{
				scope.deselectElements();
			}*/
		}

		scope.area_selection = null;


		if(scope.mode != 'crop' && objectMoved && scope.activeElement && scope.activeElement.object.type=='image' && scope.activeElement.object.sub_type!='icon' && mouseDown){
			var box = scope.overlappedGridBox(mouseX,mouseY)
			if(box /*&& !box.image*/){
				box.image = scope.activeElement.object
				box.image.master = box;
				box.image.image_details.image_needs_autoset = true
				editor.loaded_images[box.image.image_cache_id(box.master.id)] = editor.loaded_images[scope.activeElement.object.image_cache_id()];
				box.loaded_attached_image = editor.loaded_images[box.image.image_cache_id(box.master.id)]
				
				delete editor.loaded_images[scope.activeElement.object.image_cache_id()];
				delete box.hover_attach
				delete box.old_loaded_attached_image;
				delete box.hover_attached_image.hover_attach
				delete box.hover_attached_image

				box.attached_filter = null;
				scope.activeElement.object.remove();
				scope.activeElement = null
				box.master.set_redraw()
			}
		}


		if(scope.mode != 'crop' && !objectMoved && leftClick && scope.activeElement && scope.activeElement.object && scope.lastMouseUpSelection && scope.lastMouseUpSelection.object){
			var condition = false
			if(scope.selection.object.type == 'group'){
				condition = scope.lastMouseUpSelection.object.selected_object && scope.lastMouseUpSelection.object.selected_object.type=='text' && scope.lastMouseUpSelection.object.selected_object == scope.activeElement.object.selected_object
			}else if(scope.selection.object.type == 'text'){
				condition = scope.lastMouseUpSelection.object == scope.activeElement.object && scope.lastMouseUpSelection.object.type == 'text'
			}
			if(condition){
				if(scope.selection.object.type == 'group'){
					var obj = scope.selection.object.selected_object
				}else{
					var obj = scope.selection.object	
				}
				
				scope.updateTextAreaStyling(obj)

				$(textarea_dom).off()
				var time_temp = setTimeout(function(){
					$(textarea_dom).val(obj.text_details.text)
					$(textarea_dom).keyup(function(e){
						obj.text_details.text = $(textarea_dom).val();
						obj.set_redraw()
						scope.drawText(obj)
						obj.set_redraw()
						scope.needs_redraw = true;
					})
					document.body.appendChild(textarea_dom)
					textarea_dom.focus()
					clearTimeout(time_temp);
				},0)
			}else{
				if(textarea_dom.parentElement){
					$(textarea_dom).off()
					textarea_dom.parentElement.removeChild(textarea_dom)
				}
			}
		}else{
			if(textarea_dom.parentElement){
				$(textarea_dom).off()
				textarea_dom.parentElement.removeChild(textarea_dom)
			}
		}

		scope.lastMouseUpSelection = scope.selection;
		mouseDown = false;

		if(!document.getElementById('design_editor_undo_button') || !document.getElementById('design_editor_undo_button').contains(event.target)){
			editor.addUndoChange()
		}

		if(scope.snapping_lines_to_draw && scope.snapping_lines_to_draw.length>0){
			scope.snapping_lines_to_draw = [];
			scope.needs_redraw = true
		}

	}

	function mouseMoveControl(event){
		if(editor.present_index != null){
			return;
		}
		// update mouse
		if(event.type == "touchmove"){
			rawMouseX = event.touches[0].pageX;
			rawMouseY = event.touches[0].pageY;

			mouseX = (event.touches[0].pageX - $(scope.canvas).offset().left) * cmPerPixel*editor.canvas_scale + scope.originX * cmPerPixel;
			mouseY = (event.touches[0].pageY - $(scope.canvas).offset().top) * cmPerPixel*editor.canvas_scale + scope.originY * cmPerPixel;
		}else{
			rawMouseX = event.pageX;
			rawMouseY = event.pageY;

			mouseX = (event.pageX - $(scope.canvas).offset().left) * cmPerPixel*editor.canvas_scale + scope.originX * cmPerPixel;
			mouseY = (event.pageY - $(scope.canvas).offset().top) * cmPerPixel*editor.canvas_scale + scope.originY * cmPerPixel;
		}

		//area_selection
		if(mouseDown && scope.area_selection && leftClick){
			areaMoved = true
			scope.area_selection.end.x = mouseX;
			scope.area_selection.end.y = mouseY;
		}


		//dragging
		if(mouseDown && leftClick && scope.selection && scope.selection.background && scope.mode == 'crop' && scope.activeCropImage == 'background'){
			var image_vertices = [
				{x: scope.background_details.contentDisplacement.x,y: scope.background_details.contentDisplacement.y},
				{x: scope.background_details.contentDisplacement.x + scope.background_details.image_width,y: scope.background_details.contentDisplacement.y},
				{x: scope.background_details.contentDisplacement.x + scope.background_details.image_width,y: scope.background_details.contentDisplacement.y + scope.background_details.image_height},
				{x: scope.background_details.contentDisplacement.x,y: scope.background_details.contentDisplacement.y + scope.background_details.image_height}
			]

			var nw_point_image = image_vertices[0];
			var ne_point_image = image_vertices[1];
			var se_point_image = image_vertices[2];
			var sw_point_image = image_vertices[3];

			var w = editor.get_width(); var h = editor.get_height();

			if(scope.background_crop_corner.top_left_crop_2){
				var new_corner = utils.projectPointOnLine(mouseX, mouseY,
					se_point_image.x,se_point_image.y,
					nw_point_image.x,nw_point_image.y);

				if(new_corner.x > 0){
					new_corner.x = 0
				}

				if(new_corner.y > 0){
					new_corner.y = 0
				}

				if(image_vertices[3].y - new_corner.y < 2){
					new_corner.x = image_vertices[3].y - 3
				}

				var new_top_line = utils.getGeneralLineFromLineSegment(
					new_corner,{x:new_corner.x + 100,y:new_corner.y}
				);

				var new_left_line = utils.getGeneralLineFromLineSegment(
					new_corner,{x:new_corner.x,y:new_corner.y + 100}
				);

				var line_right = utils.getGeneralLineFromLineSegment(image_vertices[1],image_vertices[2]);
				var line_bottom = utils.getGeneralLineFromLineSegment(image_vertices[2],image_vertices[3]);

				image_vertices[0] = new_corner
				image_vertices[1] = utils.lineLineIntersectionGeneral(new_top_line.a,new_top_line.b,new_top_line.c,line_right.a,line_right.b,line_right.c)
				image_vertices[3] = utils.lineLineIntersectionGeneral(new_left_line.a,new_left_line.b,new_left_line.c,line_bottom.a,line_bottom.b,line_bottom.c)

				if(!(image_vertices[1].x - image_vertices[0].x) < 5 && !(image_vertices[3].y - image_vertices[0].y) < 5){
					scope.background_details.contentDisplacement.x = image_vertices[0].x;
					scope.background_details.contentDisplacement.y = image_vertices[0].y;
					scope.background_details.image_width = image_vertices[1].x - image_vertices[0].x
					scope.background_details.image_height = image_vertices[3].y - image_vertices[0].y
				}
			}else if(scope.background_crop_corner.top_right_crop_2){
				var new_corner = utils.projectPointOnLine(mouseX, mouseY,
					ne_point_image.x,ne_point_image.y,
					sw_point_image.x,sw_point_image.y);


				if(new_corner.x < w){
					new_corner.x = w
				}

				if(new_corner.y > 0){
					new_corner.y = 0
				}

				if(new_corner.x - image_vertices[0].x < 2){
					new_corner.x = image_vertices[0].x + 3
				}

				if(image_vertices[3].y - new_corner.y < 2){
					new_corner.x = image_vertices[3].y - 3
				}


				var new_top_line = utils.getGeneralLineFromLineSegment(
					new_corner,{x:new_corner.x + 100,y:new_corner.y}
				);

				var new_right_line = utils.getGeneralLineFromLineSegment(
					new_corner,{x:new_corner.x,y:new_corner.y + 100}
				);

				var line_left = utils.getGeneralLineFromLineSegment(image_vertices[3],image_vertices[0]);
				var line_bottom = utils.getGeneralLineFromLineSegment(image_vertices[2],image_vertices[3]);

				image_vertices[1] = new_corner
				image_vertices[0] = utils.lineLineIntersectionGeneral(new_top_line.a,new_top_line.b,new_top_line.c,line_left.a,line_left.b,line_left.c)
				image_vertices[2] = utils.lineLineIntersectionGeneral(new_right_line.a,new_right_line.b,new_right_line.c,line_bottom.a,line_bottom.b,line_bottom.c)

				if(!(image_vertices[1].x - image_vertices[0].x) < 5 && !(image_vertices[3].y - image_vertices[0].y) < 5){
					scope.background_details.contentDisplacement.x = image_vertices[0].x;
					scope.background_details.contentDisplacement.y = image_vertices[0].y;
					scope.background_details.image_width = image_vertices[1].x - image_vertices[0].x
					scope.background_details.image_height = image_vertices[3].y - image_vertices[0].y
				}
			}else if(scope.background_crop_corner.bottom_right_crop_2){
				var new_corner = utils.projectPointOnLine(mouseX, mouseY,
					se_point_image.x,se_point_image.y,
					nw_point_image.x,nw_point_image.y);

				if(new_corner.x < w){
					new_corner.x = w
				}

				if(new_corner.y < h){
					new_corner.y = h
				}

				var new_bottom_line = utils.getGeneralLineFromLineSegment(
					new_corner,{x:new_corner.x + 100,y:new_corner.y}
				);

				var new_right_line = utils.getGeneralLineFromLineSegment(
					new_corner,{x:new_corner.x,y:new_corner.y + 100}
				);

				var line_left = utils.getGeneralLineFromLineSegment(image_vertices[3],image_vertices[0]);
				var line_top = utils.getGeneralLineFromLineSegment(image_vertices[0],image_vertices[1]);

				image_vertices[2] = new_corner
				image_vertices[1] = utils.lineLineIntersectionGeneral(new_right_line.a,new_right_line.b,new_right_line.c,line_top.a,line_top.b,line_top.c)
				image_vertices[3] = utils.lineLineIntersectionGeneral(new_bottom_line.a,new_bottom_line.b,new_bottom_line.c,line_left.a,line_left.b,line_left.c)

				if(!(image_vertices[1].x - image_vertices[0].x) < 5 && !(image_vertices[3].y - image_vertices[0].y) < 5){
					scope.background_details.contentDisplacement.x = image_vertices[0].x;
					scope.background_details.contentDisplacement.y = image_vertices[0].y;
					scope.background_details.image_width = image_vertices[1].x - image_vertices[0].x
					scope.background_details.image_height = image_vertices[3].y - image_vertices[0].y
				}
			}else if(scope.background_crop_corner.bottom_left_crop_2){
				var new_corner = utils.projectPointOnLine(mouseX, mouseY,
					sw_point_image.x,sw_point_image.y,
					ne_point_image.x,ne_point_image.y);

				if(new_corner.x > 0){
					new_corner.x = 0
				}

				if(new_corner.y < h){
					new_corner.y = h
				}


				var new_bottom_line = utils.getGeneralLineFromLineSegment(
					new_corner,{x:new_corner.x + 100,y:new_corner.y}
				);

				var new_left_line = utils.getGeneralLineFromLineSegment(
					new_corner,{x:new_corner.x,y:new_corner.y + 100}
				);

				var line_right = utils.getGeneralLineFromLineSegment(image_vertices[1],image_vertices[2]);
				var line_top = utils.getGeneralLineFromLineSegment(image_vertices[0],image_vertices[1]);

				image_vertices[3] = new_corner
				image_vertices[0] = utils.lineLineIntersectionGeneral(new_left_line.a,new_left_line.b,new_left_line.c,line_top.a,line_top.b,line_top.c)
				image_vertices[2] = utils.lineLineIntersectionGeneral(new_bottom_line.a,new_bottom_line.b,new_bottom_line.c,line_right.a,line_right.b,line_right.c)

				if(!(image_vertices[1].x - image_vertices[0].x) < 5 && !(image_vertices[3].y - image_vertices[0].y) < 5){
					scope.background_details.contentDisplacement.x = image_vertices[0].x;
					scope.background_details.contentDisplacement.y = image_vertices[0].y;
					scope.background_details.image_width = image_vertices[1].x - image_vertices[0].x
					scope.background_details.image_height = image_vertices[3].y - image_vertices[0].y
				}
			}else{
				image_vertices_clone = image_vertices.map(function(o){
					return {x: o.x==0?o.x + 0.001:o.x,y:o.y==0?o.y + 0.001:o.y};
				})
				if(utils.pointInPolygon(mouseX,mouseY,image_vertices_clone,100000,100000)){
					var expected_pos = {x: scope.initialObject.contentDisplacement.x + (mouseX - initialMouseX),y:scope.initialObject.contentDisplacement.y + (mouseY - initialMouseY)}

					scope.background_details.contentDisplacement.x = expected_pos.x;
					scope.background_details.contentDisplacement.y = expected_pos.y;

					var object_vertices = [
						{x:0,y:0},
						{x:w,y:0},
						{x:w,y:h},
						{x:0,y:h}
					]

					var image_vertices = [
						{x: scope.background_details.contentDisplacement.x,y: scope.background_details.contentDisplacement.y},
						{x: scope.background_details.contentDisplacement.x + scope.background_details.image_width,y: scope.background_details.contentDisplacement.y},
						{x: scope.background_details.contentDisplacement.x + scope.background_details.image_width,y: scope.background_details.contentDisplacement.y + scope.background_details.image_height},
						{x: scope.background_details.contentDisplacement.x,y: scope.background_details.contentDisplacement.y + scope.background_details.image_height}
					]

					if(image_vertices[0].x > object_vertices[0].x){
						scope.background_details.contentDisplacement.x = 0
					}else if(image_vertices[1].x < object_vertices[1].x){
						var diff = object_vertices[1].x - image_vertices[1].x
						scope.background_details.contentDisplacement.x += diff
					}

					if(image_vertices[0].y > object_vertices[0].y){
						scope.background_details.contentDisplacement.y = 0
					}else if(image_vertices[3].y < object_vertices[3].y){
						var diff = object_vertices[3].y - image_vertices[3].y
						scope.background_details.contentDisplacement.y += diff
					}
				}
			}

			scope.background_needs_redraw = true
		}

		if(mouseDown && leftClick && scope.activeElement && scope.selection && (scope.activeElement.object==scope.group_selected_object || scope.activeElement.object==scope.selection.object)
			&& !scope.activeElement.object.locked && !(scope.activeElement.object.type == 'group' && scope.activeElement.object.group_details.object_data.find(function(o){return o.object.locked}))
		){
			objectMoved = true
			var object = scope.activeElement.object

			if(textarea_dom.parentElement){
				$(textarea_dom).off()
				textarea_dom.parentElement.removeChild(textarea_dom)
			}

			design.updateSnappingLines()

			//resize and cropping
			if(scope.activeElement.corner){
				if(['top_left','top_right','bottom_right','bottom_left'].indexOf(scope.activeElement.corner)>-1){
					object.resize(scope.activeElement.corner,mouseX,mouseY)
					var snap = scope.checkSnapWithObject(scope.activeElement.object,scope.activeElement.corner,true);
					if(snap.snapping_line){
						object.resize(scope.activeElement.corner,mouseX,mouseY,snap.snapping_line)
					}
					design.needs_redraw = true;
				}else if(['top','right','bottom','left','rotate'].indexOf(scope.activeElement.corner)>-1){
					object.cropOrRotate(scope.activeElement.corner,mouseX,mouseY)	
					var snap = scope.checkSnapWithObject(scope.activeElement.object,scope.activeElement.corner,true);
					if(snap.snapping_line){
						object.cropOrRotate(scope.activeElement.corner,mouseX,mouseY,snap.snapping_line)
					}
					design.needs_redraw = true;
				}else if(scope.mode == 'crop' && ['top_left_crop','top_right_crop','bottom_right_crop','bottom_left_crop','top_left_crop_2','top_right_crop_2','bottom_right_crop_2','bottom_left_crop_2'].indexOf(scope.activeElement.corner)>-1){
					var object_to_crop;
					if(object.type == 'image' && scope.activeCropImage==object){
						object_to_crop = object;
					}else if(object.type == 'grid' && object.grid_details.boxes.find(function(o){return o.image == scope.activeCropImage})){
						var object_to_crop = scope.activeCropImage;
						for (var i = 0; i < object.grid_details.boxes.length; i++) {
							if(object.grid_details.boxes[i].image){
								object.grid_details.boxes[i].image.width = (object.grid_details.boxes[i].width/100)*object.width
								object.grid_details.boxes[i].image.height = (object.grid_details.boxes[i].height/100)*object.height
							}
						}
					}

					if(object_to_crop){
						if(['top_left_crop','top_right_crop','bottom_right_crop','bottom_left_crop'].indexOf(scope.activeElement.corner)>-1){
							// if()
						}
						object_to_crop.cropModeCrop(scope.activeElement.corner,mouseX,mouseY)
						design.needs_redraw = true;
					}
				}
			}else{
				if(scope.mode == 'crop'){
					var object_to_crop;var initial_object
					if(object.type == 'image' && scope.activeCropImage==object){
						object_to_crop = object;
						initial_object = scope.initialObject;
					}else if(object.type == 'grid' && object.grid_details.boxes.find(function(o){return o.image == scope.activeCropImage})){
						var object_to_crop = scope.activeCropImage;
						var box_index = _.findIndex(object.grid_details.boxes,function(o){return o.image == object_to_crop});
						initial_object = scope.initialObject.grid_details.boxes[box_index].image
						for (var i = 0; i < object.grid_details.boxes.length; i++) {
							if(object.grid_details.boxes[i].image){
								object.grid_details.boxes[i].image.width = (object.grid_details.boxes[i].width/100)*object.width
								object.grid_details.boxes[i].image.height = (object.grid_details.boxes[i].height/100)*object.height
							}
						}
					}

					if(object_to_crop && initial_object){
						var result = object_to_crop.cropModeMovement((mouseX - initialMouseX),(mouseY - initialMouseY),initial_object,initialMouseX,initialMouseY);
						initialMouseX = result.initialMouseX
						initialMouseY = result.initialMouseY
						design.needs_redraw = true;
					}
				}else{
					object.move((mouseX - initialMouseX),(mouseY - initialMouseY),scope.initialObject);
					design.needs_redraw = true;
				}
			}

			var grids = design.objects.filter(function(o){
				return o.type == 'grid'
			})

			for (var i = 0; i < grids.length; i++) {
				for(var j=0;j<grids[i].grid_details.boxes.length;j++){
					if(grids[i].grid_details.boxes[j].hover_attach/* && grids[i].grid_details.boxes[j].loaded_attached_image && !grids[i].grid_details.boxes[j].image*/){
						grids[i].grid_details.boxes[j].loaded_attached_image = grids[i].grid_details.boxes[j].old_loaded_attached_image;
						grids[i].grid_details.boxes[j].attached_filter = null;
						
						delete grids[i].grid_details.boxes[j].hover_attach
						delete grids[i].grid_details.boxes[j].hover_attached_image.hover_attach
						delete grids[i].grid_details.boxes[j].hover_attached_image
						delete grids[i].grid_details.boxes[j].old_loaded_attached_image;

						grids[i].set_redraw()
					}
				}
			}

			if(object.type == 'image' && object.sub_type!='icon'){
				var box = scope.overlappedGridBox(mouseX,mouseY)
				if(box/* && !box.image*/){
					box.old_loaded_attached_image = box.loaded_attached_image
					box.hover_attach = true;
					object.hover_attach = true;
					box.hover_attached_image = object;

					box.loaded_attached_image = editor.loaded_images[object.image_cache_id()];
					box.attached_filter = object.image_details.filter
					box.master.set_redraw()
				}
			}
		}

		lastX = rawMouseX;
		lastY = rawMouseY; 

		lastMouseX = mouseX;
		lastMouseY = mouseY; 

		if(!mouseDown){
			scope.findActiveElement();
		}

		scope.needs_redraw = true
	}

	this.updateTextAreaStyling = function(obj){
		var canvas_top_position = scope.canvas.getBoundingClientRect()
		var top_vertex = obj.getUnrotatedVertices()[0]
		textarea_dom.style.left = (canvas_top_position.x + (scope.convertX(top_vertex.x)/editor.canvas_scale)) + 'px';
		textarea_dom.style.top = (canvas_top_position.y + (scope.convertY(top_vertex.y)/editor.canvas_scale)) + 'px';
		textarea_dom.style.width = (scope.convertCmToPixel(obj.width)/editor.canvas_scale) + 'px';
		textarea_dom.style.height = (scope.convertCmToPixel(obj.height)/editor.canvas_scale) + 'px';
		var rotation = (obj.rotation*180/Math.PI)
		textarea_dom.style.transform =  'rotate('+rotation+'deg)';

		textarea_dom.style.fontSize = (Number(obj.text_details.fontSize)*pixelsPerCm/editor.canvas_scale)+'px'
		textarea_dom.style.lineHeight = ((1.2*Number(obj.text_details.fontSize) + Number(obj.text_details.lineHeight) )*pixelsPerCm/editor.canvas_scale)+'px'
		textarea_dom.style.fontFamily = obj.text_details.font
		textarea_dom.style.wordBreak = 'break-word'
		textarea_dom.style.letterSpacing = (scope.convertCmToPixel(obj.text_details.letterSpacing)/editor.canvas_scale) + 'px'
		textarea_dom.style.zIndex = '10000'

		if(obj.text_details.bold){
			textarea_dom.style.fontWeight = 'bold'
		}else{
			textarea_dom.style.fontWeight = 'normal'
		}

		if(obj.text_details.italic){
			textarea_dom.style.fontStyle = 'italic'
		}else{
			textarea_dom.style.fontStyle = 'normal'
		}

		textarea_dom.style.textAlign = obj.text_details.textAlign;
		textarea_dom.style.color = 'rgba(0,0,0,0)'
		// textarea_dom.style.color = 'pink'
		textarea_dom.style.caretColor = obj.text_details.fontColor
	}

	this.overlappedGridBox = function(x,y){
		var grids = design.objects.filter(function(o){
			return o.type == 'grid'
		})

		grids = _.sortBy(grids,function(o){
	        return -o.layer_index
	    })

		for (var i = 0; i < grids.length; i++) {
			for(var j=0;j<grids[i].grid_details.boxes.length;j++){
				var vertices = grids[i].grid_details.boxes[j].vertices
				vertices = vertices.map(function(o){
					o.x==0?o.x +=0.001:null;
					return o
				})
				if(utils.pointInPolygonWithPadding(40,mouseX,mouseY,vertices,100000,100000)){
					return grids[i].grid_details.boxes[j]
				}
			}
		}
	}

	this.getBackroundImageCropVertices = function(){
		return [
			{x: scope.background_details.contentDisplacement.x, y: scope.background_details.contentDisplacement.y},
			{x: scope.background_details.contentDisplacement.x + scope.background_details.image_width, y: scope.background_details.contentDisplacement.y},
			{x: scope.background_details.contentDisplacement.x + scope.background_details.image_width, y: scope.background_details.contentDisplacement.y + scope.background_details.image_height},
			{x: scope.background_details.contentDisplacement.x, y: scope.background_details.contentDisplacement.y + scope.background_details.image_height}
		]
	}

	this.findActiveElement = function(){
		var tolerance = 20;
		var ordered_objects = design.objects.concat(design.groups);

		var ordered_objects = _.sortBy(ordered_objects,function(o){
	    	if(o.type == 'group'){
	    		var group_layer_index = _.maxBy(o.group_details.object_data,function(p){
		    		return p.object.layer_index
		    	})
		    	if(group_layer_index){
		    		group_layer_index = group_layer_index.object.layer_index
		    	}else{
		    		return 100000000
		    	}
		        return group_layer_index
	    	}else{
	    		return o.layer_index
	    	}
	    })

		ordered_objects.reverse();

	    if(scope.temporary_group){
	    	ordered_objects.push(scope.temporary_group)
	    }

	    //background
	    scope.background_crop_corner.top_left_crop_2 = false;
	    scope.background_crop_corner.top_right_crop_2 = false;
	    scope.background_crop_corner.bottom_right_crop_2 = false;
	    scope.background_crop_corner.bottom_left_crop_2 = false;

	    var bg_vertices = scope.getBackroundImageCropVertices();
	    if(scope.mode == 'crop' && scope.activeCropImage == 'background'){
	    	if(utils.distance(mouseX,mouseY,bg_vertices[0].x,bg_vertices[0].y)<tolerance){
				scope.background_crop_corner.top_left_crop_2 = true;
				scope.needs_redraw = true;
				return;
			}else if(utils.distance(mouseX,mouseY,bg_vertices[1].x,bg_vertices[1].y)<tolerance){
				scope.background_crop_corner.top_right_crop_2 = true;
				scope.needs_redraw = true;
				return;
			}else if(utils.distance(mouseX,mouseY,bg_vertices[2].x,bg_vertices[2].y)<tolerance){
				scope.background_crop_corner.bottom_right_crop_2 = true;
				scope.needs_redraw = true;
				return;
			}else if(utils.distance(mouseX,mouseY,bg_vertices[3].x,bg_vertices[3].y)<tolerance){
				scope.background_crop_corner.bottom_left_crop_2 = true;
				scope.needs_redraw = true;
				return;
			}
	    }

	    var oldElement = scope.activeElement
	    scope.activeElement = null

		var object_found = scope.getCropObject();

		if(object_found){
			ordered_objects = [object_found]
		}

		for(var i=0;i<ordered_objects.length;i++){
			var handle_tolerance = 20;
			var object = ordered_objects[i]

			if(object.height < 40 || object.width < 40){
				handle_tolerance /= 2;
			}

			if(object.getGroup() && scope.mode != 'crop'){
				continue;
			}

			if(!((scope.mode == 'crop' && object_found) || (scope.selection && scope.selection.object == object))){
				continue
			}

			var vertices = object.getVertices();
			var image_vertices = object.getImageCropVertices();
			var rotation_vertex = object.getRotationPoint();

			if(object.type == 'grid'){
				var boxes = object.grid_details.boxes
				var imgs = [];
				for(var j=0;j<boxes.length;j++){
					if(boxes[j].image){
						imgs.push(boxes[j].image);
					}
				}

				for(var j=0;j<imgs.length;j++){
					var box_image_vertices;
					var master = imgs[j].master
					if(master && master.image_vertices){
						box_image_vertices = master.image_vertices
					}

					if(box_image_vertices && scope.mode == 'crop' && scope.activeCropImage == imgs[j]){
						if(utils.distance(mouseX,mouseY,box_image_vertices[0].x,box_image_vertices[0].y)<tolerance){
							scope.activeElement = {
								object: object,
								box_image: imgs[j],
								corner: 'top_left_crop_2'
							}
							scope.needs_redraw = true;
							return;
						}else if(utils.distance(mouseX,mouseY,box_image_vertices[1].x,box_image_vertices[1].y)<tolerance){
							scope.activeElement = {
								object: object,
								box_image: imgs[j],
								corner: 'top_right_crop_2'
							}
							scope.needs_redraw = true;
							return;
						}else if(utils.distance(mouseX,mouseY,box_image_vertices[2].x,box_image_vertices[2].y)<tolerance){
							scope.activeElement = {
								object: object,
								box_image: imgs[j],
								corner: 'bottom_right_crop_2'
							}
							scope.needs_redraw = true;
							return;
						}else if(utils.distance(mouseX,mouseY,box_image_vertices[3].x,box_image_vertices[3].y)<tolerance){
							scope.activeElement = {
								object: object,
								box_image: imgs[j],
								corner: 'bottom_left_crop_2'
							}
							scope.needs_redraw = true;
							return;
						}
					}
				}
			}

			if(object.type!="text" && !(object.type == 'grid' && object.sub_type=='frame')  && !(object.type=='group' && _.findIndex(object.group_details.object_data,function(o){return o.object.type=='text' || (o.object.type=='grid' && o.object.sub_type=='frame' )})>-1 ) && utils.distance(mouseX,mouseY,(vertices[0].x+vertices[1].x)/2,(vertices[0].y+vertices[1].y)/2)<handle_tolerance){
				scope.activeElement = {
					object: object,
					corner: 'top'
				}
				scope.needs_redraw = true;
				return;
			}else if(!(object.type == 'grid' && object.sub_type=='frame') && !(object.type=='group' && _.findIndex(object.group_details.object_data,function(o){return o.object.type=='grid' && o.object.sub_type=='frame'})>-1) && utils.distance(mouseX,mouseY,(vertices[1].x+vertices[2].x)/2,(vertices[1].y+vertices[2].y)/2)<handle_tolerance){
				scope.activeElement = {
					object: object,
					corner: 'right'
				}
				scope.needs_redraw = true;
				return;
			}else if(object.type!="text" && !(object.type == 'grid' && object.sub_type=='frame')  && !(object.type=='group' && _.findIndex(object.group_details.object_data,function(o){return o.object.type=='text' || (o.object.type=='grid' && o.object.sub_type=='frame' )})>-1 ) && utils.distance(mouseX,mouseY,(vertices[2].x+vertices[3].x)/2,(vertices[2].y+vertices[3].y)/2)<handle_tolerance){
				scope.activeElement = {
					object: object,
					corner: 'bottom'
				}
				scope.needs_redraw = true;
				return;
			}else if(!(object.type == 'grid' && object.sub_type=='frame') && !(object.type=='group' && _.findIndex(object.group_details.object_data,function(o){return o.object.type=='grid' && o.object.sub_type=='frame'})>-1) && utils.distance(mouseX,mouseY,(vertices[3].x+vertices[0].x)/2,(vertices[3].y+vertices[0].y)/2)<handle_tolerance){
				scope.activeElement = {
					object: object,
					corner: 'left'
				}
				scope.needs_redraw = true;
				return;
			}else if(utils.distance(mouseX,mouseY,vertices[0].x,vertices[0].y)<handle_tolerance){
				if(scope.mode == 'crop' && scope.activeCropImage == object){
					scope.activeElement = {
						object: object,
						corner: 'top_left_crop'
					}
				}else{
					scope.activeElement = {
						object: object,
						corner: 'top_left'
					}
				}
				
				scope.needs_redraw = true;
				return;
			}else if(utils.distance(mouseX,mouseY,vertices[1].x,vertices[1].y)<handle_tolerance){
				if(scope.mode == 'crop' && scope.activeCropImage == object){
					scope.activeElement = {
						object: object,
						corner: 'top_right_crop'
					}
				}else{
					scope.activeElement = {
						object: object,
						corner: 'top_right'
					}
				}
				scope.needs_redraw = true;
				return;
			}else if(utils.distance(mouseX,mouseY,vertices[2].x,vertices[2].y)<handle_tolerance){
				if(scope.mode == 'crop' && scope.activeCropImage == object){
					scope.activeElement = {
						object: object,
						corner: 'bottom_right_crop'
					}
				}else{
					scope.activeElement = {
						object: object,
						corner: 'bottom_right'
					}
				}
				scope.needs_redraw = true;
				return;
			}else if(utils.distance(mouseX,mouseY,vertices[3].x,vertices[3].y)<handle_tolerance){
				if(scope.mode == 'crop' && scope.activeCropImage == object){
					scope.activeElement = {
						object: object,
						corner: 'bottom_left_crop'
					}
				}else{
					scope.activeElement = {
						object: object,
						corner: 'bottom_left'
					}
				}
				scope.needs_redraw = true;
				return;
			}else if(scope.mode == 'crop' && scope.activeCropImage == object && utils.distance(mouseX,mouseY,image_vertices[0].x,image_vertices[0].y)<handle_tolerance){
				scope.activeElement = {
					object: object,
					corner: 'top_left_crop_2'
				}
				scope.needs_redraw = true;
				return;
			}else if(scope.mode == 'crop' && scope.activeCropImage == object && utils.distance(mouseX,mouseY,image_vertices[1].x,image_vertices[1].y)<handle_tolerance){
				scope.activeElement = {
					object: object,
					corner: 'top_right_crop_2'
				}
				scope.needs_redraw = true;
				return;
			}else if(scope.mode == 'crop' && scope.activeCropImage == object && utils.distance(mouseX,mouseY,image_vertices[2].x,image_vertices[2].y)<handle_tolerance){
				scope.activeElement = {
					object: object,
					corner: 'bottom_right_crop_2'
				}
				scope.needs_redraw = true;
				return;
			}else if(scope.mode == 'crop' && scope.activeCropImage == object && utils.distance(mouseX,mouseY,image_vertices[3].x,image_vertices[3].y)<handle_tolerance){
				scope.activeElement = {
					object: object,
					corner: 'bottom_left_crop_2'
				}
				scope.needs_redraw = true;
				return;
			}else if(utils.distance(mouseX,mouseY,rotation_vertex.x,rotation_vertex.y)<tolerance){
				scope.activeElement = {
					object: object,
					corner: 'rotate'
				}
				scope.needs_redraw = true;
				return;
			}
		}


		for(var i=0;i<ordered_objects.length;i++){
			var object = ordered_objects[i]
			// if(object.getGroup() && scope.mode != 'crop'){
			// 	continue;
			// }
			if(scope.mode == 'crop' && scope.activeCropImage!='background'){
				var vertices = object.getImageCropVertices();
				if(object.type == 'image' && scope.activeCropImage==object){
					var vertices = object.getImageCropVertices();
				}else if(object.type == 'grid' && object.grid_details.boxes.find(function(o){return o.image == scope.activeCropImage})){
					var vertices;
					var master = scope.activeCropImage
					if(master){
						master = master.master
					}
					if(master && master.image_vertices){
						vertices = master.image_vertices
					}
				}

				if(!vertices){
					var vertices = object.getVertices();
				}
			}else{
				var vertices = object.getVertices();
			}

			var verticesInCm = [
				{
					x:vertices[0].x,
					y:vertices[0].y
				},
				{
					x:vertices[1].x,
					y:vertices[1].y
				},
				{
					x:vertices[2].x,
					y:vertices[2].y
				},
				{
					x:vertices[3].x,
					y:vertices[3].y
				}

			]

			verticesInCm = verticesInCm.map(function(o){
				o.x==0?o.x +=0.001:null;
				return o
			})

			if(utils.pointInPolygon(mouseX,mouseY,verticesInCm,100000,100000)){
				if(object.getGroup() && scope.mode != 'crop'){
					scope.activeElement = {object:object.getGroup()};
					scope.needs_redraw = needs_redraw;
					break;
				}else{
					var needs_redraw = (!oldElement || oldElement.object!=object)
					scope.activeElement = {
						object: object
					}	
					scope.needs_redraw = needs_redraw;
					break;
				}
			}
		}

		if(scope.activeElement && scope.activeElement.object && scope.activeElement.object.type == 'group'){
			scope.activeElement.object.selected_object = null
			var objects = scope.activeElement.object.group_details.object_data.map(function(o){return o.object})
			objects = _.sortBy(objects,function(o){
				return o.layer_index
		    })
			for (var i = 0; i < objects.length; i++) {
				var object_vertices = objects[i].getVertices().map(function(o){
					o.x==0?o.x +=0.001:null;
					return o
				})
				if(utils.pointInPolygon(mouseX,mouseY,object_vertices,100000,100000)){
					var needs_redraw = (!oldElement || oldElement.object!=object || oldElement.object.selected_object !=objects[i])
					scope.activeElement.object.selected_object = objects[i]
					scope.needs_redraw = needs_redraw;
					break;
				}
			}
		}

		if(scope.activeElement && scope.activeElement.object && (scope.activeElement.object.type == 'grid' || (scope.activeElement.object.selected_object && scope.activeElement.object.selected_object.type == 'grid'))){
			if(scope.activeElement.object.type == 'grid'){
				var obj = scope.activeElement.object
			}else{
				var obj = scope.activeElement.object.selected_object
			}

			obj.selected_box = null
			var boxes = obj.grid_details.boxes
			for (var i = 0; i < boxes.length; i++) {
				var box_vertices = boxes[i].vertices.map(function(o){
					o.x==0?o.x +=0.001:null;
					return o
				})
				if(utils.pointInPolygon(mouseX,mouseY,box_vertices,100000,100000)){
					var needs_redraw = (!oldElement || oldElement.object!=object || oldElement.object.selected_box !=boxes[i])
					obj.selected_box = boxes[i]
					// if(boxes[i].image){
					// 	scope.activeElement.box_image = boxes[i].image;
					// }
					scope.needs_redraw = needs_redraw;
					break;
				}
			}
		}

		var needs_redraw = (oldElement==null && scope.activeElement!=null) || (oldElement!=null && scope.activeElement==null)
		if(oldElement && scope.activeElement){
			if(oldElement.object != scope.activeElement.object || oldElement.corner != scope.activeElement.corner){
				needs_redraw = true
			}
		}
		scope.needs_redraw = needs_redraw;
	}

	this.draw = function(transparent_backdrop){
		var context = scope.canvas.getContext('2d')
		var canvas = scope.canvas
		context.clearRect(0, 0, scope.canvas.width, scope.canvas.height);
		scope.canvas_outer.getContext('2d').clearRect(0, 0, scope.canvas_outer.width, scope.canvas_outer.height);
		
		drawBackground();

		var ordered_objects_draw = _.sortBy(design.objects,function(o){
	        return o.layer_index
	    }).concat(_.sortBy(design.groups,function(o){
	        return o.layer_index
	    }))

		for (var i = 0; i < ordered_objects_draw.length; i++) {
			if(ordered_objects_draw[i].type == 'text'){
				drawText(ordered_objects_draw[i])
			}else if(ordered_objects_draw[i].type == 'image'){
				drawImage(ordered_objects_draw[i])
			}else if(ordered_objects_draw[i].type == 'grid'){
				drawGrid(ordered_objects_draw[i])
			}else if(ordered_objects_draw[i].type == 'group' && scope.selection && scope.selection.object == ordered_objects_draw[i] ){
				drawSelectionBox(ordered_objects_draw[i])
				ordered_objects_draw[i].needs_redraw = false
			}else if(ordered_objects_draw[i].type == 'group' && scope.activeElement && scope.activeElement.object == ordered_objects_draw[i] ){
				drawSelectionBox(ordered_objects_draw[i],true)
				ordered_objects_draw[i].needs_redraw = false
			}
		}

		if(scope.temporary_group && scope.temporary_group.type == 'group' && scope.selection && scope.selection.object == scope.temporary_group ){
			drawSelectionBox(scope.temporary_group)
			scope.temporary_group.unset_redraw()
		}

		if(scope.mode == 'crop' && scope.activeCropImage && scope.activeCropImage != 'background'){
			var vertices
			if(scope.activeCropImage.type != 'background'){
				var image_found = scope.objects.find(function(o){return o.type == 'image' && o==scope.activeCropImage});
				if(image_found){
					vertices = scope.activeCropImage.getVertices();
				}else{
					var master = scope.activeCropImage.master;
					if(master && master.image_vertices){
						vertices = master.image_vertices;
					}
				}
			}

			if(vertices){
				var context = scope.canvas.getContext('2d');
				context.fillStyle = 'rgba(120,120,120,0.5)'
				context.beginPath();

				context.moveTo(scope.canvas.width,0);
				context.lineTo(0,0);
				context.lineTo(0,scope.canvas.height);
				context.lineTo(scope.canvas.width,scope.canvas.height);
				context.lineTo(scope.canvas.width,0);

				if(utils.getDirection(vertices) == 'anticlockwise'){
					vertices.reverse();
				}

				context.moveTo(scope.convertX(vertices[0].x),scope.convertY(vertices[0].y));  
				for(var i=1;i<vertices.length;i++){
					context.lineTo(scope.convertX(vertices[i].x),scope.convertY(vertices[i].y));  
				}
				context.lineTo(scope.convertX(vertices[0].x),scope.convertY(vertices[0].y));  
				context.fill();
			}
		}

		drawSnappingLines()
		drawAreaSelection()

		if(editor.loader_image){
			scope.canvas_outer.getContext('2d').clearRect(0, 0, scope.canvas_outer.width, scope.canvas_outer.height);
			context.filter = 'blur(7px)';
			context.drawImage(editor.loader_image,0, 0, scope.canvas.width, scope.canvas.height);
			context.filter = 'none';
		}

		//drawing border
		context.setLineDash([]);
		context.strokeStyle = '#000000';
		context.lineWidth = 1;
		context.beginPath();
		context.moveTo(0,0);
		context.lineTo(scope.canvas.width,0);
		context.lineTo(scope.canvas.width,scope.canvas.height);
		context.lineTo(0,scope.canvas.height);
		context.lineTo(0,0);
		context.stroke()
	}

	function drawAreaSelection(){
		if(scope.area_selection){
			var context = scope.canvas.getContext('2d');
			context.strokeStyle = 'fc6d1a';
			context.fillStyle = 'rgba(252,110,26,0.4)';
			context.beginPath();
			context.moveTo(scope.convertX(scope.area_selection.start.x),scope.convertY(scope.area_selection.start.y))
			context.lineTo(scope.convertX(scope.area_selection.end.x),scope.convertY(scope.area_selection.start.y))
			context.lineTo(scope.convertX(scope.area_selection.end.x),scope.convertY(scope.area_selection.end.y))
			context.lineTo(scope.convertX(scope.area_selection.start.x),scope.convertY(scope.area_selection.end.y))
			context.lineTo(scope.convertX(scope.area_selection.start.x),scope.convertY(scope.area_selection.start.y))
			context.stroke();
			context.fill();

			var context_outer = scope.canvas_outer.getContext('2d');
			context_outer.strokeStyle = 'fc6d1a';
			context_outer.fillStyle = 'rgba(252,110,26,0.4)';
			context_outer.beginPath();
			context_outer.moveTo(scope.convertXOuter(scope.area_selection.start.x),scope.convertYOuter(scope.area_selection.start.y))
			context_outer.lineTo(scope.convertXOuter(scope.area_selection.end.x),scope.convertYOuter(scope.area_selection.start.y))
			context_outer.lineTo(scope.convertXOuter(scope.area_selection.end.x),scope.convertYOuter(scope.area_selection.end.y))
			context_outer.lineTo(scope.convertXOuter(scope.area_selection.start.x),scope.convertYOuter(scope.area_selection.end.y))
			context_outer.lineTo(scope.convertXOuter(scope.area_selection.start.x),scope.convertYOuter(scope.area_selection.start.y))
			context_outer.stroke();
			context_outer.fill();
		}
	}

	function drawSnappingLines(){
		if(scope.dont_draw_snapping_lines){
			return
		}
		var context = scope.canvas.getContext('2d');
		context.strokeStyle = '#fc6d1a'
		context.lineWidth = 1;

		if(scope.snapping_lines_to_draw){
			for (var i = 0; i < scope.snapping_lines_to_draw.length; i++) {
				if(scope.snapping_lines_to_draw[i][2]){
					context.setLineDash([4,3]);
				}
				context.beginPath();
				context.moveTo(
					scope.convertX(scope.snapping_lines_to_draw[i][0].x),
					scope.convertY(scope.snapping_lines_to_draw[i][0].y)
				);
				context.lineTo(
					scope.convertX(scope.snapping_lines_to_draw[i][1].x),
					scope.convertY(scope.snapping_lines_to_draw[i][1].y)
				);

				context.stroke();
				context.setLineDash([]);
			}
		}
	}

	function drawSelectionBox(object,dont_draw_corners,strokeColor){
		if(scope.dont_draw_selection_box){
			return
		}
		var context = scope.canvas.getContext('2d')
		var context_outer = scope.canvas_outer.getContext('2d');
		context.lineWidth  = 2;
		context.setLineDash([]);
		context.strokeStyle = strokeColor || '#aaaaaa'/*"rgba(0,0,0,0.2)"#FF841F*/;

		context_outer.lineWidth  = 2;
		context_outer.setLineDash([]);
		context_outer.strokeStyle = strokeColor || '#aaaaaa'/*"rgba(0,0,0,0.2)"#FF841F*/;

		var vertices = object.getVertices();
		
		if(scope.mode != 'crop'){
			context.beginPath();
			context.moveTo(scope.convertX(vertices[0].x), scope.convertY(vertices[0].y));
			context.lineTo(scope.convertX(vertices[1].x), scope.convertY(vertices[1].y));
			context.lineTo(scope.convertX(vertices[2].x), scope.convertY(vertices[2].y));
			context.lineTo(scope.convertX(vertices[3].x), scope.convertY(vertices[3].y));
			context.lineTo(scope.convertX(vertices[0].x), scope.convertY(vertices[0].y));
			context.stroke();

			context_outer.beginPath();
			context_outer.moveTo(scope.convertXOuter(vertices[0].x), scope.convertYOuter(vertices[0].y));
			context_outer.lineTo(scope.convertXOuter(vertices[1].x), scope.convertYOuter(vertices[1].y));
			context_outer.lineTo(scope.convertXOuter(vertices[2].x), scope.convertYOuter(vertices[2].y));
			context_outer.lineTo(scope.convertXOuter(vertices[3].x), scope.convertYOuter(vertices[3].y));
			context_outer.lineTo(scope.convertXOuter(vertices[0].x), scope.convertYOuter(vertices[0].y));
			context_outer.stroke();
		}else{
			if(object.type == 'image' && scope.activeCropImage==object){
				var crop_vertices = object.getVertices();
			}else if(object.type == 'grid' && object.grid_details.boxes.find(function(o){return o.image == scope.activeCropImage})){
				var crop_vertices;
				var master = scope.activeCropImage
				if(master){
					master = master.master
				}
				if(master && master.vertices){
					crop_vertices = master.vertices
				}
			}

			if(crop_vertices){
				context.beginPath();
				context.moveTo(scope.convertX(crop_vertices[0].x), scope.convertY(crop_vertices[0].y));
				context.lineTo(scope.convertX(crop_vertices[1].x), scope.convertY(crop_vertices[1].y));
				context.lineTo(scope.convertX(crop_vertices[2].x), scope.convertY(crop_vertices[2].y));
				context.lineTo(scope.convertX(crop_vertices[3].x), scope.convertY(crop_vertices[3].y));
				context.lineTo(scope.convertX(crop_vertices[0].x), scope.convertY(crop_vertices[0].y));
				context.stroke();

				context_outer.beginPath();
				context_outer.moveTo(scope.convertXOuter(crop_vertices[0].x), scope.convertYOuter(crop_vertices[0].y));
				context_outer.lineTo(scope.convertXOuter(crop_vertices[1].x), scope.convertYOuter(crop_vertices[1].y));
				context_outer.lineTo(scope.convertXOuter(crop_vertices[2].x), scope.convertYOuter(crop_vertices[2].y));
				context_outer.lineTo(scope.convertXOuter(crop_vertices[3].x), scope.convertYOuter(crop_vertices[3].y));
				context_outer.lineTo(scope.convertXOuter(crop_vertices[0].x), scope.convertYOuter(crop_vertices[0].y));
				context_outer.stroke();
			}
		}

		var rad_tl=rad_tr=rad_br=rad_bl=6*1.5;
		var rad_rotate=8*1.5
		var rad_t=rad_r=rad_b=rad_l=4*1.5;
		var length_tl_crop=length_tr_crop=length_br_crop=length_bl_crop=14*1.5;
		var breadth_tl_crop=breadth_tr_crop=breadth_br_crop=breadth_bl_crop=4*1.5;
		var rad_tl_crop_2=rad_tr_crop_2=rad_br_crop_2=rad_bl_crop_2=6*1.5;

		if(scope.selection && scope.activeElement && (scope.selection.object==scope.activeElement.object || scope.group_selected_object==scope.activeElement.object) && scope.activeElement.corner){
			if(scope.activeElement.corner =='top_left'){
				rad_tl = 9*1.5
			}else if(scope.activeElement.corner =='top_right'){
				rad_tr = 9*1.5
			}else if(scope.activeElement.corner =='bottom_right'){
				rad_br = 9*1.5
			}else if(scope.activeElement.corner =='bottom_left'){
				rad_bl = 9*1.5
			}else if(scope.activeElement.corner =='top'){
				rad_t = 6*1.5
			}else if(scope.activeElement.corner =='right'){
				rad_r = 6*1.5
			}else if(scope.activeElement.corner =='bottom'){
				rad_b = 6*1.5
			}else if(scope.activeElement.corner =='left'){
				rad_l = 6*1.5
			}else if(scope.activeElement.corner =='rotate'){
				rad_rotate = 12*1.5
			}else if(scope.activeElement.corner =='top_left_crop'){
				length_tl_crop = 21*1.5;
				breadth_tl_crop = 6*1.5;
			}else if(scope.activeElement.corner =='top_right_crop'){
				length_tr_crop = 21*1.5;
				breadth_tr_crop = 6*1.5;
			}else if(scope.activeElement.corner =='bottom_right_crop'){
				length_br_crop = 21*1.5;
				breadth_br_crop = 6*1.5;
			}else if(scope.activeElement.corner =='bottom_left_crop'){
				length_bl_crop = 21*1.5;
				breadth_bl_crop = 6*1.5;
			}else if(scope.activeElement.corner =='top_left_crop_2'){
				rad_tl_crop_2 = 9*1.5
			}else if(scope.activeElement.corner =='top_right_crop_2'){
				rad_tr_crop_2 = 9*1.5
			}else if(scope.activeElement.corner =='bottom_right_crop_2'){
				rad_br_crop_2 = 9*1.5
			}else if(scope.activeElement.corner =='bottom_left_crop_2'){
				rad_bl_crop_2 = 9*1.5
			}
		}

		if(object.height < 40 || object.width < 40){
			rad_tl /= 2;
			rad_tr /= 2;
			rad_br /= 2;
			rad_bl /= 2;
			rad_t /= 2;
			rad_b /= 2;
			rad_l /= 2;
			rad_r /= 2;
		}

		if(scope.mode != 'crop' && !dont_draw_corners){
			drawCircle(
				context,
				scope.convertX(vertices[0].x),
				scope.convertY(vertices[0].y),
				scope.convertCmToPixel(rad_tl),
				true,'#ffffff',
				true,'#000000',scope.convertCmToPixel(1)
			)

			drawCircle(
				context,
				scope.convertX(vertices[1].x),
				scope.convertY(vertices[1].y),
				scope.convertCmToPixel(rad_tr),
				true,'#ffffff',
				true,'#000000',scope.convertCmToPixel(1)
			)

			drawCircle(
				context,
				scope.convertX(vertices[2].x),
				scope.convertY(vertices[2].y),
				scope.convertCmToPixel(rad_br),
				true,'#ffffff',
				true,'#000000',scope.convertCmToPixel(1)
			)

			drawCircle(
				context,
				scope.convertX(vertices[3].x),
				scope.convertY(vertices[3].y),
				scope.convertCmToPixel(rad_bl),
				true,'#ffffff',
				true,'#000000',scope.convertCmToPixel(1)
			)

			drawCircle(
				context_outer,
				scope.convertXOuter(vertices[0].x),
				scope.convertYOuter(vertices[0].y),
				scope.convertCmToPixelOuter(rad_tl),
				true,'#ffffff',
				true,'#000000',scope.convertCmToPixel(1)
			)

			drawCircle(
				context_outer,
				scope.convertXOuter(vertices[1].x),
				scope.convertYOuter(vertices[1].y),
				scope.convertCmToPixelOuter(rad_tr),
				true,'#ffffff',
				true,'#000000',scope.convertCmToPixel(1)
			)

			drawCircle(
				context_outer,
				scope.convertXOuter(vertices[2].x),
				scope.convertYOuter(vertices[2].y),
				scope.convertCmToPixelOuter(rad_br),
				true,'#ffffff',
				true,'#000000',scope.convertCmToPixel(1)
			)

			drawCircle(
				context_outer,
				scope.convertXOuter(vertices[3].x),
				scope.convertYOuter(vertices[3].y),
				scope.convertCmToPixelOuter(rad_bl),
				true,'#ffffff',
				true,'#000000',scope.convertCmToPixel(1)
			)
		}

		if(scope.mode == 'crop'){
			if(object.type == 'image' && scope.activeCropImage==object){
				context.strokeStyle = '#000000';
				context.fillStyle = '#ffffff';
				context.lineWidth = scope.convertCmToPixel(1);

				context_outer.strokeStyle = '#000000';
				context_outer.fillStyle = '#ffffff';
				context_outer.lineWidth = scope.convertCmToPixel(1);

				var right_angle = Math.atan2(vertices[1].y - vertices[0].y, vertices[1].x - vertices[0].x);
				var bottom_angle = Math.atan2(vertices[3].y - vertices[0].y, vertices[3].x - vertices[0].x);

				var cr = Math.cos(right_angle); var sr = Math.sin(right_angle);
				var cb = Math.cos(bottom_angle); var sb = Math.sin(bottom_angle);

				var p0 = {x:scope.convertX(vertices[0].x) - cr*(scope.convertCmToPixel(breadth_tl_crop/2)) - cb*(scope.convertCmToPixel(breadth_tl_crop/2)), y:scope.convertY(vertices[0].y) - sr*(scope.convertCmToPixel(breadth_tl_crop/2)) - sb*(scope.convertCmToPixel(breadth_tl_crop/2))}
				var p1 = {x:scope.convertX(vertices[1].x) + cr*(scope.convertCmToPixel(breadth_tr_crop/2)) - cb*(scope.convertCmToPixel(breadth_tr_crop/2)), y:scope.convertY(vertices[1].y) + sr*(scope.convertCmToPixel(breadth_tr_crop/2)) - sb*(scope.convertCmToPixel(breadth_tr_crop/2))}
				var p2 = {x:scope.convertX(vertices[2].x) + cr*(scope.convertCmToPixel(breadth_br_crop/2)) + cb*(scope.convertCmToPixel(breadth_br_crop/2)), y:scope.convertY(vertices[2].y) + sr*(scope.convertCmToPixel(breadth_br_crop/2)) + sb*(scope.convertCmToPixel(breadth_br_crop/2))}
				var p3 = {x:scope.convertX(vertices[3].x) - cr*(scope.convertCmToPixel(breadth_bl_crop/2)) + cb*(scope.convertCmToPixel(breadth_bl_crop/2)), y:scope.convertY(vertices[3].y) - sr*(scope.convertCmToPixel(breadth_bl_crop/2)) + sb*(scope.convertCmToPixel(breadth_bl_crop/2))}
				
				// tl
				context.beginPath();
				var current = {x:p0.x,y:p0.y}
				context.moveTo(current.x,current.y);

				current.x += cr*scope.convertCmToPixel(length_tl_crop);
				current.y += sr*scope.convertCmToPixel(length_tl_crop);
				context.lineTo(current.x,current.y);

				current.x += cb*scope.convertCmToPixel(breadth_tl_crop);
				current.y += sb*scope.convertCmToPixel(breadth_tl_crop);
				context.lineTo(current.x,current.y);

				current.x -= cr*scope.convertCmToPixel(length_tl_crop - breadth_tl_crop);
				current.y -= sr*scope.convertCmToPixel(length_tl_crop - breadth_tl_crop);
				context.lineTo(current.x,current.y);

				current.x += cb*scope.convertCmToPixel(length_tl_crop - breadth_tl_crop);
				current.y += sb*scope.convertCmToPixel(length_tl_crop - breadth_tl_crop);
				context.lineTo(current.x,current.y);

				current.x -= cr*scope.convertCmToPixel(breadth_tl_crop);
				current.y -= sr*scope.convertCmToPixel(breadth_tl_crop);
				context.lineTo(current.x,current.y);
				
				context.lineTo(p0.x,p0.y);
				context.fill();

				// tr
				context.beginPath();
				var current = {x:p1.x,y:p1.y}
				context.moveTo(current.x,current.y);

				current.x -= cr*scope.convertCmToPixel(length_tr_crop);
				current.y -= sr*scope.convertCmToPixel(length_tr_crop);
				context.lineTo(current.x,current.y);

				current.x += cb*scope.convertCmToPixel(breadth_tr_crop);
				current.y += sb*scope.convertCmToPixel(breadth_tr_crop);
				context.lineTo(current.x,current.y);

				current.x += cr*scope.convertCmToPixel(length_tr_crop - breadth_tr_crop);
				current.y += sr*scope.convertCmToPixel(length_tr_crop - breadth_tr_crop);
				context.lineTo(current.x,current.y);

				current.x += cb*scope.convertCmToPixel(length_tr_crop - breadth_tr_crop);
				current.y += sb*scope.convertCmToPixel(length_tr_crop - breadth_tr_crop);
				context.lineTo(current.x,current.y);

				current.x += cr*scope.convertCmToPixel(breadth_tr_crop);
				current.y += sr*scope.convertCmToPixel(breadth_tr_crop);
				context.lineTo(current.x,current.y);
				
				context.lineTo(p1.x,p1.y);
				context.fill();

				// br
				context.beginPath();
				var current = {x:p2.x,y:p2.y}
				context.moveTo(current.x,current.y);

				current.x -= cr*scope.convertCmToPixel(length_br_crop);
				current.y -= sr*scope.convertCmToPixel(length_br_crop);
				context.lineTo(current.x,current.y);

				current.x -= cb*scope.convertCmToPixel(breadth_br_crop);
				current.y -= sb*scope.convertCmToPixel(breadth_br_crop);
				context.lineTo(current.x,current.y);

				current.x += cr*scope.convertCmToPixel(length_br_crop - breadth_br_crop);
				current.y += sr*scope.convertCmToPixel(length_br_crop - breadth_br_crop);
				context.lineTo(current.x,current.y);

				current.x -= cb*scope.convertCmToPixel(length_br_crop - breadth_br_crop);
				current.y -= sb*scope.convertCmToPixel(length_br_crop - breadth_br_crop);
				context.lineTo(current.x,current.y);

				current.x += cr*scope.convertCmToPixel(breadth_br_crop);
				current.y += sr*scope.convertCmToPixel(breadth_br_crop);
				context.lineTo(current.x,current.y);
				
				context.lineTo(p2.x,p2.y);
				context.fill();

				// bl
				context.beginPath();
				var current = {x:p3.x,y:p3.y}
				context.moveTo(current.x,current.y);

				current.x += cr*scope.convertCmToPixel(length_bl_crop);
				current.y += sr*scope.convertCmToPixel(length_bl_crop);
				context.lineTo(current.x,current.y);

				current.x -= cb*scope.convertCmToPixel(breadth_bl_crop);
				current.y -= sb*scope.convertCmToPixel(breadth_bl_crop);
				context.lineTo(current.x,current.y);

				current.x -= cr*scope.convertCmToPixel(length_bl_crop - breadth_bl_crop);
				current.y -= sr*scope.convertCmToPixel(length_bl_crop - breadth_bl_crop);
				context.lineTo(current.x,current.y);

				current.x -= cb*scope.convertCmToPixel(length_bl_crop - breadth_bl_crop);
				current.y -= sb*scope.convertCmToPixel(length_bl_crop - breadth_bl_crop);
				context.lineTo(current.x,current.y);

				current.x -= cr*scope.convertCmToPixel(breadth_bl_crop);
				current.y -= sr*scope.convertCmToPixel(breadth_bl_crop);
				context.lineTo(current.x,current.y);
				
				context.lineTo(p3.x,p3.y);
				context.fill();

				var p0_outer = {x:scope.convertXOuter(vertices[0].x) - cr*(scope.convertCmToPixelOuter(breadth_tl_crop/2)) - cb*(scope.convertCmToPixelOuter(breadth_tl_crop/2)), y:scope.convertYOuter(vertices[0].y) - sr*(scope.convertCmToPixelOuter(breadth_tl_crop/2)) - sb*(scope.convertCmToPixelOuter(breadth_tl_crop/2))}
				var p1_outer = {x:scope.convertXOuter(vertices[1].x) + cr*(scope.convertCmToPixelOuter(breadth_tr_crop/2)) - cb*(scope.convertCmToPixelOuter(breadth_tr_crop/2)), y:scope.convertYOuter(vertices[1].y) + sr*(scope.convertCmToPixelOuter(breadth_tr_crop/2)) - sb*(scope.convertCmToPixelOuter(breadth_tr_crop/2))}
				var p2_outer = {x:scope.convertXOuter(vertices[2].x) + cr*(scope.convertCmToPixelOuter(breadth_br_crop/2)) + cb*(scope.convertCmToPixelOuter(breadth_br_crop/2)), y:scope.convertYOuter(vertices[2].y) + sr*(scope.convertCmToPixelOuter(breadth_br_crop/2)) + sb*(scope.convertCmToPixelOuter(breadth_br_crop/2))}
				var p3_outer = {x:scope.convertXOuter(vertices[3].x) - cr*(scope.convertCmToPixelOuter(breadth_bl_crop/2)) + cb*(scope.convertCmToPixelOuter(breadth_bl_crop/2)), y:scope.convertYOuter(vertices[3].y) - sr*(scope.convertCmToPixelOuter(breadth_bl_crop/2)) + sb*(scope.convertCmToPixelOuter(breadth_bl_crop/2))}
				
				// tl
				context_outer.beginPath();
				var current = {x:p0_outer.x,y:p0_outer.y}
				context_outer.moveTo(current.x,current.y);

				current.x += cr*scope.convertCmToPixelOuter(length_tl_crop);
				current.y += sr*scope.convertCmToPixelOuter(length_tl_crop);
				context_outer.lineTo(current.x,current.y);

				current.x += cb*scope.convertCmToPixelOuter(breadth_tl_crop);
				current.y += sb*scope.convertCmToPixelOuter(breadth_tl_crop);
				context_outer.lineTo(current.x,current.y);

				current.x -= cr*scope.convertCmToPixelOuter(length_tl_crop - breadth_tl_crop);
				current.y -= sr*scope.convertCmToPixelOuter(length_tl_crop - breadth_tl_crop);
				context_outer.lineTo(current.x,current.y);

				current.x += cb*scope.convertCmToPixelOuter(length_tl_crop - breadth_tl_crop);
				current.y += sb*scope.convertCmToPixelOuter(length_tl_crop - breadth_tl_crop);
				context_outer.lineTo(current.x,current.y);

				current.x -= cr*scope.convertCmToPixelOuter(breadth_tl_crop);
				current.y -= sr*scope.convertCmToPixelOuter(breadth_tl_crop);
				context_outer.lineTo(current.x,current.y);
				
				context_outer.lineTo(p0_outer.x,p0_outer.y);
				context_outer.fill();

				// tr
				context_outer.beginPath();
				var current = {x:p1_outer.x,y:p1_outer.y}
				context_outer.moveTo(current.x,current.y);

				current.x -= cr*scope.convertCmToPixelOuter(length_tr_crop);
				current.y -= sr*scope.convertCmToPixelOuter(length_tr_crop);
				context_outer.lineTo(current.x,current.y);

				current.x += cb*scope.convertCmToPixelOuter(breadth_tr_crop);
				current.y += sb*scope.convertCmToPixelOuter(breadth_tr_crop);
				context_outer.lineTo(current.x,current.y);

				current.x += cr*scope.convertCmToPixelOuter(length_tr_crop - breadth_tr_crop);
				current.y += sr*scope.convertCmToPixelOuter(length_tr_crop - breadth_tr_crop);
				context_outer.lineTo(current.x,current.y);

				current.x += cb*scope.convertCmToPixelOuter(length_tr_crop - breadth_tr_crop);
				current.y += sb*scope.convertCmToPixelOuter(length_tr_crop - breadth_tr_crop);
				context_outer.lineTo(current.x,current.y);

				current.x += cr*scope.convertCmToPixelOuter(breadth_tr_crop);
				current.y += sr*scope.convertCmToPixelOuter(breadth_tr_crop);
				context_outer.lineTo(current.x,current.y);
				
				context_outer.lineTo(p1_outer.x,p1_outer.y);
				context_outer.fill();

				// br
				context_outer.beginPath();
				var current = {x:p2_outer.x,y:p2_outer.y}
				context_outer.moveTo(current.x,current.y);

				current.x -= cr*scope.convertCmToPixelOuter(length_br_crop);
				current.y -= sr*scope.convertCmToPixelOuter(length_br_crop);
				context_outer.lineTo(current.x,current.y);

				current.x -= cb*scope.convertCmToPixelOuter(breadth_br_crop);
				current.y -= sb*scope.convertCmToPixelOuter(breadth_br_crop);
				context_outer.lineTo(current.x,current.y);

				current.x += cr*scope.convertCmToPixelOuter(length_br_crop - breadth_br_crop);
				current.y += sr*scope.convertCmToPixelOuter(length_br_crop - breadth_br_crop);
				context_outer.lineTo(current.x,current.y);

				current.x -= cb*scope.convertCmToPixelOuter(length_br_crop - breadth_br_crop);
				current.y -= sb*scope.convertCmToPixelOuter(length_br_crop - breadth_br_crop);
				context_outer.lineTo(current.x,current.y);

				current.x += cr*scope.convertCmToPixelOuter(breadth_br_crop);
				current.y += sr*scope.convertCmToPixelOuter(breadth_br_crop);
				context_outer.lineTo(current.x,current.y);
				
				context_outer.lineTo(p2_outer.x,p2_outer.y);
				context_outer.fill();

				// bl
				context_outer.beginPath();
				var current = {x:p3_outer.x,y:p3_outer.y}
				context_outer.moveTo(current.x,current.y);

				current.x += cr*scope.convertCmToPixelOuter(length_bl_crop);
				current.y += sr*scope.convertCmToPixelOuter(length_bl_crop);
				context_outer.lineTo(current.x,current.y);

				current.x -= cb*scope.convertCmToPixelOuter(breadth_bl_crop);
				current.y -= sb*scope.convertCmToPixelOuter(breadth_bl_crop);
				context_outer.lineTo(current.x,current.y);

				current.x -= cr*scope.convertCmToPixelOuter(length_bl_crop - breadth_bl_crop);
				current.y -= sr*scope.convertCmToPixelOuter(length_bl_crop - breadth_bl_crop);
				context_outer.lineTo(current.x,current.y);

				current.x -= cb*scope.convertCmToPixelOuter(length_bl_crop - breadth_bl_crop);
				current.y -= sb*scope.convertCmToPixelOuter(length_bl_crop - breadth_bl_crop);
				context_outer.lineTo(current.x,current.y);

				current.x -= cr*scope.convertCmToPixelOuter(breadth_bl_crop);
				current.y -= sr*scope.convertCmToPixelOuter(breadth_bl_crop);
				context_outer.lineTo(current.x,current.y);
				
				context_outer.lineTo(p3_outer.x,p3_outer.y);
				context_outer.fill();

				var image_vertices = object.getImageCropVertices();

				if(Math.abs(image_vertices[0].x - vertices[0].x)>3 || Math.abs(image_vertices[0].y - vertices[0].y)>3){
					drawCircle(
						context,
						scope.convertX(image_vertices[0].x),
						scope.convertY(image_vertices[0].y),
						scope.convertCmToPixel(rad_tl_crop_2),
						true,'#ffffff',
						true,'#000000',scope.convertCmToPixel(1)
					)

					drawCircle(
						context_outer,
						scope.convertXOuter(image_vertices[0].x),
						scope.convertYOuter(image_vertices[0].y),
						scope.convertCmToPixelOuter(rad_tl_crop_2),
						true,'#ffffff',
						true,'#000000',scope.convertCmToPixel(1)
					)
				}

				if(Math.abs(image_vertices[1].x - vertices[1].x)>3 || Math.abs(image_vertices[1].y - vertices[1].y)>3){
					drawCircle(
						context,
						scope.convertX(image_vertices[1].x),
						scope.convertY(image_vertices[1].y),
						scope.convertCmToPixel(rad_tr_crop_2),
						true,'#ffffff',
						true,'#000000',scope.convertCmToPixel(1)
					)

					drawCircle(
						context_outer,
						scope.convertXOuter(image_vertices[1].x),
						scope.convertYOuter(image_vertices[1].y),
						scope.convertCmToPixelOuter(rad_tr_crop_2),
						true,'#ffffff',
						true,'#000000',scope.convertCmToPixel(1)
					)
				}

				if(Math.abs(image_vertices[2].x - vertices[2].x)>3 || Math.abs(image_vertices[2].y - vertices[2].y)>3){
					drawCircle(
						context,
						scope.convertX(image_vertices[2].x),
						scope.convertY(image_vertices[2].y),
						scope.convertCmToPixel(rad_br_crop_2),
						true,'#ffffff',
						true,'#000000',scope.convertCmToPixel(1)
					)

					drawCircle(
						context_outer,
						scope.convertXOuter(image_vertices[2].x),
						scope.convertYOuter(image_vertices[2].y),
						scope.convertCmToPixelOuter(rad_br_crop_2),
						true,'#ffffff',
						true,'#000000',scope.convertCmToPixel(1)
					)
				}

				if(Math.abs(image_vertices[3].x - vertices[3].x)>3 || Math.abs(image_vertices[3].y - vertices[3].y)>3){
					drawCircle(
						context,
						scope.convertX(image_vertices[3].x),
						scope.convertY(image_vertices[3].y),
						scope.convertCmToPixel(rad_bl_crop_2),
						true,'#ffffff',
						true,'#000000',scope.convertCmToPixel(1)
					)

					drawCircle(
						context_outer,
						scope.convertXOuter(image_vertices[3].x),
						scope.convertYOuter(image_vertices[3].y),
						scope.convertCmToPixelOuter(rad_bl_crop_2),
						true,'#ffffff',
						true,'#000000',scope.convertCmToPixel(1)
					)
				}
			}else if(object.type == 'grid' && object.grid_details.boxes.find(function(o){return o.image == scope.activeCropImage})){
				var image_vertices;
				var master = scope.activeCropImage
				if(master){
					master = master.master
				}
				if(master && master.image_vertices){
					image_vertices = master.image_vertices
				}

				if(image_vertices){
					drawCircle(
						context,
						scope.convertX(image_vertices[0].x),
						scope.convertY(image_vertices[0].y),
						scope.convertCmToPixel(rad_tl_crop_2),
						true,'#ffffff',
						true,'#000000',scope.convertCmToPixel(1)
					)

					drawCircle(
						context,
						scope.convertX(image_vertices[1].x),
						scope.convertY(image_vertices[1].y),
						scope.convertCmToPixel(rad_tr_crop_2),
						true,'#ffffff',
						true,'#000000',scope.convertCmToPixel(1)
					)

					drawCircle(
						context,
						scope.convertX(image_vertices[2].x),
						scope.convertY(image_vertices[2].y),
						scope.convertCmToPixel(rad_br_crop_2),
						true,'#ffffff',
						true,'#000000',scope.convertCmToPixel(1)
					)

					drawCircle(
						context,
						scope.convertX(image_vertices[3].x),
						scope.convertY(image_vertices[3].y),
						scope.convertCmToPixel(rad_bl_crop_2),
						true,'#ffffff',
						true,'#000000',scope.convertCmToPixel(1)
					)

					drawCircle(
						context_outer,
						scope.convertXOuter(image_vertices[0].x),
						scope.convertYOuter(image_vertices[0].y),
						scope.convertCmToPixelOuter(rad_tl_crop_2),
						true,'#ffffff',
						true,'#000000',scope.convertCmToPixel(1)
					)

					drawCircle(
						context_outer,
						scope.convertXOuter(image_vertices[1].x),
						scope.convertYOuter(image_vertices[1].y),
						scope.convertCmToPixelOuter(rad_tr_crop_2),
						true,'#ffffff',
						true,'#000000',scope.convertCmToPixel(1)
					)

					drawCircle(
						context_outer,
						scope.convertXOuter(image_vertices[2].x),
						scope.convertYOuter(image_vertices[2].y),
						scope.convertCmToPixelOuter(rad_br_crop_2),
						true,'#ffffff',
						true,'#000000',scope.convertCmToPixel(1)
					)

					drawCircle(
						context_outer,
						scope.convertXOuter(image_vertices[3].x),
						scope.convertYOuter(image_vertices[3].y),
						scope.convertCmToPixelOuter(rad_bl_crop_2),
						true,'#ffffff',
						true,'#000000',scope.convertCmToPixel(1)
					)
				}
			}
		}

		if(scope.mode != 'crop' && !dont_draw_corners){
			if(object.type!="text" && !(object.type == 'grid' && object.sub_type=='frame') && !(object.type=='group' && _.findIndex(object.group_details.object_data,function(o){return o.object.type=='text' || (o.object.type == 'grid' && o.object.sub_type=='frame')})>-1 ) ){
				drawCropIcon(
					context,
					{x:scope.convertX(vertices[0].x),y:scope.convertY(vertices[0].y)},
					{x:scope.convertX(vertices[1].x),y:scope.convertY(vertices[1].y)},
					scope.convertCmToPixel(rad_t)
				)
				drawCropIcon(
					context,
					{x:scope.convertX(vertices[2].x),y:scope.convertY(vertices[2].y)},
					{x:scope.convertX(vertices[3].x),y:scope.convertY(vertices[3].y)},
					scope.convertCmToPixel(rad_b)
				)

				drawCropIcon(
					context_outer,
					{x:scope.convertXOuter(vertices[0].x),y:scope.convertYOuter(vertices[0].y)},
					{x:scope.convertXOuter(vertices[1].x),y:scope.convertYOuter(vertices[1].y)},
					scope.convertCmToPixelOuter(rad_t)
				)
				drawCropIcon(
					context_outer,
					{x:scope.convertXOuter(vertices[2].x),y:scope.convertYOuter(vertices[2].y)},
					{x:scope.convertXOuter(vertices[3].x),y:scope.convertYOuter(vertices[3].y)},
					scope.convertCmToPixelOuter(rad_b)
				)
			}

			if(!(object.type == 'grid' && object.sub_type=='frame') && !(object.type=='group' && _.findIndex(object.group_details.object_data,function(o){return o.object.type == 'grid' && o.object.sub_type=='frame'})>-1 )){
				drawCropIcon(
					context,
					{x:scope.convertX(vertices[1].x),y:scope.convertY(vertices[1].y)},
					{x:scope.convertX(vertices[2].x),y:scope.convertY(vertices[2].y)},
					scope.convertCmToPixel(rad_r)
				)
				drawCropIcon(
					context,
					{x:scope.convertX(vertices[3].x),y:scope.convertY(vertices[3].y)},
					{x:scope.convertX(vertices[0].x),y:scope.convertY(vertices[0].y)},
					scope.convertCmToPixel(rad_l)
				)

				drawCropIcon(
					context_outer,
					{x:scope.convertXOuter(vertices[1].x),y:scope.convertYOuter(vertices[1].y)},
					{x:scope.convertXOuter(vertices[2].x),y:scope.convertYOuter(vertices[2].y)},
					scope.convertCmToPixelOuter(rad_r)
				)
				drawCropIcon(
					context_outer,
					{x:scope.convertXOuter(vertices[3].x),y:scope.convertYOuter(vertices[3].y)},
					{x:scope.convertXOuter(vertices[0].x),y:scope.convertYOuter(vertices[0].y)},
					scope.convertCmToPixelOuter(rad_l)
				)
			}

			if(scope.rotate_svg){
				var rotation_vertex = object.getRotationPoint();		
				drawCircle(
					context,
					scope.convertX(rotation_vertex.x),
					scope.convertY(rotation_vertex.y),
					scope.convertCmToPixel(rad_rotate),
					true,'#ffffff',
					true,'#000000',scope.convertCmToPixel(1)
				)

				drawCircle(
					context_outer,
					scope.convertXOuter(rotation_vertex.x),
					scope.convertYOuter(rotation_vertex.y),
					scope.convertCmToPixelOuter(rad_rotate),
					true,'#ffffff',
					true,'#000000',scope.convertCmToPixel(1)
				)

				if(scope.activeElement && scope.activeElement.corner == 'rotate'){
					context.fillStyle = '#000000'
					context.font = "normal "+Math.ceil(scope.convertCmToPixel(16))+"px Arial";
					context.fillText((object.rotation*180/Math.PI).toFixed(0)+'˚', scope.convertX(rotation_vertex.x+25),scope.convertY(rotation_vertex.y+25));

					context_outer.fillStyle = '#000000'
					context_outer.font = "normal "+Math.ceil(scope.convertCmToPixelOuter(16))+"px Arial";
					context_outer.fillText((object.rotation*180/Math.PI).toFixed(0)+'˚', scope.convertXOuter(rotation_vertex.x+25),scope.convertYOuter(rotation_vertex.y+25));
				}

				context.drawImage(scope.rotate_svg,scope.convertX(rotation_vertex.x)-0.6*(rad_rotate),scope.convertY(rotation_vertex.y)-0.6*(rad_rotate),1.2*rad_rotate,1.2*rad_rotate)
				context_outer.drawImage(scope.rotate_svg,scope.convertXOuter(rotation_vertex.x)-0.6*(rad_rotate),scope.convertYOuter(rotation_vertex.y)-0.6*(rad_rotate),1.2*rad_rotate,1.2*rad_rotate)
			}
		}

		if(object.type == 'group'){
			for (var i = 0; i < object.group_details.object_data.length; i++) {
				drawSelectionBox(object.group_details.object_data[i].object,true,object.group_details.object_data[i].object==scope.group_selected_object?'#fc6d1a':'rgba(0,0,0,0)');
			}
		}

		if(object.type == 'grid'){
			for (var i = 0; i < object.grid_details.boxes.length; i++) {
				if(!object.grid_details.boxes[i].getVertices){
					object.grid_details.boxes[i].getVertices = function(){return this.vertices}
				}
				drawSelectionBox(object.grid_details.boxes[i],true,object.grid_details.boxes[i]==scope.grid_selected_box?'#fc6d1a':'rgba(0,0,0,0)');
			}
		}
	}

	function drawCircle(context,centerX,centerY,radius,fill,fillColor,stroke,strokeColor,strokeWidth){
		context.beginPath();
		context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
		if(fill){
			context.fillStyle = fillColor;
			context.fill();
		}
		if(stroke){
			context.lineWidth = strokeWidth;
			context.strokeStyle = strokeColor;
			context.stroke();
		}
	}

	function drawCropIcon(context,point1,point2,radius){
		var center = {x: (point1.x+point2.x)/2,y: (point1.y+point2.y)/2}

		var angle = Math.atan2(point2.y-point1.y,point2.x-point1.x);

		var length = 2.5
		// if(object.height<30){
		// 	length = 1.5
		// }

		var p1 = {
			x: center.x - Math.cos(angle)*length*radius + Math.cos(angle+(Math.PI/2))*radius,
			y: center.y - Math.sin(angle)*length*radius + Math.sin(angle+(Math.PI/2))*radius
		}


		var p2 = {
			x: center.x + Math.cos(angle)*length*radius + Math.cos(angle+(Math.PI/2))*radius,
			y: center.y + Math.sin(angle)*length*radius + Math.sin(angle+(Math.PI/2))*radius
		}

		var p3 = {
			x: center.x + Math.cos(angle)*length*radius - Math.cos(angle+(Math.PI/2))*radius,
			y: center.y + Math.sin(angle)*length*radius - Math.sin(angle+(Math.PI/2))*radius
		}

		var p4 = {
			x: center.x - Math.cos(angle)*length*radius - Math.cos(angle+(Math.PI/2))*radius,
			y: center.y - Math.sin(angle)*length*radius - Math.sin(angle+(Math.PI/2))*radius
		}

		context.strokeStyle = '#000000';
		context.fillStyle = '#ffffff';

		context.beginPath();
		context.moveTo(p1.x,p1.y);
		context.lineTo(p2.x,p2.y);
		context.quadraticCurveTo((Math.cos(angle)*radius)+(p2.x+p3.x)/2,(Math.sin(angle)*radius)+(p2.y+p3.y)/2,p3.x,p3.y)
		context.lineTo(p4.x,p4.y);
		context.quadraticCurveTo(-(Math.cos(angle)*radius)+(p4.x+p1.x)/2,-(Math.sin(angle)*radius)+(p4.y+p1.y)/2,p1.x,p1.y)
		context.stroke();
		context.fill();
	}

	function drawBackgroundCropPoints(){
		var context = scope.canvas.getContext('2d')
		var context_outer = scope.canvas_outer.getContext('2d')

		var rad_tl_crop_2=rad_tr_crop_2=rad_br_crop_2=rad_bl_crop_2=6;
		if(scope.background_crop_corner.top_left_crop_2){
			rad_tl_crop_2 = 9
		}else if(scope.background_crop_corner.top_right_crop_2){
			rad_tr_crop_2 = 9
		}else if(scope.background_crop_corner.bottom_right_crop_2){
			rad_br_crop_2 = 9
		}else if(scope.background_crop_corner.bottom_left_crop_2){
			rad_bl_crop_2 = 9
		}

		var image_vertices = [
			{x: scope.background_details.contentDisplacement.x,y: scope.background_details.contentDisplacement.y},
			{x: scope.background_details.contentDisplacement.x + scope.background_details.image_width,y: scope.background_details.contentDisplacement.y},
			{x: scope.background_details.contentDisplacement.x + scope.background_details.image_width,y: scope.background_details.contentDisplacement.y + scope.background_details.image_height},
			{x: scope.background_details.contentDisplacement.x,y: scope.background_details.contentDisplacement.y + scope.background_details.image_height}
		]
		var w = editor.get_width(); var h = editor.get_height();

		drawCircle(
			context,
			scope.convertX(image_vertices[0].x),
			scope.convertY(image_vertices[0].y),
			rad_tl_crop_2,
			true,'#ffffff',
			true,'#000000',scope.convertCmToPixel(1)
		)

		drawCircle(
			context,
			scope.convertX(image_vertices[1].x),
			scope.convertY(image_vertices[1].y),
			rad_tr_crop_2,
			true,'#ffffff',
			true,'#000000',scope.convertCmToPixel(1)
		)

		drawCircle(
			context,
			scope.convertX(image_vertices[2].x),
			scope.convertY(image_vertices[2].y),
			rad_br_crop_2,
			true,'#ffffff',
			true,'#000000',scope.convertCmToPixel(1)
		)

		drawCircle(
			context,
			scope.convertX(image_vertices[3].x),
			scope.convertY(image_vertices[3].y),
			rad_bl_crop_2,
			true,'#ffffff',
			true,'#000000',scope.convertCmToPixel(1)
		)

		drawCircle(
			context_outer,
			scope.convertXOuter(image_vertices[0].x),
			scope.convertYOuter(image_vertices[0].y),
			rad_tl_crop_2,
			true,'#ffffff',
			true,'#000000',scope.convertCmToPixel(1)
		)

		drawCircle(
			context_outer,
			scope.convertXOuter(image_vertices[1].x),
			scope.convertYOuter(image_vertices[1].y),
			rad_tr_crop_2,
			true,'#ffffff',
			true,'#000000',scope.convertCmToPixel(1)
		)

		drawCircle(
			context_outer,
			scope.convertXOuter(image_vertices[2].x),
			scope.convertYOuter(image_vertices[2].y),
			rad_br_crop_2,
			true,'#ffffff',
			true,'#000000',scope.convertCmToPixel(1)
		)

		drawCircle(
			context_outer,
			scope.convertXOuter(image_vertices[3].x),
			scope.convertYOuter(image_vertices[3].y),
			rad_bl_crop_2,
			true,'#ffffff',
			true,'#000000',scope.convertCmToPixel(1)
		)
	}

	function drawBackground(){
		var context = scope.canvas.getContext('2d')
		context.fillStyle = design.background_color
		context.fillRect(0, 0, scope.canvas.width, scope.canvas.height);

		var image_raw

		var image_cache_id = design.background_image.id_unsplash||design.background_image.id_pixlr||design.background_image.id_123rf||design.background_image.resource_id||design.background_image.src||design.background_mockup_details.id
		image_cache_id += ('background_' + scope.id + '_')

		if(scope.background_image_exists()){
			if(editor.loaded_images[image_cache_id]){
				image_raw = editor.loaded_images[image_cache_id]
				if(scope.background_needs_redraw){
					design.background_loader_image = null;
					continueDrawingBackground(image_raw)
				}
			}else if(!editor.loading_images[image_cache_id]){
				editor.loading_images[image_cache_id] = true
				var details = deref(design.background_image);
				details.image_contain = design.background_details.image_contain

				var load_promise = scope.loadImage({sub_type:design.background_sub_type,mockup_details: design.background_mockup_details,bgremoval: design.background_bgremoval,image_details:details,image_cache_id: function(){return image_cache_id} });
				editor.resource_promise_array.push(load_promise);
				load_promise.then(function(image_raw){
					design.background_loader_image = null;
					scope.background_needs_redraw = true;
					scope.needs_redraw = true;
				})
			}
		}
		

		var image_special_type
		if(design.background_loader_image){
			image_special_type = 'loader'
			continueDrawingBackground(design.background_loader_image,image_special_type)
		}

		if(editor.drag_details && editor.drag_details.replace_feedback && editor.drag_details.replace_feedback.obj == 'background' && editor.drag_details.replace_feedback.replace_image){
			image_special_type = 'replace'
			continueDrawingBackground(editor.drag_details.replace_feedback.replace_image,image_special_type)
		}


		function continueDrawingBackground(image_raw,image_special_type){
			if(!scope.bg_canvas){
				scope.bg_canvas = document.createElement('canvas');
				// scope.bg_canvas = new OffscreenCanvas(256,256);
			}

			scope.bg_canvas.width = scope.canvas.width
			scope.bg_canvas.height = scope.canvas.height

			var context = scope.bg_canvas.getContext('2d')


			if(design.background_details.image_needs_autoset){
				var image_width = image_raw.width
				var image_height = image_raw.height

				var box_width = editor.get_width()
				var box_height = editor.get_height()

				var pos_x; var pos_y;var draw_width;var draw_height
				if((image_width/image_height)>(box_width/box_height)){
					draw_height = box_height
					draw_width = draw_height*(image_width/image_height)
					pos_y = 0
					pos_x = -(draw_width - box_width)/2
				}else{
					draw_width = box_width
					draw_height = draw_width*(image_height/image_width)
					pos_x = 0
					pos_y = -(draw_height - box_height)/2
				}

				design.background_details.contentDisplacement.x = pos_x
                design.background_details.contentDisplacement.y = pos_y

                design.background_details.image_width = draw_width
                design.background_details.image_height = draw_height
                design.background_details.image_needs_autoset = false;
                editor.addUndoChange()
			}

			if(design.background_details.flip_horizontal!=undefined && design.background_details.flip_vertical!=undefined){
				var scale_x = Number(design.background_details.flip_horizontal)
				var scale_y = Number(design.background_details.flip_vertical)
			}else{
				var scale_x = 1
				var scale_y = 1
			}

			if(image_special_type == 'replace'){
				var image_width = image_raw.width
				var image_height = image_raw.height

				var box_width = editor.get_width()
				var box_height = editor.get_height()

				var pos_x; var pos_y;var draw_width;var draw_height
				if((image_width/image_height)>(box_width/box_height)){
					draw_height = box_height
					draw_width = draw_height*(image_width/image_height)
					pos_y = 0
					pos_x = -(draw_width - box_width)/2
				}else{
					draw_width = box_width
					draw_height = draw_width*(image_height/image_width)
					pos_x = 0
					pos_y = -(draw_height - box_height)/2
				}

                var pos_x = scope.convertCmToPixel(pos_x)
				var draw_width = scope.convertCmToPixel(draw_width)
				var pos_y = scope.convertCmToPixel(pos_y)
				var draw_height = scope.convertCmToPixel(draw_height)
			}else{
				var pos_x = scope.convertCmToPixel(design.background_details.contentDisplacement.x)
				var draw_width = scope.convertCmToPixel(design.background_details.image_width)
				var pos_y = scope.convertCmToPixel(design.background_details.contentDisplacement.y)
				var draw_height = scope.convertCmToPixel(design.background_details.image_height)
			}

			if(scale_x == -1){
				pos_x = -(draw_width + pos_x)
			}
			if(scale_y == -1){
				pos_y = -(draw_height + pos_y)
			}

			if(image_special_type == 'loader'){
				context.filter = 'blur(7px)';
			}else if(scope.background_details.filter){
				context.filter= 'url(#'+scope.background_details.filter.id+')'
			}else{
				context.filter = 'none';
			}

			context.save()
			context.scale(scale_x, scale_y);
			context.drawImage(
				image_raw,
				pos_x,pos_y,
				draw_width,draw_height
			)

			context.restore()

			if(image_special_type!='loader' && image_special_type!='replace'){
				applyImageFilter(scope.bg_canvas,scope.background_filter);
			}

			if(scope.mode == 'crop' && scope.activeCropImage == 'background'){
				if(!scope.bg_canvas_crop){
					scope.bg_canvas_crop = document.createElement('canvas');
					// scope.bg_canvas_crop = new OffscreenCanvas(256,256);
				}

				scope.bg_canvas_crop.width = Math.ceil(draw_width)
				scope.bg_canvas_crop.height = Math.ceil(draw_height)

				var context_crop = scope.bg_canvas_crop.getContext('2d');
				if(scope.background_details.filter){
					context_crop.filter= 'url(#'+scope.background_details.filter.id+')'
				}

				pos_x = 0;pos_y = 0
				if(scale_x == -1){
					pos_x = -(draw_width + pos_x)
				}
				if(scale_y == -1){
					pos_y = -(draw_height + pos_y)
				}

				context_crop.save()
				context_crop.scale(scale_x, scale_y);
				context_crop.drawImage(
					image_raw,
					pos_x,pos_y,
					draw_width,draw_height
				)
				context_crop.restore()
				applyImageFilter(scope.bg_canvas_crop,scope.background_filter);
			}
		}

		if(scope.bg_canvas && (scope.background_image_exists() || image_special_type == 'loader' || image_special_type == 'replace')){
			var context = scope.canvas.getContext('2d');
			context.drawImage(scope.bg_canvas,0,0,scope.canvas.width,scope.canvas.height)

			if(scope.mode == 'crop' && scope.activeCropImage == 'background' && scope.bg_canvas_crop){
				var context_outer = scope.canvas_outer.getContext('2d');
				context_outer.drawImage(
					scope.bg_canvas_crop,
					scope.convertXOuter(design.background_details.contentDisplacement.x),scope.convertYOuter(design.background_details.contentDisplacement.y),
					scope.bg_canvas_crop.width,scope.bg_canvas_crop.height
				)
			}

			if(scope.mode == 'crop'){
				var context_outer = scope.canvas_outer.getContext('2d')
				context_outer.fillStyle = 'rgba(120,120,120,0.5)'
				context_outer.fillRect(0, 0, scope.canvas_outer.width, scope.canvas_outer.height);
			}

			if(image_special_type != 'replace'){
				scope.background_needs_redraw = false	
			}
		}

		if(!(scope.background_image_exists() || image_special_type == 'loader' || image_special_type == 'replace')){
			if(image_special_type != 'replace'){
				scope.background_needs_redraw = false	
			}
		}

		if(scope.mode == 'crop' && scope.activeCropImage == 'background'){
			drawBackgroundCropPoints()
		}
	}

	function drawGrid(grid){
		var image_raw
		if(grid.needs_redraw){
			if(!grid.canvas){
				grid.canvas = document.createElement('canvas');
				// grid.canvas = new OffscreenCanvas(256,256);
			}

			grid.canvas.width = Math.ceil(scope.convertCmToPixel(grid.width));
			grid.canvas.height = Math.ceil(scope.convertCmToPixel(grid.height));

			grid.updateGridBoxes()

			grid.canvas.getContext('2d').clearRect(0, 0, grid.canvas.width, grid.canvas.height);
			for (var i = 0; i < grid.grid_details.boxes.length; i++) {
				if(!grid.grid_details.boxes[i].canvas){
					grid.grid_details.boxes[i].canvas = document.createElement('canvas');
					// grid.grid_details.boxes[i].canvas = new OffscreenCanvas(256,256);
				}

				grid.grid_details.boxes[i].canvas.width = Math.ceil(scope.convertCmToPixel(grid.grid_details.boxes[i].width*grid.width/100));
				grid.grid_details.boxes[i].canvas.height = Math.ceil(scope.convertCmToPixel(grid.grid_details.boxes[i].height*grid.height/100));

				var image_special_type = null
				if(grid.grid_details.boxes[i].loader_image_frame){
					image_special_type = 'loader_frame'
					grid.grid_details.boxes[i].loaded_attached_frame = grid.grid_details.boxes[i].loader_image_frame
				}

				function tempLoadFrame(frame,i){
					var load_promise = scope.loadImage(frame,grid.id);
					editor.resource_promise_array.push(load_promise);
					load_promise.then(function(image_raw){
						delete grid.grid_details.boxes[i].loader_image_frame
						grid.grid_details.boxes[i].loaded_attached_frame = image_raw
						grid.set_redraw()
						scope.needs_redraw = true;
					})
				}

				var context = grid.grid_details.boxes[i].canvas.getContext('2d');
				context.clearRect(0, 0, grid.grid_details.boxes[i].canvas.width, grid.grid_details.boxes[i].canvas.height);
				if(grid.grid_details.boxes[i].frame && (image_special_type=="loader_frame" || !grid.grid_details.boxes[i].loaded_attached_frame)){
					var frame = grid.grid_details.boxes[i].frame
					var image_cache_id = frame.image_cache_id(grid.id)
					var loadable = frame.image_details.id_unsplash||frame.image_details.id_pixlr||frame.image_details.id_123rf||frame.image_details.resource_id||frame.image_details.src

					if(loadable){
						if(editor.loaded_images[image_cache_id]){
							if(image_special_type == 'loader_frame'){
								image_special_type = undefined
							}
							delete grid.grid_details.boxes[i].loader_image_frame
							image_raw = editor.loaded_images[image_cache_id]
							grid.grid_details.boxes[i].loaded_attached_frame = image_raw
						}else if(!editor.loading_images[image_cache_id]){
							editor.loading_images[image_cache_id] = true
							tempLoadFrame(frame,i)
						}
					}
				}

				function tempLoadImage(image,i){
					var load_promise = scope.loadImage(image,grid.id)
					editor.resource_promise_array.push(load_promise);
					load_promise.then(function(image_raw){
						delete grid.grid_details.boxes[i].loader_image
						grid.grid_details.boxes[i].loaded_attached_image = image_raw
						grid.set_redraw()
						scope.needs_redraw = true;
					})
				}

				if(grid.grid_details.boxes[i].loader_image){
					image_special_type = 'loader'
					grid.grid_details.boxes[i].loaded_attached_image = grid.grid_details.boxes[i].loader_image
				}

				if(editor.drag_details && editor.drag_details.replace_feedback && editor.drag_details.replace_feedback.obj == grid && editor.drag_details.replace_feedback.box == grid.grid_details.boxes[i] && editor.drag_details.replace_feedback.replace_image){
					image_special_type = 'replace'
					grid.grid_details.boxes[i].loaded_attached_image = editor.drag_details.replace_feedback.replace_image
				}

				
				
				var image_to_draw
				var image = grid.grid_details.boxes[i].image
				if(image && (image_special_type=="loader" || !grid.grid_details.boxes[i].loaded_attached_image)){
					var image = grid.grid_details.boxes[i].image
					var image_cache_id = image.image_cache_id(grid.id)
					var loadable = image.image_details.id_unsplash||image.image_details.id_pixlr||image.image_details.id_123rf||image.image_details.resource_id||image.image_details.src

					if(loadable){
						if(editor.loaded_images[image_cache_id]){
							if(image_special_type == 'loader'){
								image_special_type = undefined
							}
							delete grid.grid_details.boxes[i].loader_image
							image_raw = editor.loaded_images[image_cache_id]
							grid.grid_details.boxes[i].loaded_attached_image = image_raw
						}else if(!editor.loading_images[image_cache_id]){
							editor.loading_images[image_cache_id] = true
							tempLoadImage(image,i)
						}
					}
				}
					
				if(grid.grid_details.boxes[i].loaded_attached_image){
					image_to_draw = grid.grid_details.boxes[i].loaded_attached_image
				}else if(!grid.grid_details.boxes[i].frame && !grid.grid_details.boxes[i].color){
					if(scope.grid_background){
						image_to_draw = scope.grid_background
					}else{
						load_grid_promise.then(function(){
							if(scope.grid_background){
								image_to_draw = scope.grid_background
								grid.set_redraw()
								design.needs_redraw = true
							}
						})
					}
				}else{
					image_to_draw = null
				}

				if(image_special_type == 'loader' || image_special_type == 'loader_frame'){
					context.filter = 'blur(4px)';
				}else if(grid.grid_details.boxes[i].attached_filter && !grid.grid_details.boxes[i].color){
					context.filter= 'url(#'+grid.grid_details.boxes[i].attached_filter.id+')'
				}else if(grid.grid_details.boxes[i].image && grid.grid_details.boxes[i].image.image_details.filter && !grid.grid_details.boxes[i].color){
					context.filter= 'url(#'+grid.grid_details.boxes[i].image.image_details.filter.id+')'
				}else if(grid.grid_details.boxes[i].frame && grid.grid_details.boxes[i].frame.image_details.filter && !grid.grid_details.boxes[i].color){
					context.filter= 'url(#'+grid.grid_details.boxes[i].frame.image_details.filter.id+')'
				}else{
					context.filter = 'none'
				}

				if(grid.grid_details.boxes[i].color){
					context.fillStyle = grid.grid_details.boxes[i].color
					context.fillRect(0, 0, grid.grid_details.boxes[i].canvas.width, grid.grid_details.boxes[i].canvas.height);
				}


				if(image_to_draw){
					if(image && image_to_draw != scope.grid_background){
						if(image.image_details.image_needs_autoset){
							var image_width = image_to_draw.width
							var image_height = image_to_draw.height

							var box_width = grid.grid_details.boxes[i].width*grid.width/100
							var box_height = grid.grid_details.boxes[i].height*grid.height/100

							var pos_x; var pos_y;var draw_width;var draw_height
							if((image_width/image_height)>(box_width/box_height)){
								draw_height = box_height
								draw_width = draw_height*(image_width/image_height)
								pos_y = 0
								pos_x = -(draw_width - box_width)/2
							}else{
								draw_width = box_width
								draw_height = draw_width*(image_height/image_width)
								pos_x = 0
								pos_y = -(draw_height - box_height)/2;
							}


							image.image_details.contentDisplacement.x = pos_x
			                image.image_details.contentDisplacement.y = pos_y

			                image.image_details.image_width = draw_width
			                image.image_details.image_height = draw_height
							image.image_details.image_needs_autoset = false
							// editor.addUndoChange()
						}


						if(image.image_details.flip_horizontal!=undefined && image.image_details.flip_vertical!=undefined){
							var scale_x = Number(image.image_details.flip_horizontal)
							var scale_y = Number(image.image_details.flip_vertical)
						}else{
							var scale_x = 1
							var scale_y = 1
						}

						if(image_special_type == 'replace'){
							var image_width = image_to_draw.width
							var image_height = image_to_draw.height

							var box_width = grid.grid_details.boxes[i].width*grid.width/100
							var box_height = grid.grid_details.boxes[i].height*grid.height/100

							var pos_x; var pos_y;var draw_width;var draw_height
							if((image_width/image_height)>(box_width/box_height)){
								draw_height = box_height
								draw_width = draw_height*(image_width/image_height)
								pos_y = 0
								pos_x = -(draw_width - box_width)/2
							}else{
								draw_width = box_width
								draw_height = draw_width*(image_height/image_width)
								pos_x = 0
								pos_y = -(draw_height - box_height)/2;
							}

							var pos_x = scope.convertCmToPixel(pos_x)
							var draw_width = scope.convertCmToPixel(draw_width)

							var pos_y = scope.convertCmToPixel(pos_y)
							var draw_height = scope.convertCmToPixel(draw_height)
						}else{
							var pos_x = scope.convertCmToPixel(image.image_details.contentDisplacement.x)
							var draw_width = scope.convertCmToPixel(image.image_details.image_width)

							var pos_y = scope.convertCmToPixel(image.image_details.contentDisplacement.y)
							var draw_height = scope.convertCmToPixel(image.image_details.image_height)
						}

						if(scale_x == -1){
							pos_x = -(draw_width + pos_x)
						}

						if(scale_y == -1){
							pos_y = -(draw_height + pos_y)
						}
					}else{
						var scale_x = 1
						var scale_y = 1

						var image_width = image_to_draw.width
						var image_height = image_to_draw.height

						var box_width = scope.convertCmToPixel(grid.grid_details.boxes[i].width*grid.width/100)
						var box_height = scope.convertCmToPixel(grid.grid_details.boxes[i].height*grid.height/100)

						var pos_x; var pos_y;var draw_width;var draw_height
						if((image_width/image_height)>(box_width/box_height)){
							draw_height = box_height
							draw_width = draw_height*(image_width/image_height)
							pos_y = 0
							pos_x = -(draw_width - box_width)/2
						}else{
							draw_width = box_width
							draw_height = draw_width*(image_height/image_width)
							pos_x = 0
							pos_y = -(draw_height - box_height)/2;
						}
					}
					context.save()
					context.scale(scale_x, scale_y);

					context.drawImage(
						image_to_draw,
						pos_x,pos_y,
						draw_width,draw_height
					)
					context.restore();
					if(image){
						applyImageFilter(grid.grid_details.boxes[i].canvas,image.filter);
					}
					

					if(image && scope.mode == 'crop' && scope.activeCropImage == image){
						if(!image.canvas_crop){
							image.canvas_crop = document.createElement('canvas');
							// image.canvas_crop = new OffscreenCanvas(256,256);
						}

						image.canvas_crop.width = Math.ceil(scope.convertCmToPixel(image.image_details.image_width));
						image.canvas_crop.height = Math.ceil(scope.convertCmToPixel(image.image_details.image_height));

						var context_crop = image.canvas_crop.getContext('2d');
						context_crop.globalAlpha = 0.5
						if(grid.grid_details.boxes[i].attached_filter){
							context_crop.filter= 'url(#'+grid.grid_details.boxes[i].attached_filter.id+')'
						}
						context_crop.clearRect(0, 0, image.canvas_crop.width, image.canvas_crop.height);
						if(image.image_details.flip_horizontal!=undefined && image.image_details.flip_vertical!=undefined){
							var scale_x = Number(image.image_details.flip_horizontal)
							var scale_y = Number(image.image_details.flip_vertical)
						}else{
							var scale_x = 1
							var scale_y = 1
						}
						
						var pos_x = 0
						var draw_width = scope.convertCmToPixel(image.image_details.image_width)
						if(scale_x == -1){
							pos_x = -(draw_width + pos_x)
						}

						var pos_y = 0
						var draw_height = scope.convertCmToPixel(image.image_details.image_height)
						if(scale_y == -1){
							pos_y = -(draw_height + pos_y)
						}

						context_crop.save()
						context_crop.scale(scale_x, scale_y);
						context_crop.drawImage(image_to_draw,pos_x,pos_y,image.canvas_crop.width,image.canvas_crop.height);
						context_crop.globalAlpha = 1;
						context_crop.restore()
						applyImageFilter(image.canvas_crop,image.filter);
					}
				}

				if(grid.grid_details.boxes[i].loaded_attached_frame){
					context.globalCompositeOperation = 'destination-in'
					context.drawImage(grid.grid_details.boxes[i].loaded_attached_frame,0, 0, grid.grid_details.boxes[i].canvas.width, grid.grid_details.boxes[i].canvas.height);
					context.globalCompositeOperation = 'source-over'

					if(!image_to_draw){
						context.drawImage(grid.grid_details.boxes[i].loaded_attached_frame,0, 0, grid.grid_details.boxes[i].canvas.width, grid.grid_details.boxes[i].canvas.height);
						if(grid.grid_details.boxes[i].color){
							context.globalCompositeOperation = 'source-in'
							context.fillStyle = grid.grid_details.boxes[i].color
							context.fillRect(0, 0, grid.grid_details.boxes[i].canvas.width, grid.grid_details.boxes[i].canvas.height);
							context.globalCompositeOperation = 'source-over'
						}
					}
				}

				var context = grid.canvas.getContext('2d')

				context.drawImage(
					grid.grid_details.boxes[i].canvas,
					scope.convertCmToPixel(grid.grid_details.boxes[i].local_vertices[0].x),scope.convertCmToPixel(grid.grid_details.boxes[i].local_vertices[0].y),
					scope.convertCmToPixel(grid.grid_details.boxes[i].width*grid.width/100),scope.convertCmToPixel(grid.grid_details.boxes[i].height*grid.height/100)
				)
			}
		}

		var context = scope.canvas.getContext('2d')
		var context_outer = scope.canvas_outer.getContext('2d')
			
		var oldAlpha = context.globalAlpha;
		context.globalAlpha = grid.opacity;
		context_outer.globalAlpha = grid.opacity;
		
		context.save();
		context.translate( scope.convertX(grid.position.x + (grid.width/2)),scope.convertY(grid.position.y + (grid.height/2)))
		context.rotate(grid.rotation);

		context_outer.save();
		context_outer.translate( scope.convertXOuter(grid.position.x + (grid.width/2)),scope.convertYOuter(grid.position.y + (grid.height/2)))
		context_outer.rotate(grid.rotation);

		for (var i = 0; i < grid.grid_details.boxes.length; i++) {
			var bx = grid.grid_details.boxes[i];
			if(bx.image && bx.image.canvas_crop && scope.mode == 'crop' && scope.activeCropImage == bx.image){
				context.drawImage(bx.image.canvas_crop,-scope.convertCmToPixel((grid.width/2) - (bx.position.x*grid.width/100) -  bx.image.image_details.contentDisplacement.x),-scope.convertCmToPixel((grid.height/2) - (bx.position.y*grid.height/100) -  bx.image.image_details.contentDisplacement.y), scope.convertCmToPixel(bx.image.image_details.image_width), scope.convertCmToPixel(bx.image.image_details.image_height));
				context_outer.drawImage(bx.image.canvas_crop,-scope.convertCmToPixel((grid.width/2) - (bx.position.x*grid.width/100) -  bx.image.image_details.contentDisplacement.x),-scope.convertCmToPixel((grid.height/2) - (bx.position.y*grid.height/100) -  bx.image.image_details.contentDisplacement.y), scope.convertCmToPixel(bx.image.image_details.image_width), scope.convertCmToPixel(bx.image.image_details.image_height));
			}
		}

		if(grid.canvas){
			context.drawImage(grid.canvas,-scope.convertCmToPixel((grid.width)/2),-scope.convertCmToPixel((grid.height)/2), scope.convertCmToPixel(grid.width), scope.convertCmToPixel(grid.height));
		}
		context.restore();
		context_outer.restore();

		context.globalAlpha = oldAlpha;
		context_outer.globalAlpha = oldAlpha;

		var grid_selected = (design.selection && grid == design.selection.object)
		var grid_hovered = (design.activeElement && grid == design.activeElement.object)

		if(grid_selected){
			drawSelectionBox(grid,grid.locked)
		}else if(grid_hovered){
			drawSelectionBox(grid,true)
		}

		grid.unset_redraw()
	}

	function drawImage(image){
		var image_raw

		var image_cache_id = image.image_cache_id()
		var loadable = image.image_details.id_unsplash||image.image_details.id_pixlr||image.image_details.id_123rf||image.image_details.resource_id||image.image_details.src

		if(loadable){
			if(editor.loaded_images[image_cache_id]){
				image.loader_image = null;
				image_raw = editor.loaded_images[image_cache_id]
				if(image.needs_redraw){
					continueDrawingImage(image,image_raw)
				}
			}else if(!editor.loading_images[image_cache_id]){
				editor.loading_images[image_cache_id] = true
				var load_promise = scope.loadImage(image);
				editor.resource_promise_array.push(load_promise);
				load_promise.then(function(image_raw){
					image.loader_image = null;
					image.set_redraw()
					scope.needs_redraw = true;
				})
			}
		}

		var image_special_type
		if(image.loader_image){
			image_special_type = 'loader'
			continueDrawingImage(image,image.loader_image,image_special_type)
		}

		if(editor.drag_details && editor.drag_details.replace_feedback && editor.drag_details.replace_feedback.obj == image && editor.drag_details.replace_feedback.replace_image){
			image_special_type = 'replace'
			continueDrawingImage(image,editor.drag_details.replace_feedback.replace_image,image_special_type)
		}

		function continueDrawingImage(image,image_raw,image_special_type){
			if(!image.canvas){
				image.canvas = document.createElement('canvas');
				// image.canvas = new OffscreenCanvas(256,256);
			}

			image.canvas.width = Math.ceil(scope.convertCmToPixel(image.width));
			image.canvas.height = Math.ceil(scope.convertCmToPixel(image.height));

			var context = image.canvas.getContext('2d');
			if(image_special_type == 'loader'){
				context.filter = 'blur(4px)';
			}else if(image.image_details.filter){
				context.filter= 'url(#'+image.image_details.filter.id+')'
			}else{
				context.filter = 'none'
			}

			context.clearRect(0, 0, image.canvas.width, image.canvas.height);

			if(image.image_details.image_needs_autoset){
				var image_width = image_raw.width
				var image_height = image_raw.height

				var box_width = image.width
				var box_height = image.height

				var pos_x; var pos_y;var draw_width;var draw_height
				if((image_width/image_height)>(box_width/box_height)){
					draw_height = box_height
					draw_width = draw_height*(image_width/image_height)
					pos_y = 0
					pos_x = -(draw_width - box_width)/2
				}else{
					draw_width = box_width
					draw_height = draw_width*(image_height/image_width)
					pos_x = 0
					pos_y = -(draw_height - box_height)/2;
				}


				image.image_details.contentDisplacement.x = pos_x
                image.image_details.contentDisplacement.y = pos_y

                image.image_details.image_width = draw_width
                image.image_details.image_height = draw_height
				image.image_details.image_needs_autoset = false
				editor.addUndoChange()
			}

			if(image.image_details.flip_horizontal!=undefined && image.image_details.flip_vertical!=undefined){
				var scale_x = Number(image.image_details.flip_horizontal)
				var scale_y = Number(image.image_details.flip_vertical)
			}else{
				var scale_x = 1
				var scale_y = 1
			}
			
			if(image_special_type == 'replace'){
				var image_width = image_raw.width
				var image_height = image_raw.height

				var box_width = image.width
				var box_height = image.height

				var pos_x; var pos_y;var draw_width;var draw_height
				if((image_width/image_height)>(box_width/box_height)){
					draw_height = box_height
					draw_width = draw_height*(image_width/image_height)
					pos_y = 0
					pos_x = -(draw_width - box_width)/2
				}else{
					draw_width = box_width
					draw_height = draw_width*(image_height/image_width)
					pos_x = 0
					pos_y = -(draw_height - box_height)/2;
				}

				var pos_x = scope.convertCmToPixel(pos_x)
				var draw_width = scope.convertCmToPixel(draw_width)

				var pos_y = scope.convertCmToPixel(pos_y)
				var draw_height = scope.convertCmToPixel(draw_height)
			}else{
				var pos_x = scope.convertCmToPixel(image.image_details.contentDisplacement.x)
				var draw_width = scope.convertCmToPixel(image.image_details.image_width)

				var pos_y = scope.convertCmToPixel(image.image_details.contentDisplacement.y)
				var draw_height = scope.convertCmToPixel(image.image_details.image_height)
			}

			if(scale_x == -1){
				pos_x = -(draw_width + pos_x)
			}
			if(scale_y == -1){
				pos_y = -(draw_height + pos_y)
			}

			context.save()
			context.scale(scale_x, scale_y);
			context.drawImage(image_raw,pos_x,pos_y,draw_width,draw_height);
			context.restore()

			if(image_special_type != 'loader' && image_special_type != 'replace'){
				applyImageFilter(image.canvas,image.filter);
			}

			if(scope.mode == 'crop' && scope.activeCropImage == image){
				if(!image.canvas_crop){
					image.canvas_crop = document.createElement('canvas');
					// image.canvas_crop = new OffscreenCanvas(256,256);
				}

				image.canvas_crop.width = Math.ceil(draw_width);
				image.canvas_crop.height = Math.ceil(draw_height);

				var context = image.canvas_crop.getContext('2d');
				context.globalAlpha = 0.5
				if(image.image_details.filter){
					context.filter= 'url(#'+image.image_details.filter.id+')'
				}
				context.clearRect(0, 0, image.canvas_crop.width, image.canvas_crop.height);
				if(image.image_details.flip_horizontal!=undefined && image.image_details.flip_vertical!=undefined){
					var scale_x = Number(image.image_details.flip_horizontal)
					var scale_y = Number(image.image_details.flip_vertical)
				}else{
					var scale_x = 1
					var scale_y = 1
				}
				
				pos_x = 0
				if(scale_x == -1){
					pos_x = -(draw_width + pos_x)
				}

				pos_y = 0
				if(scale_y == -1){
					pos_y = -(draw_height + pos_y)
				}

				context.save()

				context.scale(scale_x, scale_y);
				context.drawImage(image_raw,pos_x,pos_y,image.canvas_crop.width,image.canvas_crop.height);
				context.globalAlpha = 1;
				context.restore()

				applyImageFilter(image.canvas_crop,image.filter)
			}
		}

		if(image.canvas && !image.hover_attach){
			var context = scope.canvas.getContext('2d')
			var context_outer = scope.canvas_outer.getContext('2d')
			
			var oldAlpha = context.globalAlpha;
			context.globalAlpha = image.opacity;
			context_outer.globalAlpha = image.opacity;
			
			context.save();
			context.translate( scope.convertX(image.position.x + (image.width/2)),scope.convertY(image.position.y + (image.height/2)))
			context.rotate(image.rotation);

			context_outer.save();
			context_outer.translate( scope.convertXOuter(image.position.x + (image.width/2)),scope.convertYOuter(image.position.y + (image.height/2)))
			context_outer.rotate(image.rotation);

			if(image.canvas_crop && scope.mode == 'crop' && scope.activeCropImage == image){
				context.drawImage(image.canvas_crop,-scope.convertCmToPixel((image.width/2) - image.image_details.contentDisplacement.x),-scope.convertCmToPixel((image.height/2) - image.image_details.contentDisplacement.y), scope.convertCmToPixel(image.image_details.image_width), scope.convertCmToPixel(image.image_details.image_height));
				context_outer.drawImage(image.canvas_crop,-scope.convertCmToPixel((image.width/2) - image.image_details.contentDisplacement.x),-scope.convertCmToPixel((image.height/2) - image.image_details.contentDisplacement.y), scope.convertCmToPixel(image.image_details.image_width), scope.convertCmToPixel(image.image_details.image_height));
			}
			context.drawImage(image.canvas,-scope.convertCmToPixel((image.width)/2),-scope.convertCmToPixel((image.height)/2), scope.convertCmToPixel(image.width), scope.convertCmToPixel(image.height));
			context.restore();
			context_outer.restore();

			context.globalAlpha = oldAlpha;
			context_outer.globalAlpha = oldAlpha;

			var image_selected = (design.selection && image == design.selection.object)
			var image_hovered = (design.activeElement && image == design.activeElement.object)

			if(image_selected){
				drawSelectionBox(image,image.locked)
			}else if(image_hovered){
				drawSelectionBox(image,true)
			}

			if(image_special_type != 'replace'){
				image.unset_redraw()
			}
		}
	}

	function drawText(text){
		var pad_percentage = 25;

		if(text.needs_redraw){
			drawTextCore(text,pad_percentage);
		}

		var context = scope.canvas.getContext('2d')
			
		var oldAlpha = context.globalAlpha;
		context.globalAlpha = text.opacity;
		
		context.save();
		context.translate( scope.convertX(text.position.x + (text.width/2)),scope.convertY(text.position.y + (text.height/2)))
		context.rotate(text.rotation);

		if(text.canvas.width && text.canvas.height){
			var expected_width = scope.convertCmToPixel(text.width);
			var expected_height = scope.convertCmToPixel(text.height);
			context.drawImage(text.canvas,-((0.5 + (pad_percentage/100))*expected_width),-((0.5 + (pad_percentage/100))*expected_height), (1 + (pad_percentage/100))*expected_width, (1 + (pad_percentage/100))*expected_height);
		}

		context.restore();

		context.globalAlpha = oldAlpha;

		if(text.loader_image){
			context.filter = 'blur(4px)'
			context.drawImage(text.loader_image,scope.convertX(text.position.x),scope.convertY(text.position.y),scope.convertCmToPixel(text.width),scope.convertCmToPixel(text.height));
		}else{
			context.filter = 'none'
		}


		var text_selected = (design.selection && text == design.selection.object)
		var text_hovered = (design.activeElement && text == design.activeElement.object)

		if(text_selected){
			drawSelectionBox(text,text.locked)
		}else if(text_hovered){
			drawSelectionBox(text,true)	
		}
	}

	this.drawText = drawText

	this.actualWidth = function(t,context){
		var metrics = context.measureText(t)
		// if(metrics.actualBoundingBoxLeft && metrics.actualBoundingBoxRight){
		// 	return metrics.actualBoundingBoxRight - metrics.actualBoundingBoxLeft
		// }else{
			return metrics.width
		// }
	}

	this.actualHeight = function(t,context,text_object){
		var metrics = context.measureText(t)
		if(metrics.actualBoundingBoxAscent && metrics.actualBoundingBoxDescent){
			return metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
		}else{
			return design.convertCmToPixel(1.2*Number(text_object.text_details.fontSize))
		}
	}

	this.actualWidthLetter = function(t,context){
		var metrics = context.measureText(t)
		if(metrics.actualBoundingBoxLeft && metrics.actualBoundingBoxRight){
			return metrics.actualBoundingBoxRight + metrics.actualBoundingBoxLeft
		}else{
			return metrics.width
		}
	}

	function drawTextCore(text,pad_percentage){
		if(!text.canvas){
			text.canvas = document.createElement('canvas');
			// text.canvas = new OffscreenCanvas(256, 256);
		}

		var expected_width = Math.ceil(scope.convertCmToPixel(text.width));
		var expected_height = Math.ceil(scope.convertCmToPixel(text.height));

		text.canvas.width = (1 + (pad_percentage/100))*expected_width;
		text.canvas.height = (1 + (pad_percentage/100))*expected_height;

		var pad_dx = (pad_percentage/100)*expected_width;
		var pad_dy = (pad_percentage/100)*expected_height;

		var context = text.canvas.getContext('2d')

		context.clearRect(0, 0, text.canvas.width, text.canvas.height);
		
		var text_details = text.text_details;
		if(text_details.font && text_details.font_src && !editor.font_checking_completed[text_details.font]){
			editor.font_checking_completed[text_details.font] = true
			if(checkFontExists(text_details.font)){
				if(!checkFontLoad(text_details.font) && !editor.loading_fonts.find(function(o){return text_details.font==o})){
					var font_promise = checkFontExists(text_details.font).loaded
					editor.resource_promise_array.push(font_promise);
					editor.loading_fonts.push(text_details.font);
					font_promise.then(function(){
						for(var j=0;j<editor.pages.length;j++){
							for (var i = 0; i < editor.pages[j].objects.length; i++) {
								if(editor.pages[j].objects[i].type == 'text' && editor.pages[j].objects[i].text_details.font == text_details.font){
									delete editor.pages[j].objects[i].loader_image
									editor.pages[j].objects[i].set_redraw()
								}
							}
						}
						editor.needs_redraw = true
					}).catch(function(err) {
						console.log(err);
					})

					return
				}else{
					for(var t=0;t<editor.pages.length;t++){
						for (var u = 0; u < editor.pages[t].objects.length; u++) {
							if(editor.pages[t].objects[u].type == 'text' && editor.pages[t].objects[u].text_details.font == text_details.font){
								delete editor.pages[t].objects[u].loader_image
							}
						}
					}
				}
			}else{
				var new_font = new FontFace(text_details.font, 'url("'+server_path+text_details.font_src+'")');
				document.fonts.add(new_font);
				var font_promise = new_font.load()
				editor.resource_promise_array.push(font_promise);
				font_promise.then(function(){
					for(var j=0;j<editor.pages.length;j++){
						for (var i = 0; i < editor.pages[j].objects.length; i++) {
							if(editor.pages[j].objects[i].type == 'text' && editor.pages[j].objects[i].text_details.font == text_details.font){
								delete editor.pages[j].objects[i].loader_image
								editor.pages[j].objects[i].set_redraw()
							}
						}
					}
					editor.needs_redraw = true
				}).catch(function(err) {
					console.log(err);
				})

				return
			}
		}else{
			for(var t=0;t<editor.pages.length;t++){
				for (var u = 0; u < editor.pages[t].objects.length; u++) {
					if(editor.pages[t].objects[u].type == 'text' && editor.pages[t].objects[u].text_details.font == text_details.font){
						delete editor.pages[t].objects[u].loader_image
					}
				}
			}
		}

		var oldAlpha = context.globalAlpha
		context.globalAlpha = text.opacity

		var fontSize = (Number(text_details.fontSize)*pixelsPerCm)+'px'
		var fontSizeNumber = (Number(text_details.fontSize)*pixelsPerCm);
		var lineheight = 1.2*Number(text_details.fontSize)*pixelsPerCm

		var fontFamily = text_details.font
		if(!fontFamily){
			fontFamily = 'Arial'
		}

		if(text_details.bold || text_details.italic){
			var bold = text_details.bold?'bold ':''
			var italic = text_details.italic?'italic ':''
			context.font = italic + bold + fontSize + ' "' + fontFamily + '"';
		}else{
			context.font = 'normal ' + fontSize + ' "' + fontFamily + '"';
		}


		// context.textAlign = text_details.textAlign;
		context.textBaseline = "middle";
		context.save();
		
		context.fillStyle = text_details.fontColor;

		var available_width = scope.convertCmToPixel(text.width);

		var words = text_details.text.split('');
		var lineTest = line = (words.length>0?words[0]:''); var lines = []
		if(line == '\n'){
			lines.push(line);
			if(words.length == 1){
				lines.push('');
			}
			line = ''
		}
		for (var i = 1, len = words.length; i < len; i++) {
			if(words[i] == '\n'){
				lines.push(line);
				if(i==words.length-1){
					lines.push('');
				}
				line = ''
			}else{
				lineTest = line + words[i];

				if ((scope.actualWidth(lineTest,context) + ((lineTest.length-1)*scope.convertCmToPixel(text_details.letterSpacing))) > available_width/* && words[i] != ' '*/) {
					var reverse_line = line.split("").reverse().join("")
					var after_space = reverse_line.split(' ')[0].split("").reverse().join("")
					var before_space = reverse_line.substring(after_space.length+1).split("").reverse().join("")
					if(before_space == ''){
						before_space = line;
						after_space = ''
					}else{
						before_space += ' '
					}

					lines.push(before_space)
					line = after_space + words[i];
				} else {
					line = lineTest;
				}
			}
		}

		// var w_test = 0;
		// var a = text_details.text
		// for (var i = 0; i < a.length; i++) {
		// 	w_test += scope.actualWidth(a[i],context);
		// }
		// var w_initial = scope.actualWidth(a,context);

		// console.log(w_test,w_initial)

		// var w_test = 0;
		// var a = text_details.text
		// for (var i = 0; i < a.length; i++) {
		// 	w_test += context.measureText(a[i]).width;
		// }
		// var w_initial = context.measureText(a).width;

		// console.log(w_test,w_initial)

		if (line.length > 0) {
			lines.push(line.trim());
		}

		text.lines = lines

		var line_heights = []

		// var lineheight = scope.actualHeight('G',context)

		var y_correction = 0;
		for(var i = 0; i < lines.length; i++){
			var initial_pos_x
			if(text_details.textAlign == 'left'){
				var initial_pos_x = 0
			}else if(text_details.textAlign == 'right'){
				var initial_pos_x = (available_width - (scope.actualWidth(lines[i],context) + ((lines[i].length)*scope.convertCmToPixel(text_details.letterSpacing)) ))
			}else{
				var initial_pos_x = (available_width - (scope.actualWidth(lines[i],context) + ((lines[i].length)*scope.convertCmToPixel(text_details.letterSpacing)) ))/2
			}

			var posY = i==0?0:i*line_heights[line_heights.length-1];
			// if(!(Number(text_details.lineHeight*pixelsPerCm)<0 && i==0)){
				posY += (i)* Number(text_details.lineHeight*pixelsPerCm);
			// }

			line_heights.push(lineheight);

			posY += (line_heights[line_heights.length-1]/2);

			// if(posY < (line_heights[line_heights.length-1]/2)){
			// 	y_correction = (line_heights[line_heights.length-1]/2) - posY
			// }

			posY += y_correction

			var split = lines[i].split('');
			for(var j=0;j<split.length;j++){
				var posX = initial_pos_x
				if(j!=0){
					posX += (scope.actualWidth(lines[i].substr(0,j),context) + (lines[i].substr(0,j).length*scope.convertCmToPixel(Number(text_details.letterSpacing))) );
				}

				// if(j!=0){
				// 	posX += (scope.actualWidth(split[j-1],context) + scope.convertCmToPixel(Number(text_details.letterSpacing)));
				// }

				
		    	if(text_details.shadow){
		    		for(var s=0;s<text_details.shadows.length;s++){
		    			context.shadowOffsetX = text_details.shadows[s].r*Math.cos(text_details.shadows[s].theta*Math.PI/180)*(fontSizeNumber/10);
				      	context.shadowOffsetY = text_details.shadows[s].r*Math.sin(text_details.shadows[s].theta*Math.PI/180)*(fontSizeNumber/10);
			      		context.shadowBlur = text_details.shadows[s].blur;
			      		context.shadowColor = text_details.shadows[s].shadowColor
			      		context.globalAlpha = text_details.shadows[s].opacity;
						context.fillText(split[j], posX + pad_dx,posY + pad_dy);
						context.globalAlpha = 1;
		    		}
		    	}

		    	if(text_details.glow){
					context.shadowOffsetX = 0;
			      	context.shadowOffsetY = fontSizeNumber/30;
		      		context.shadowBlur = 0.5*(fontSizeNumber/2) + ((text_details.glowIntensity - 50)/100)*(fontSizeNumber/2) ;
		      		context.shadowColor = text_details.glowColor;
		      		context.globalAlpha = text_details.glowOpacity;
					context.fillText(split[j], posX + pad_dx,posY + pad_dy);
					context.globalAlpha = 1;
		    	}

		    	context.shadowOffsetX = 0;
		    	context.shadowOffsetY = 0;
		    	context.shadowBlur = 0;

				context.fillText(split[j], posX + pad_dx,posY + pad_dy);
				if(text_details.stroke){
				    context.lineWidth = text_details.strokeSize * pixelsPerCm;
					context.strokeStyle = text_details.strokeColor;
					context.shadowOffsetX = 0;
			      	context.shadowOffsetY = 0;
		      		context.shadowBlur = 0;
				    context.strokeText(split[j], posX + pad_dx,posY + pad_dy );
				}
			}
		}

		var oldHeight = text.height

		var h, lh;
		if(lines.length>=1){
			h = line_heights.reduce(function(o,v){return o+v})
			lh = lines.length* Number(text_details.lineHeight*pixelsPerCm)
		}else{
			h = lineheight
			lh = 0
		}

		if(lh>0){
			lh += (0.3*(lh/lines.length))
		}

		if(h>0){
			h += (0.3*(h/lines.length))
		}
		
		text.height = scope.convertPixelToCm(h+lh)

		context.restore();

		context.globalAlpha = oldAlpha

		text.unset_redraw()

		if(Math.abs(oldHeight - text.height)>0.001){
			var gr = text.getGroup()
			if(gr){
				gr.setGroupFromObjects(gr.group_details.object_data.map(function(o){
					return o.object
				}),true)
				gr.set_redraw()
				for (var i = 0; i < gr.group_details.object_data.length; i++) {
					if(gr.group_details.object_data[i].object.type == 'text'){
						scope.updateTextAreaStyling(gr.group_details.object_data[i].object)
					}
				}
			}else{
				scope.updateTextAreaStyling(text)
				text.set_redraw()
			}

			if(Math.abs(oldHeight - text.height)>0.1){
				text.canvas.width = Math.ceil(scope.convertCmToPixel(text.width));
				text.canvas.height = Math.ceil(scope.convertCmToPixel(text.height));
			}
			design.needs_redraw = true;
		}
	}

	this.export = function(quality){
		if(quality == undefined){
			quality = 'high'
		}

		scope.dont_draw_selection_box = true
		scope.dont_draw_snapping_lines = true
		if(quality == 'high' || quality == 'high_jpg'){
			var old_width = scope.canvas.width
			var old_height = scope.canvas.height
			var old_dom_width = scope.canvas.style.width
			var old_dom_height = scope.canvas.style.height
			scope.canvas.style.width = editor.get_width()+'px'
			scope.canvas.style.height = (editor.get_height()/editor.get_width())*editor.get_width() + 'px'
			scope.canvas.width = editor.canvas_scale*editor.get_width()
			scope.canvas.height = editor.canvas_scale*(editor.get_height()/editor.get_width())*editor.get_width()

			scope.setView(
				{x:editor.get_width()/2,y:editor.get_height()/2},
				editor.get_width(),editor.get_height(),0
			)
		}
		scope.draw();

		delete scope.dont_draw_selection_box
		delete scope.dont_draw_snapping_lines

		var output
		if(quality == 'high' || quality == 'high_jpg'){
			if(quality == 'high_jpg'){
				output = scope.canvas.toDataURL("image/jpeg",1);
			}else{
				output = scope.canvas.toDataURL();
			}
			scope.canvas.style.width = old_dom_width
			scope.canvas.style.height = old_dom_height
			scope.canvas.width = old_width
			scope.canvas.height = old_height

			scope.setView(
				{x:editor.get_width()/2,y:editor.get_height()/2},
				editor.get_width(),editor.get_height(),0
			)

		}else if(quality == 'low'){
			output = scope.canvas.toDataURL("image/jpeg",0.9)
		}
		scope.draw();
        return output
	}


	this.convertXPixel = function(x) {
		return (scope.originX * cmPerPixel) + (x/pixelsPerCm);
	}

	this.convertX = function(x) {
		return (x - scope.originX * cmPerPixel) * pixelsPerCm;
	}

	this.convertYPixel = function(y) {
		return (scope.originY * cmPerPixel) + (y/pixelsPerCm);
	}

	this.convertY = function(y) {
		return (y - scope.originY * cmPerPixel) * pixelsPerCm;
	}

	this.convertXOuter = function(x) {
		return (x - scope.originXOuter * cmPerPixel) * pixelsPerCm;
	}

	this.convertYOuter = function(y) {
		return (y - scope.originYOuter * cmPerPixel) * pixelsPerCm;
	}

	this.convertCmToPixel = function(a){
		return a*pixelsPerCm;
	}

	this.convertPixelToCm = function(a){
		return a*cmPerPixel;
	}

	this.convertCmToPixelOuter = function(a){
		return a*pixelsPerCm;
	}

	this.convertPixelToCmOuter = function(a){
		return a*cmPerPixel;
	}

	this.fillImageCropGaps = function(object){
		if(scope.cropFillGapChanges[object.id]){
			object.image_details.image_width -= scope.cropFillGapChanges[object.id].image_width
			object.image_details.image_height -= scope.cropFillGapChanges[object.id].image_height
			object.image_details.contentDisplacement.x -= scope.cropFillGapChanges[object.id].content_displacement_x
			object.image_details.contentDisplacement.y -= scope.cropFillGapChanges[object.id].content_displacement_y
		}

		var old_image_width = object.image_details.image_width;
		var old_image_height = object.image_details.image_height;
		var old_content_displacement_x = object.image_details.contentDisplacement.x;
		var old_content_displacement_y = object.image_details.contentDisplacement.y;

		if(object.image_details.contentDisplacement.x > 0){
			var gap = object.image_details.contentDisplacement.x;
			object.image_details.contentDisplacement.x = 0;
			var aspect = object.image_details.image_width/object.image_details.image_height
			object.image_details.image_width = object.width;
			object.image_details.image_height = object.image_details.image_width/aspect;
			object.image_details.contentDisplacement.y -= (object.image_details.image_height - old_image_height)/2
		}

		if(object.image_details.contentDisplacement.y > 0){
			var gap = object.image_details.contentDisplacement.y;
			object.image_details.contentDisplacement.y = 0;
			var aspect = object.image_details.image_width/object.image_details.image_height
			object.image_details.image_height = object.height;
			object.image_details.image_width = object.image_details.image_height*aspect;
			object.image_details.contentDisplacement.x -= (object.image_details.image_width - old_image_width)/2
		}

		if(object.image_details.contentDisplacement.x + object.image_details.image_width < object.width){
			var gap = object.width - (object.image_details.contentDisplacement.x + object.image_details.image_width);
			var aspect = object.image_details.image_width/object.image_details.image_height
			object.image_details.image_width += gap;
			object.image_details.image_height = object.image_details.image_width/aspect;
			object.image_details.contentDisplacement.y -= (object.image_details.image_height - old_image_height)/2
		}

		if(object.image_details.contentDisplacement.y + object.image_details.image_height < object.height){
			var gap = object.height - (object.image_details.contentDisplacement.y + object.image_details.image_height);
			var aspect = object.image_details.image_width/object.image_details.image_height
			object.image_details.image_height += gap;
			object.image_details.image_width = object.image_details.image_height*aspect;
			object.image_details.contentDisplacement.x -= (object.image_details.image_width - old_image_width)/2
		}

		if(!scope.cropFillGapChanges[object.id]){
			scope.cropFillGapChanges[object.id] = {
				image_width:0,
				image_height:0,
				content_displacement_x:0,
				content_displacement_y:0,
			}
		}

		scope.cropFillGapChanges[object.id].image_width = object.image_details.image_width - old_image_width
		scope.cropFillGapChanges[object.id].image_height = object.image_details.image_height - old_image_height
		scope.cropFillGapChanges[object.id].content_displacement_x = object.image_details.contentDisplacement.x - old_content_displacement_x
		scope.cropFillGapChanges[object.id].content_displacement_y = object.image_details.contentDisplacement.y - old_content_displacement_y
	}


	this.setView = function(center,width,height,offsetPercent){
		if(offsetPercent == undefined){
			offsetPercent = 0;
		}
		var inner_width = scope.canvas.width;
		var inner_height = scope.canvas.height;
		
		var centerX = inner_width / 2;
		var centerY = inner_height / 2;

		var widthRatio = inner_width / width; 
		var heightRatio = inner_height / height;

		if(widthRatio<heightRatio){
			pixelsPerCm = inner_width/(width*0.01*(100+offsetPercent));
			scope.updateScale();
		}else {
			pixelsPerCm = inner_height/(height*0.01*(100+offsetPercent));
			scope.updateScale();
		}
		
		scope.originX = (center.x) * pixelsPerCm - centerX;
		scope.originY = (center.y) * pixelsPerCm - centerY;


		var time_temp_setview = setTimeout(function(){
			if(document.getElementById('design_doms_parent')){
			    var top = scope.canvas.offsetTop + 10
			    var left = scope.canvas.offsetLeft

			    scope.originXOuter = scope.originX - (left*editor.canvas_scale)
			    scope.originYOuter = scope.originY - (top*editor.canvas_scale)
			}
			clearTimeout(time_temp_setview);
		},0)

		scope.needs_redraw = true;
		for (var i = 0; i < scope.objects.length; i++) {
			scope.objects[i].set_redraw();
		}
	}

	this.updateScale = function(){
		cmPerPixel = 1/pixelsPerCm
	}

	this.handleWindowResize = function() {
		var base_width
		var available_height = Math.floor(window.innerHeight)
		if(editor.page_zoom.constructor.name != 'Number' && editor.page_zoom != 'fit' && editor.page_zoom != 'fill'){
			editor.page_zoom = 'fit'
		}


		if(!editor.base_width){
			if(scope.dom.parentElement){
				if(editor.page_zoom == 'fit' || editor.page_zoom == 'fill'){
					base_width = Math.floor(scope.dom.parentElement.clientWidth*0.95)
					if(base_width == 0){return}
					if(editor.page_zoom == 'fit' && base_width*(editor.get_height()/editor.get_width()) > 0.8*available_height){
						base_width = 0.8*available_height*(editor.get_width()/editor.get_height())
					}
				}else if(editor.page_zoom.constructor.name == 'Number'){
					base_width = (editor.page_zoom/100)*Math.floor(scope.dom.parentElement.clientWidth*1)
					if(base_width == 0){return}
				}
			}else{
				base_width = Math.max(editor.get_width(),editor.get_height());
			}
		}else{
			base_width = editor.base_width;
		}

		scope.canvas.style.width = base_width+'px'
		scope.canvas.style.height = (editor.get_height()/editor.get_width())*base_width + 'px'
		scope.canvas.width = editor.canvas_scale*base_width
		scope.canvas.height = editor.canvas_scale*(editor.get_height()/editor.get_width())*base_width

		if(scope.canvas.parentElement && scope.canvas.parentElement.children[0] && scope.canvas.parentElement.children[0]!=scope.canvas){
			scope.canvas.parentElement.children[0].style.width = base_width+'px'
		}

		if(scope.dom){
			scope.canvas_outer.style.width = (scope.dom.clientWidth)+'px'
			scope.canvas_outer.style.height = (scope.dom.clientHeight+20)+'px'

			scope.canvas_outer.width = editor.canvas_scale*(scope.dom.clientWidth)
			scope.canvas_outer.height = editor.canvas_scale*(scope.dom.clientHeight+20)
		}

		scope.setView(
			{x:editor.get_width()/2,y:editor.get_height()/2},
			editor.get_width(),editor.get_height(),0
		)

		scope.needs_redraw = true;
	}

	init(page_file);
}

var designObject = function(design){
	var object = this;
	this.master = design;
	this.design = design;

	object.id = utils.uuidv4()
	object.type = 'text';
	object.sub_type = '';
	object.layer_index = 0;
	object.position = {x:200,y:200}
	object.width = 300;
	object.height = 300;
	object.rotation = 0;
	object.opacity = 1;
	object.locked = false;
	object.labels = {
		text:'',
		image:'',
		colors: []
	}

	object.user_labels = {
		text:'',
		image:'',
		colors: []
	}

	object.text_details = {
		text: 'Enter your text here',
		font_src: '',
		bold: false,
		italic: false,
		font: '',
		fontSize: 30,
		fontColor: '#000000',
		textAlign: 'left',
		rotation: 0,
		letterSpacing: 0,
		lineHeight: 0,
		stroke: false,
		strokeSize: 2,
		strokeColor: '#0000ff',
		shadow: false,
		glow: false,
		glowColor: '#aaaaaa',
		glowIntensity: 50,
		glowOpacity: 1,
		shadows: [{
			shadowColor: '#aaaaaa',	
			r: 2,
			theta: 116,
			blur: 2,
			opacity: 1
		}]
	}

	object.image_details = {
		src: '',
		id_123rf: '',
		id_pixlr: '',
		id_unsplash: '',
		resource_id: '',
		flip_horizontal: 1,
		flip_vertical: 1,
		image_width: 300,
		image_height: 300,
		svg_colors: [],
		contentDisplacement: {x:0,y:0},
		filter: null,
		image_needs_autoset: false,
		image_contain: null
	}

	object.mockup_details = {
		id:null,
		inputs: null
	}

	object.grid_details = {
		boxes:[]
	}

	object.group_details = {
		object_data: []
	}

	object.filter = {
		brightness: 0,
		contrast:0,
		saturation:0,
		tint:0,
		blur: 0,
		vignette: 0
	}

	object.bgremoval = {
        enabled: false,
        feather: 0,
        offset: 0,
        sharpness: 0,
        crf: 0,
        matting: 0,
        cache:""
    }

	this.copy = function(){
		if(object.type == 'group'){
			var copied_group = object.save();
			copied_group.id = utils.uuidv4();
			var copied_objects = []
			var copy_map = {}

			for (var i = 0; i < object.group_details.object_data.length; i++) {
				var copied_object = object.group_details.object_data[i].object.copy();
				copied_objects.push(copied_object);
				copied_group.group_details.object_data[i].object = copied_object.id;
			}

			return {
				group: copied_group,
				objects: copied_objects
			}
		}else{
			var copied_object = object.save();
			copied_object.id = utils.uuidv4();
			try{
				if(copied_object.type == 'grid'){
					for (var i = 0; i < copied_object.grid_details.boxes.length; i++) {
						if(copied_object.grid_details.boxes[i].frame){
							copied_object.grid_details.boxes[i].frame.id = utils.uuidv4()
						}

						if(copied_object.grid_details.boxes[i].image){
							copied_object.grid_details.boxes[i].image.id = utils.uuidv4()
						}
					}

				}
			}catch(err){
				console.log(err)
			}
			
			return copied_object
		}

	}

	this.getUnrotatedVertices = function(){
		var unrotated_vertices = [
			{x:object.position.x,y:object.position.y},
			{x:object.position.x + object.width,y:object.position.y},
			{x:object.position.x + object.width,y:object.position.y + object.height},
			{x:object.position.x,y:object.position.y + object.height}
		]

		return unrotated_vertices

	}

	this.getUnrotatedImageCropVertices = function(){
		var pos = {x: object.position.x + object.image_details.contentDisplacement.x,y: object.position.y + object.image_details.contentDisplacement.y}
		
		var unrotated_vertices = [
			{x:pos.x,y:pos.y},
			{x:pos.x + object.image_details.image_width,y:pos.y},
			{x:pos.x + object.image_details.image_width,y:pos.y + object.image_details.image_height},
			{x:pos.x,y:pos.y + object.image_details.image_height}
		]

		return unrotated_vertices

	}

	this.updateColors = function(){
		if(object.type == 'image' && object.sub_type == 'icon'){
			if(object.svgXml){
				return object.applySvgColors().then(function(image_raw){
					design.master.loaded_images[object.image_cache_id()] = image_raw
					object.set_redraw()
					design.needs_redraw = true;
					return Promise.resolve();
				})
			}else{
				return design.loadImage(object)
			}
		}
	}

	this.set_redraw = function(){
		try{
			object.needs_redraw = true;
		
			if(object.type == 'group'){
				for (var i = 0; i < object.group_details.object_data.length; i++) {
					object.group_details.object_data[i].object.set_redraw()
				}
			}

			if(object.type == 'grid'){
				for (var i = 0; i < object.grid_details.boxes.length; i++) {
					if(object.grid_details.boxes[i].frame){
						object.grid_details.boxes[i].frame.set_redraw()
					}
					if(object.grid_details.boxes[i].image){
						object.grid_details.boxes[i].image.set_redraw()
					}
				}
			}
		}catch(err){
			console.log(err);
		}
	}

	this.unset_redraw = function(){
		object.needs_redraw = false;	
		
		if(object.type == 'group'){
			for (var i = 0; i < object.group_details.object_data.length; i++) {
				object.group_details.object_data[i].object.unset_redraw()
			}
		}

		if(object.type == 'grid'){
			for (var i = 0; i < object.grid_details.boxes.length; i++) {
				if(object.grid_details.boxes[i].frame){
					object.grid_details.boxes[i].frame.unset_redraw()
				}
				if(object.grid_details.boxes[i].image){
					object.grid_details.boxes[i].image.unset_redraw()
				}
			}
		}
	}

	this.parseFirstColor = function(str){
		var index1 = str.indexOf('"')
		var index2 = str.indexOf(';')

		if((index1 < index2 && index1 != -1) || (index2==-1 && index1!=-1)){
			var length = str.split('"')[0].length
			var color = str.split('"')[0].replace(/\s/g, '');
			return {
				length: length,
				color: color
			}
		}else if((index2 < index1 && index2 != -1) || (index1==-1 && index2!=-1)){
			var length = str.split(';')[0].length
			var color = str.split(';')[0].replace(/\s/g, '');
			return {
				length: length,
				color: color
			}
		}

		return {
			length: str.length,
			color: str
		}
	}

	this.getSvgColors = function(){
		var svgXml = object.svgXml
		// var xmlString = (new XMLSerializer).serializeToString(svgXml);
		var xmlString = svgXml;

		var fillColors = []
		var indices = getIndicesOfSubstring('fill="', xmlString)
		for (var i = 0; i < indices.length; i++) {
			var test = xmlString.substring(indices[i]+6);
			var color_test = object.parseFirstColor(test)
			if(chroma.valid(color_test.color)){
				fillColors.push({
					color: chroma(color_test.color).get('hex'),
					index: indices[i]+6
				})
			}
		}
		var indices = getIndicesOfSubstring('fill:', xmlString)
		for (var i = 0; i < indices.length; i++) {
			var test = xmlString.substring(indices[i]+5)
			var color_test = object.parseFirstColor(test)
			if(chroma.valid(color_test.color)){
				fillColors.push({
					color: chroma(color_test.color).get('hex'),
					index: indices[i]+5
				})
			}
		}

		var strokeColors = []
		var indices = getIndicesOfSubstring('stroke="', xmlString)
		for (var i = 0; i < indices.length; i++) {
			var test = xmlString.substring(indices[i]+8)
			var color_test = object.parseFirstColor(test)
			if(chroma.valid(color_test.color)){
				strokeColors.push({
					color: chroma(color_test.color).get('hex'),
					index: indices[i]+8
				})
			}
		}
		var indices = getIndicesOfSubstring('stroke:', xmlString)
		for (var i = 0; i < indices.length; i++) {
			var test = xmlString.substring(indices[i]+7)
			var color_test = object.parseFirstColor(test)
			if(chroma.valid(color_test.color)){
				strokeColors.push({
					color: chroma(color_test.color).get('hex'),
					index: indices[i]+7
				})
			}
		}

		return fillColors.concat(strokeColors)
	}

	this.applySvgColors = function(){
		return new Promise(function(resolve,reject){
			var colors = object.image_details.svg_colors
			var svgXml = object.svgXml

			var img = new Image();
			// var xmlString = (new XMLSerializer).serializeToString(svgXml);
			var xmlString = svgXml;

			var final_indices = []
			var indices = getIndicesOfSubstring('fill="', xmlString)
			for (var i = 0; i < indices.length; i++) {
				final_indices.push(indices[i]+6)
			}

			var indices = getIndicesOfSubstring('fill:', xmlString)
			for (var i = 0; i < indices.length; i++) {
				final_indices.push(indices[i]+5)
			}

			var indices = getIndicesOfSubstring('stroke="', xmlString)
			for (var i = 0; i < indices.length; i++) {
				final_indices.push(indices[i]+8)
			}

			var indices = getIndicesOfSubstring('stroke:', xmlString)
			for (var i = 0; i < indices.length; i++) {
				final_indices.push(indices[i]+7)
			}

			for (var i = 0; i < colors.length; i++) {
				var old_length = xmlString.length;
				var remaining_string = xmlString.substring(final_indices[i])
				var color_length = object.parseFirstColor(remaining_string).length;
				var color_to_apply = object.parseFirstColor(colors[i].color).color
				xmlString = xmlString.substr(0, final_indices[i]) + color_to_apply+ xmlString.substr(final_indices[i] + color_length);
				var new_length = xmlString.length;
				var diff = new_length - old_length;
				for(var j=i+1;j<final_indices.length;j++){
					final_indices[j] += diff
				}
			}
			
			img.onload = function(){
				object.set_redraw()
				resolve(img);
			}

			img.onerror = function(){
				object.set_redraw()
				console.log("could not load svg - applySvgColors");
				reject();	
			}

			var preserve_index = xmlString.indexOf('<svg')
			if(preserve_index != -1){
				preserve_index += 4
				xmlString = xmlString.substr(0, preserve_index) + ' preserveAspectRatio="none" '+ xmlString.substr(preserve_index);
			}


			var browser = findBrowser()

			if(browser == 'firefox'){
				if(xmlString.indexOf('width="')==-1){
					var svg_index = xmlString.indexOf('<svg')
					if(svg_index != -1){
						svg_index += 4
						xmlString = xmlString.substr(0, svg_index) + ' width="1px" height="1px" '+ xmlString.substr(svg_index);
					}
				}
				
			}

			if(browser == 'safari' || browser == 'firefox'){
				img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(xmlString);
			}else{
				var DOMURL = self.URL || self.webkitURL || self;
				var svg = new Blob([xmlString], {type: "image/svg+xml;charset=utf-8"});
		    	img.src = DOMURL.createObjectURL(svg);
			}
		},0)
	}

	this.getStringWidth = function(str){
		var context = design.canvas.getContext('2d')
		var fontSize = (design.convertCmToPixel(Number(object.text_details.fontSize)))+'px'
		var lineheight = 1.2*design.convertCmToPixel(Number(object.text_details.fontSize))
		var fontFamily = object.text_details.font
		if(!fontFamily){
			fontFamily = 'Arial'
		}

		if(object.text_details.bold || object.text_details.italic){
			var bold = object.text_details.bold?'bold ':''
			var italic = object.text_details.italic?'italic ':''
			context.font = italic + bold + fontSize + ' "' + fontFamily + '"';
		}else{
			context.font = 'normal ' + fontSize + ' "' + fontFamily + '"';
		}

		var w = design.convertPixelToCm(design.actualWidth(str,context))

		w += object.text_details.letterSpacing*(str.length-1)

		return w
	}

	this.exportThumbnail = function(quality,best_fit_square,offset){
		if(quality == undefined){
			quality = 'high'
		}

		if(offset==undefined){
			offset = 0
		}

		design.dont_draw_selection_box = true
		design.dont_draw_snapping_lines = true
		design.draw();

		delete design.dont_draw_selection_box
		delete design.dont_draw_snapping_lines

		var context = design.canvas.getContext('2d');
		var vertices = object.getVertices();
		var bbox = utils.get2dBoundingBox(vertices.map(function(o){
			return {x: design.convertX(o.x),y: design.convertY(o.y)}
		}))

		var width = bbox.maxX - bbox.minX
		var height = bbox.maxY - bbox.minY

		bbox.maxX += ((offset/200)*width)
		bbox.minX -= ((offset/200)*width)

		bbox.maxY += ((offset/200)*width)
		bbox.minY -= ((offset/200)*width)

		width = bbox.maxX - bbox.minX
		height = bbox.maxY - bbox.minY

		if(width>height){
			var diff = width - height;
			bbox.minY -= (diff/2)
			bbox.maxY += (diff/2)
		}else{
			var diff = height - width;
			bbox.minX -= (diff/2)
			bbox.maxX += (diff/2)
		}

		var imageData = context.getImageData(bbox.minX, bbox.minY, bbox.maxX - bbox.minX, bbox.maxY - bbox.minY);

		var canvas_temp = document.createElement('canvas');
        var context_temp = canvas_temp.getContext('2d');
        canvas_temp.width = imageData.width;
        canvas_temp.height = imageData.height;
        context_temp.putImageData(imageData, 0, 0);

		var output
		if(quality == 'high'){
			output = canvas_temp.toDataURL()
		}else if(quality == 'low'){
			output = canvas_temp.toDataURL("image/jpeg",0.9)
		}
		design.draw();
        return output
	}

	this.move = function(shiftX,shiftY,initialObject){
		object.position.x = initialObject.position.x + shiftX;
		object.position.y = initialObject.position.y + shiftY;

		var snap = design.checkSnapWithObject(object);
		object.position.x += snap.x
		object.position.y += snap.y

		if(object.type == 'group'){
			object.updateGroupObjects()
		}

		if(object.type == 'grid'){
			object.updateGridBoxes()
		}

		if(object.type == 'group'){
			object.set_redraw()
		}
	}

	this.cropModeMovement = function(shiftX,shiftY,initialObject,initialMouseX,initialMouseY){
		var old_shift_x = shiftX; var old_shift_y = shiftY;
		shiftX = old_shift_x*Math.cos(object.rotation) + old_shift_y*Math.sin(object.rotation)
		shiftY = -old_shift_x*Math.sin(object.rotation) + old_shift_y*Math.cos(object.rotation)

		var expected_pos = {x: initialObject.image_details.contentDisplacement.x + shiftX,y:initialObject.image_details.contentDisplacement.y + shiftY}

		object.image_details.contentDisplacement.x = expected_pos.x;
		object.image_details.contentDisplacement.y = expected_pos.y;

		if(object.image_details.contentDisplacement.x>0){
			initialMouseX += object.image_details.contentDisplacement.x
			object.image_details.contentDisplacement.x = 0
		}

		if(object.image_details.contentDisplacement.y>0){
			initialMouseY += object.image_details.contentDisplacement.y
			object.image_details.contentDisplacement.y = 0
		}

		if(object.image_details.contentDisplacement.x + object.image_details.image_width < object.width){
			initialMouseX -= ((object.width - object.image_details.image_width) - object.image_details.contentDisplacement.x)
			object.image_details.contentDisplacement.x = (object.width - object.image_details.image_width)
		}

		if(object.image_details.contentDisplacement.y + object.image_details.image_height < object.height){
			initialMouseY -= ((object.height - object.image_details.image_height) - object.image_details.contentDisplacement.y);
			object.image_details.contentDisplacement.y = (object.height - object.image_details.image_height)
		}

		if(object.getGroup()){
			var all_objects = object.getGroup().group_details.object_data.map(function(o){
				return o.object
			})
			object.getGroup().setGroupFromObjects(all_objects,true)
			object.getGroup().set_redraw()
		}

		if(object.master && object.master.master && object.master.master.type == 'grid'){
			object.master.master.set_redraw()
		}else{
			object.set_redraw()
		}

		return {initialMouseX:initialMouseX,initialMouseY:initialMouseY}
	}

	this.moveArrows = function(shiftX,shiftY){
		object.position.x += shiftX;
		object.position.y += shiftY;

		if(object.type == 'group'){
			object.updateGroupObjects()
		}

		object.set_redraw();
	}

	this.cropModeCrop = function(corner,mouseX,mouseY){
		var special_position

		if(object.master && object.master.image_vertices){
			var image_vertices = object.master.image_vertices;
		}else{
			var image_vertices = object.getImageCropVertices();
		}

		if(object.master && object.master.vertices){
			var vertices = object.master.vertices;
		}else{
			var vertices = object.getVertices();
		}

		if(object.master && object.master.unrotated_pos_start){
			special_position = object.master.unrotated_pos_start
		}

		var nw_point = vertices[0];
		var ne_point = vertices[1];
		var se_point = vertices[2];
		var sw_point = vertices[3];

		var nw_point_image = image_vertices[0];
		var ne_point_image = image_vertices[1];
		var se_point_image = image_vertices[2];
		var sw_point_image = image_vertices[3];

		var angle_right = Math.atan2(vertices[1].y - vertices[0].y,vertices[1].x - vertices[0].x);
		var angle_bottom = Math.atan2(vertices[3].y - vertices[0].y,vertices[3].x - vertices[0].x);

		left_c = utils.getGeneralLineFromLineSegment(image_vertices[0],image_vertices[3]).c;
		right_c = utils.getGeneralLineFromLineSegment(image_vertices[1],image_vertices[2]).c;

		top_c = utils.getGeneralLineFromLineSegment(image_vertices[0],image_vertices[1]).c;
		bottom_c = utils.getGeneralLineFromLineSegment(image_vertices[3],image_vertices[2]).c;

		left_c_2 = utils.getGeneralLineFromLineSegment(vertices[0],vertices[3]).c;
		right_c_2 = utils.getGeneralLineFromLineSegment(vertices[1],vertices[2]).c;

		top_c_2 = utils.getGeneralLineFromLineSegment(vertices[0],vertices[1]).c;
		bottom_c_2 = utils.getGeneralLineFromLineSegment(vertices[3],vertices[2]).c;

		if(corner == 'top_left_crop'){
			var new_corner = {x:mouseX,y:mouseY}

			var new_top_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_right)*100,y:new_corner.y + Math.sin(angle_right)*100}
			);

			var new_left_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_bottom)*100,y:new_corner.y + Math.sin(angle_bottom)*100}
			);

			if(Math.abs(new_top_line.c - top_c)<5){
				new_top_line.c = top_c;
				new_corner = utils.projectPointOnGeneralLine(new_corner.x,new_corner.y,new_top_line.a,new_top_line.b,new_top_line.c);
			}

			if(Math.abs(new_left_line.c - left_c)<5){
				new_left_line.c = left_c;
				new_corner = utils.projectPointOnGeneralLine(new_corner.x,new_corner.y,new_left_line.a,new_left_line.b,new_left_line.c);
			}

			if((new_top_line.c > top_c && new_top_line.c > bottom_c) || (new_top_line.c < top_c && new_top_line.c < bottom_c)){
				new_top_line.c = top_c;
				new_corner = utils.projectPointOnGeneralLine(new_corner.x,new_corner.y,new_top_line.a,new_top_line.b,new_top_line.c);
			}

			if((new_left_line.c > left_c && new_left_line.c > right_c) || (new_left_line.c < left_c && new_left_line.c < right_c)){
				new_left_line.c = left_c;
				new_corner = utils.projectPointOnGeneralLine(new_corner.x,new_corner.y,new_left_line.a,new_left_line.b,new_left_line.c);
			}

			var line_right = utils.getGeneralLineFromLineSegment(vertices[1],vertices[2]);
			var line_bottom = utils.getGeneralLineFromLineSegment(vertices[2],vertices[3]);

			vertices[0] = new_corner

			vertices[1] = utils.lineLineIntersectionGeneral(new_top_line.a,new_top_line.b,new_top_line.c,line_right.a,line_right.b,line_right.c)
			vertices[3] = utils.lineLineIntersectionGeneral(new_left_line.a,new_left_line.b,new_left_line.c,line_bottom.a,line_bottom.b,line_bottom.c)

			object.applyVertices(vertices,true,true,'top_left_crop');
		}else if(corner == 'top_right_crop'){
			var new_corner = {x:mouseX,y:mouseY}


			var new_top_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_right)*100,y:new_corner.y + Math.sin(angle_right)*100}
			);

			var new_right_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_bottom)*100,y:new_corner.y + Math.sin(angle_bottom)*100}
			);

			if(Math.abs(new_top_line.c - top_c)<5){
				new_top_line.c = top_c;
				new_corner = utils.projectPointOnGeneralLine(new_corner.x,new_corner.y,new_top_line.a,new_top_line.b,new_top_line.c);
			}

			if(Math.abs(new_right_line.c - right_c)<5){
				new_right_line.c = right_c;
				new_corner = utils.projectPointOnGeneralLine(new_corner.x,new_corner.y,new_right_line.a,new_right_line.b,new_right_line.c);
			}

			if((new_top_line.c > top_c && new_top_line.c > bottom_c) || (new_top_line.c < top_c && new_top_line.c < bottom_c)){
				new_top_line.c = top_c
				new_corner = utils.projectPointOnGeneralLine(new_corner.x,new_corner.y,new_top_line.a,new_top_line.b,new_top_line.c);
			}

			if((new_right_line.c > left_c && new_right_line.c > right_c) || (new_right_line.c < left_c && new_right_line.c < right_c)){
				new_right_line.c = right_c
				new_corner = utils.projectPointOnGeneralLine(new_corner.x,new_corner.y,new_right_line.a,new_right_line.b,new_right_line.c);
			}

			var line_left = utils.getGeneralLineFromLineSegment(vertices[3],vertices[0]);
			var line_bottom = utils.getGeneralLineFromLineSegment(vertices[2],vertices[3]);

			vertices[1] = new_corner


			vertices[0] = utils.lineLineIntersectionGeneral(new_top_line.a,new_top_line.b,new_top_line.c,line_left.a,line_left.b,line_left.c)
			vertices[2] = utils.lineLineIntersectionGeneral(new_right_line.a,new_right_line.b,new_right_line.c,line_bottom.a,line_bottom.b,line_bottom.c)

			object.applyVertices(vertices,true,true,'top_right_crop');
		}else if(corner == 'bottom_right_crop'){
			var new_corner = {x:mouseX,y:mouseY}


			var new_bottom_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_right)*100,y:new_corner.y + Math.sin(angle_right)*100}
			);

			var new_right_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_bottom)*100,y:new_corner.y + Math.sin(angle_bottom)*100}
			);

			if(Math.abs(new_bottom_line.c - bottom_c)<5){
				new_bottom_line.c = bottom_c;
				new_corner = utils.projectPointOnGeneralLine(new_corner.x,new_corner.y,new_bottom_line.a,new_bottom_line.b,new_bottom_line.c);
			}

			if(Math.abs(new_right_line.c - right_c)<5){
				new_right_line.c = right_c;
				new_corner = utils.projectPointOnGeneralLine(new_corner.x,new_corner.y,new_right_line.a,new_right_line.b,new_right_line.c);
			}

			if((new_bottom_line.c > top_c && new_bottom_line.c > bottom_c) || (new_bottom_line.c < top_c && new_bottom_line.c < bottom_c)){
				new_bottom_line.c = bottom_c
				new_corner = utils.projectPointOnGeneralLine(new_corner.x,new_corner.y,new_bottom_line.a,new_bottom_line.b,new_bottom_line.c);
			}

			if((new_right_line.c > left_c && new_right_line.c > right_c) || (new_right_line.c < left_c && new_right_line.c < right_c)){
				new_right_line.c = right_c
				new_corner = utils.projectPointOnGeneralLine(new_corner.x,new_corner.y,new_right_line.a,new_right_line.b,new_right_line.c);
			}

			var line_left = utils.getGeneralLineFromLineSegment(vertices[3],vertices[0]);
			var line_top = utils.getGeneralLineFromLineSegment(vertices[0],vertices[1]);

			vertices[2] = new_corner


			vertices[1] = utils.lineLineIntersectionGeneral(new_right_line.a,new_right_line.b,new_right_line.c,line_top.a,line_top.b,line_top.c)
			vertices[3] = utils.lineLineIntersectionGeneral(new_bottom_line.a,new_bottom_line.b,new_bottom_line.c,line_left.a,line_left.b,line_left.c)

			object.applyVertices(vertices,true,true,'bottom_right_crop');
		}else if(corner == 'bottom_left_crop'){
			var new_corner = {x:mouseX,y:mouseY}

			var new_bottom_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_right)*100,y:new_corner.y + Math.sin(angle_right)*100}
			);

			var new_left_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_bottom)*100,y:new_corner.y + Math.sin(angle_bottom)*100}
			);

			if(Math.abs(new_bottom_line.c - bottom_c)<5){
				new_bottom_line.c = bottom_c;
				new_corner = utils.projectPointOnGeneralLine(new_corner.x,new_corner.y,new_bottom_line.a,new_bottom_line.b,new_bottom_line.c);
			}

			if(Math.abs(new_left_line.c - left_c)<5){
				new_left_line.c = left_c;
				new_corner = utils.projectPointOnGeneralLine(new_corner.x,new_corner.y,new_left_line.a,new_left_line.b,new_left_line.c);
			}

			if((new_bottom_line.c > top_c && new_bottom_line.c > bottom_c) || (new_bottom_line.c < top_c && new_bottom_line.c < bottom_c)){
				new_bottom_line.c = bottom_c
				new_corner = utils.projectPointOnGeneralLine(new_corner.x,new_corner.y,new_bottom_line.a,new_bottom_line.b,new_bottom_line.c);
			}

			if((new_left_line.c > left_c && new_left_line.c > right_c) || (new_left_line.c < left_c && new_left_line.c < right_c)){
				new_left_line.c = left_c
				new_corner = utils.projectPointOnGeneralLine(new_corner.x,new_corner.y,new_left_line.a,new_left_line.b,new_left_line.c);
			}

			var line_right = utils.getGeneralLineFromLineSegment(vertices[1],vertices[2]);
			var line_top = utils.getGeneralLineFromLineSegment(vertices[0],vertices[1]);

			vertices[3] = new_corner


			vertices[0] = utils.lineLineIntersectionGeneral(new_left_line.a,new_left_line.b,new_left_line.c,line_top.a,line_top.b,line_top.c)
			vertices[2] = utils.lineLineIntersectionGeneral(new_bottom_line.a,new_bottom_line.b,new_bottom_line.c,line_right.a,line_right.b,line_right.c)

			object.applyVertices(vertices,true,true,'bottom_left_crop');
		}else if(corner == 'top_left_crop_2'){
			if(!new_corner){
				var new_corner = utils.projectPointOnLine(mouseX, mouseY,
					se_point_image.x,se_point_image.y,
					nw_point_image.x,nw_point_image.y
				);
			}

			var diagonal = utils.getGeneralLineFromLineSegment(nw_point_image,se_point_image);

			var new_top_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_right)*100,y:new_corner.y + Math.sin(angle_right)*100}
			);

			var new_left_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_bottom)*100,y:new_corner.y + Math.sin(angle_bottom)*100}
			);

			var need_recalc = false;
			var top_gap = Math.abs(top_c_2 - top_c);
			var left_gap = Math.abs(left_c_2 - left_c);

			if(top_gap < left_gap){
				if(Math.abs(new_top_line.c - top_c_2)<5){
					new_top_line.c = top_c_2;
					new_corner = utils.lineLineIntersectionGeneral(new_top_line.a,new_top_line.b,new_top_line.c,diagonal.a,diagonal.b,diagonal.c);
					need_recalc = true;
				}

				if((new_top_line.c > top_c_2 && new_top_line.c < bottom_c_2) || (new_top_line.c < top_c_2 && new_top_line.c > bottom_c_2)){
					new_top_line.c = top_c_2;
					new_corner = utils.lineLineIntersectionGeneral(new_top_line.a,new_top_line.b,new_top_line.c,diagonal.a,diagonal.b,diagonal.c);
					need_recalc = true;
				}
			}else{
				if(Math.abs(new_left_line.c - left_c_2)<5){
					new_left_line.c = left_c_2;
					new_corner = utils.lineLineIntersectionGeneral(new_left_line.a,new_left_line.b,new_left_line.c,diagonal.a,diagonal.b,diagonal.c);
					need_recalc = true;
				}

				if((new_left_line.c > left_c_2 && new_left_line.c < right_c_2) || (new_left_line.c < left_c_2 && new_left_line.c > right_c_2)){
					new_left_line.c = left_c_2;
					new_corner = utils.lineLineIntersectionGeneral(new_left_line.a,new_left_line.b,new_left_line.c,diagonal.a,diagonal.b,diagonal.c);
					need_recalc = true;
				}
			}

			if(need_recalc){
				new_top_line = utils.getGeneralLineFromLineSegment(
					new_corner,{x:new_corner.x + Math.cos(angle_right)*100,y:new_corner.y + Math.sin(angle_right)*100}
				);

				new_left_line = utils.getGeneralLineFromLineSegment(
					new_corner,{x:new_corner.x + Math.cos(angle_bottom)*100,y:new_corner.y + Math.sin(angle_bottom)*100}
				);
			}

			var line_right = utils.getGeneralLineFromLineSegment(image_vertices[1],image_vertices[2]);
			var line_bottom = utils.getGeneralLineFromLineSegment(image_vertices[2],image_vertices[3]);
			
			var line_bottom = utils.getGeneralLineFromLineSegment(image_vertices[2],image_vertices[3]);

			image_vertices[0] = new_corner
			image_vertices[1] = utils.lineLineIntersectionGeneral(new_top_line.a,new_top_line.b,new_top_line.c,line_right.a,line_right.b,line_right.c)
			image_vertices[3] = utils.lineLineIntersectionGeneral(new_left_line.a,new_left_line.b,new_left_line.c,line_bottom.a,line_bottom.b,line_bottom.c)
			object.applyImageCropVertices(image_vertices,special_position);

			
		}else if(corner == 'top_right_crop_2'){
			if(!new_corner){
				var new_corner = utils.projectPointOnLine(mouseX, mouseY,
					ne_point_image.x,ne_point_image.y,
					sw_point_image.x,sw_point_image.y);
			}

			var diagonal = utils.getGeneralLineFromLineSegment(ne_point_image,sw_point_image);
			
			var new_top_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_right)*100,y:new_corner.y + Math.sin(angle_right)*100}
			);

			var new_right_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_bottom)*100,y:new_corner.y + Math.sin(angle_bottom)*100}
			);

			var need_recalc = false
			var top_gap = Math.abs(top_c_2 - top_c);
			var right_gap = Math.abs(right_c_2 - right_c);

			if(top_gap < right_gap){
				if(Math.abs(new_top_line.c - top_c_2)<5){
					new_top_line.c = top_c_2;
					new_corner = utils.lineLineIntersectionGeneral(new_top_line.a,new_top_line.b,new_top_line.c,diagonal.a,diagonal.b,diagonal.c);
					need_recalc = true;
				}

				if((new_top_line.c > top_c_2 && new_top_line.c < bottom_c_2) || (new_top_line.c < top_c_2 && new_top_line.c > bottom_c_2)){
					new_top_line.c = top_c_2;
					new_corner = utils.lineLineIntersectionGeneral(new_top_line.a,new_top_line.b,new_top_line.c,diagonal.a,diagonal.b,diagonal.c);
					need_recalc = true;
				}
			}else{
				if(Math.abs(new_right_line.c - right_c_2)<5){
					new_right_line.c = right_c_2;
					new_corner = utils.lineLineIntersectionGeneral(new_right_line.a,new_right_line.b,new_right_line.c,diagonal.a,diagonal.b,diagonal.c);
					need_recalc = true;
				}

				if((new_right_line.c > left_c_2 && new_right_line.c < right_c_2) || (new_right_line.c < left_c_2 && new_right_line.c > right_c_2)){
					new_right_line.c = right_c_2;
					new_corner = utils.lineLineIntersectionGeneral(new_right_line.a,new_right_line.b,new_right_line.c,diagonal.a,diagonal.b,diagonal.c);
					need_recalc = true;
				}
			}

			if(need_recalc){
				var new_top_line = utils.getGeneralLineFromLineSegment(
					new_corner,{x:new_corner.x + Math.cos(angle_right)*100,y:new_corner.y + Math.sin(angle_right)*100}
				);

				var new_right_line = utils.getGeneralLineFromLineSegment(
					new_corner,{x:new_corner.x + Math.cos(angle_bottom)*100,y:new_corner.y + Math.sin(angle_bottom)*100}
				);
			}

			var line_left = utils.getGeneralLineFromLineSegment(image_vertices[3],image_vertices[0]);
			var line_bottom = utils.getGeneralLineFromLineSegment(image_vertices[2],image_vertices[3]);

			image_vertices[1] = new_corner
			image_vertices[0] = utils.lineLineIntersectionGeneral(new_top_line.a,new_top_line.b,new_top_line.c,line_left.a,line_left.b,line_left.c)
			image_vertices[2] = utils.lineLineIntersectionGeneral(new_right_line.a,new_right_line.b,new_right_line.c,line_bottom.a,line_bottom.b,line_bottom.c)

			object.applyImageCropVertices(image_vertices,special_position);
		}else if(corner == 'bottom_right_crop_2'){
			if(!new_corner){
				var new_corner = utils.projectPointOnLine(mouseX, mouseY,
					se_point_image.x,se_point_image.y,
					nw_point_image.x,nw_point_image.y);
			}

			var diagonal = utils.getGeneralLineFromLineSegment(se_point_image,nw_point_image);

			var new_bottom_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_right)*100,y:new_corner.y + Math.sin(angle_right)*100}
			);

			var new_right_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_bottom)*100,y:new_corner.y + Math.sin(angle_bottom)*100}
			);

			var need_recalc = false
			var bottom_gap = Math.abs(bottom_c_2 - bottom_c);
			var right_gap = Math.abs(right_c_2 - right_c);

			if(bottom_gap < right_gap){
				if(Math.abs(new_bottom_line.c - bottom_c_2)<5){
					new_bottom_line.c = bottom_c_2;
					new_corner = utils.lineLineIntersectionGeneral(new_bottom_line.a,new_bottom_line.b,new_bottom_line.c,diagonal.a,diagonal.b,diagonal.c);
					need_recalc = true;
				}

				if((new_bottom_line.c > top_c_2 && new_bottom_line.c < bottom_c_2) || (new_bottom_line.c < top_c_2 && new_bottom_line.c > bottom_c_2)){
					new_bottom_line.c = bottom_c_2
					new_corner = utils.lineLineIntersectionGeneral(new_bottom_line.a,new_bottom_line.b,new_bottom_line.c,diagonal.a,diagonal.b,diagonal.c);
					need_recalc = true;
				}
			}else{
				if(Math.abs(new_right_line.c - right_c_2)<5){
					new_right_line.c = right_c_2;
					new_corner = utils.lineLineIntersectionGeneral(new_right_line.a,new_right_line.b,new_right_line.c,diagonal.a,diagonal.b,diagonal.c);
					need_recalc = true;
				}

				if((new_right_line.c > left_c_2 && new_right_line.c < right_c_2) || (new_right_line.c < left_c_2 && new_right_line.c > right_c_2)){
					new_right_line.c = right_c_2;
					new_corner = utils.lineLineIntersectionGeneral(new_right_line.a,new_right_line.b,new_right_line.c,diagonal.a,diagonal.b,diagonal.c);
					need_recalc = true;
				}
			}

			if(need_recalc){
				var new_bottom_line = utils.getGeneralLineFromLineSegment(
					new_corner,{x:new_corner.x + Math.cos(angle_right)*100,y:new_corner.y + Math.sin(angle_right)*100}
				);

				var new_right_line = utils.getGeneralLineFromLineSegment(
					new_corner,{x:new_corner.x + Math.cos(angle_bottom)*100,y:new_corner.y + Math.sin(angle_bottom)*100}
				);
			}

			var line_left = utils.getGeneralLineFromLineSegment(image_vertices[3],image_vertices[0]);
			var line_top = utils.getGeneralLineFromLineSegment(image_vertices[0],image_vertices[1]);

			image_vertices[2] = new_corner
			image_vertices[1] = utils.lineLineIntersectionGeneral(new_right_line.a,new_right_line.b,new_right_line.c,line_top.a,line_top.b,line_top.c)
			image_vertices[3] = utils.lineLineIntersectionGeneral(new_bottom_line.a,new_bottom_line.b,new_bottom_line.c,line_left.a,line_left.b,line_left.c)

			object.applyImageCropVertices(image_vertices,special_position);
		}else if(corner == 'bottom_left_crop_2'){
			if(!new_corner){
				var new_corner = utils.projectPointOnLine(mouseX, mouseY,
					sw_point_image.x,sw_point_image.y,
					ne_point_image.x,ne_point_image.y);
			}

			var diagonal = utils.getGeneralLineFromLineSegment(sw_point_image,ne_point_image);

			var new_bottom_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_right)*100,y:new_corner.y + Math.sin(angle_right)*100}
			);

			var new_left_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_bottom)*100,y:new_corner.y + Math.sin(angle_bottom)*100}
			);

			var need_recalc = false
			var bottom_gap = Math.abs(bottom_c_2 - bottom_c);
			var left_gap = Math.abs(left_c_2 - left_c);

			if(bottom_gap < left_gap){
				if(Math.abs(new_bottom_line.c - bottom_c_2)<5){
					new_bottom_line.c = bottom_c_2;
					new_corner = utils.lineLineIntersectionGeneral(new_bottom_line.a,new_bottom_line.b,new_bottom_line.c,diagonal.a,diagonal.b,diagonal.c);
					need_recalc = true;
				}

				if((new_bottom_line.c > top_c_2 && new_bottom_line.c < bottom_c_2) || (new_bottom_line.c < top_c_2 && new_bottom_line.c > bottom_c_2)){
					new_bottom_line.c = bottom_c_2;
					new_corner = utils.lineLineIntersectionGeneral(new_bottom_line.a,new_bottom_line.b,new_bottom_line.c,diagonal.a,diagonal.b,diagonal.c);
					need_recalc = true;
				}
			}else{
				if(Math.abs(new_left_line.c - left_c_2)<5){
					new_left_line.c = left_c_2;
					new_corner = utils.lineLineIntersectionGeneral(new_left_line.a,new_left_line.b,new_left_line.c,diagonal.a,diagonal.b,diagonal.c);
					need_recalc = true;
				}

				if((new_left_line.c > left_c_2 && new_left_line.c < right_c_2) || (new_left_line.c < left_c_2 && new_left_line.c > right_c_2)){
					new_left_line.c = left_c_2;
					new_corner = utils.lineLineIntersectionGeneral(new_left_line.a,new_left_line.b,new_left_line.c,diagonal.a,diagonal.b,diagonal.c);
					need_recalc = true;
				}
			}

			if(need_recalc){
				var new_bottom_line = utils.getGeneralLineFromLineSegment(
					new_corner,{x:new_corner.x + Math.cos(angle_right)*100,y:new_corner.y + Math.sin(angle_right)*100}
				);

				var new_left_line = utils.getGeneralLineFromLineSegment(
					new_corner,{x:new_corner.x + Math.cos(angle_bottom)*100,y:new_corner.y + Math.sin(angle_bottom)*100}
				);
			}

			var line_right = utils.getGeneralLineFromLineSegment(image_vertices[1],image_vertices[2]);
			var line_top = utils.getGeneralLineFromLineSegment(image_vertices[0],image_vertices[1]);

			image_vertices[3] = new_corner
			image_vertices[0] = utils.lineLineIntersectionGeneral(new_left_line.a,new_left_line.b,new_left_line.c,line_top.a,line_top.b,line_top.c)
			image_vertices[2] = utils.lineLineIntersectionGeneral(new_bottom_line.a,new_bottom_line.b,new_bottom_line.c,line_right.a,line_right.b,line_right.c)

			object.applyImageCropVertices(image_vertices,special_position);
		}
		
		if(object.getGroup()){
			var all_objects = object.getGroup().group_details.object_data.map(function(o){
				return o.object
			})
			object.getGroup().setGroupFromObjects(all_objects,true)
			object.getGroup().set_redraw()
		}

		if(object.master && object.master.master && object.master.master.type == 'grid'){
			object.master.master.set_redraw()
		}else{
			object.set_redraw()
		}
		design.needs_redraw = true
	}

	this.resize = function(corner,mouseX,mouseY,snapping_line){
		var vertices = object.getVertices();
		var nw_point = vertices[0];
		var ne_point = vertices[1];
		var se_point = vertices[2];
		var sw_point = vertices[3];
		var angle_right = Math.atan2(vertices[1].y - vertices[0].y,vertices[1].x - vertices[0].x)
		var angle_bottom = Math.atan2(vertices[3].y - vertices[0].y,vertices[3].x - vertices[0].x)

		var oldHeight;

		if(object.type == 'group'){
			oldHeight = []
			object.updateGroupObjects()
			for (var i = 0; i < object.group_details.object_data.length; i++) {
				var child = object.group_details.object_data[i].object
				if(child.type == 'text'){
					oldHeight[i] = child.height;
				}
			}
		}else if(object.type == 'text'){
			oldHeight = object.height
		}

		if(corner == 'top_left'){
			if(snapping_line){
				var diagonal = utils.getGeneralLineFromLineSegment(
					se_point,nw_point
				);
				var snap_general_line = utils.getGeneralLineFromLineSegment(
					snapping_line[0],snapping_line[1]
				);
				if(!utils.areLinesAlmostParallel(diagonal.a,diagonal.b,snap_general_line.a,snap_general_line.b)){
					var new_corner = utils.lineLineIntersectionGeneral(diagonal.a,diagonal.b,diagonal.c,snap_general_line.a,snap_general_line.b,snap_general_line.c)
				}
			}

			if(!new_corner){
				var new_corner = utils.projectPointOnLine(mouseX, mouseY,
					se_point.x,se_point.y,
					nw_point.x,nw_point.y);
			}

			var new_top_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_right)*100,y:new_corner.y + Math.sin(angle_right)*100}
			);

			var new_left_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_bottom)*100,y:new_corner.y + Math.sin(angle_bottom)*100}
			);

			var line_right = utils.getGeneralLineFromLineSegment(vertices[1],vertices[2]);
			var line_bottom = utils.getGeneralLineFromLineSegment(vertices[2],vertices[3]);

			vertices[0] = new_corner
			vertices[1] = utils.lineLineIntersectionGeneral(new_top_line.a,new_top_line.b,new_top_line.c,line_right.a,line_right.b,line_right.c)
			vertices[3] = utils.lineLineIntersectionGeneral(new_left_line.a,new_left_line.b,new_left_line.c,line_bottom.a,line_bottom.b,line_bottom.c)

			object.applyVertices(vertices,true);
		}else if(corner == 'top_right'){
			if(snapping_line){
				var diagonal = utils.getGeneralLineFromLineSegment(
					sw_point,ne_point
				);
				var snap_general_line = utils.getGeneralLineFromLineSegment(
					snapping_line[0],snapping_line[1]
				);
				if(!utils.areLinesAlmostParallel(diagonal.a,diagonal.b,snap_general_line.a,snap_general_line.b)){
					var new_corner = utils.lineLineIntersectionGeneral(diagonal.a,diagonal.b,diagonal.c,snap_general_line.a,snap_general_line.b,snap_general_line.c)
				}
			}

			if(!new_corner){
				var new_corner = utils.projectPointOnLine(mouseX, mouseY,
					ne_point.x,ne_point.y,
					sw_point.x,sw_point.y);
			}

			var new_top_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_right)*100,y:new_corner.y + Math.sin(angle_right)*100}
			);

			var new_right_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_bottom)*100,y:new_corner.y + Math.sin(angle_bottom)*100}
			);

			var line_left = utils.getGeneralLineFromLineSegment(vertices[3],vertices[0]);
			var line_bottom = utils.getGeneralLineFromLineSegment(vertices[2],vertices[3]);

			vertices[1] = new_corner
			vertices[0] = utils.lineLineIntersectionGeneral(new_top_line.a,new_top_line.b,new_top_line.c,line_left.a,line_left.b,line_left.c)
			vertices[2] = utils.lineLineIntersectionGeneral(new_right_line.a,new_right_line.b,new_right_line.c,line_bottom.a,line_bottom.b,line_bottom.c)

			object.applyVertices(vertices,true);
		}else if(corner == 'bottom_right'){
			if(snapping_line){
				var diagonal = utils.getGeneralLineFromLineSegment(
					se_point,nw_point
				);
				var snap_general_line = utils.getGeneralLineFromLineSegment(
					snapping_line[0],snapping_line[1]
				);
				if(!utils.areLinesAlmostParallel(diagonal.a,diagonal.b,snap_general_line.a,snap_general_line.b)){
					var new_corner = utils.lineLineIntersectionGeneral(diagonal.a,diagonal.b,diagonal.c,snap_general_line.a,snap_general_line.b,snap_general_line.c)
				}
			}

			if(!new_corner){
				var new_corner = utils.projectPointOnLine(mouseX, mouseY,
					se_point.x,se_point.y,
					nw_point.x,nw_point.y);
			}

			var new_bottom_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_right)*100,y:new_corner.y + Math.sin(angle_right)*100}
			);

			var new_right_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_bottom)*100,y:new_corner.y + Math.sin(angle_bottom)*100}
			);

			var line_left = utils.getGeneralLineFromLineSegment(vertices[3],vertices[0]);
			var line_top = utils.getGeneralLineFromLineSegment(vertices[0],vertices[1]);

			vertices[2] = new_corner
			vertices[1] = utils.lineLineIntersectionGeneral(new_right_line.a,new_right_line.b,new_right_line.c,line_top.a,line_top.b,line_top.c)
			vertices[3] = utils.lineLineIntersectionGeneral(new_bottom_line.a,new_bottom_line.b,new_bottom_line.c,line_left.a,line_left.b,line_left.c)

			object.applyVertices(vertices,true);
		}else if(corner == 'bottom_left'){
			if(snapping_line){
				var diagonal = utils.getGeneralLineFromLineSegment(
					sw_point,ne_point
				);
				var snap_general_line = utils.getGeneralLineFromLineSegment(
					snapping_line[0],snapping_line[1]
				);
				if(!utils.areLinesAlmostParallel(diagonal.a,diagonal.b,snap_general_line.a,snap_general_line.b)){
					var new_corner = utils.lineLineIntersectionGeneral(diagonal.a,diagonal.b,diagonal.c,snap_general_line.a,snap_general_line.b,snap_general_line.c)
				}
			}

			if(!new_corner){
				var new_corner = utils.projectPointOnLine(mouseX, mouseY,
					ne_point.x,ne_point.y,
					sw_point.x,sw_point.y);
			}

			var new_bottom_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_right)*100,y:new_corner.y + Math.sin(angle_right)*100}
			);

			var new_left_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_bottom)*100,y:new_corner.y + Math.sin(angle_bottom)*100}
			);

			var line_right = utils.getGeneralLineFromLineSegment(vertices[1],vertices[2]);
			var line_top = utils.getGeneralLineFromLineSegment(vertices[0],vertices[1]);

			vertices[3] = new_corner
			vertices[0] = utils.lineLineIntersectionGeneral(new_left_line.a,new_left_line.b,new_left_line.c,line_top.a,line_top.b,line_top.c)
			vertices[2] = utils.lineLineIntersectionGeneral(new_bottom_line.a,new_bottom_line.b,new_bottom_line.c,line_right.a,line_right.b,line_right.c)

			object.applyVertices(vertices,true);
		}

		if(object.type == 'group'){
			object.updateGroupObjects()
			for (var i = 0; i < object.group_details.object_data.length; i++) {
				var child = object.group_details.object_data[i].object
				if(child.type == 'text'){
					child.text_details.letterSpacing *= (child.height/oldHeight[i])
					var oldLineHeight = child.text_details.lineHeight
					child.text_details.lineHeight *= (child.height/oldHeight[i])
					child.text_details.fontSize = ((Number(child.text_details.fontSize) + Number(oldLineHeight))*child.height/oldHeight[i]) - Number(child.text_details.lineHeight)
				}
			}
		}

		if(object.type == 'text'){
			object.text_details.letterSpacing *= (object.height/oldHeight)
			var oldLineHeight = object.text_details.lineHeight
			object.text_details.lineHeight *= (object.height/oldHeight)
			object.text_details.fontSize = ((Number(object.text_details.fontSize) + Number(oldLineHeight))*object.height/oldHeight) - Number(object.text_details.lineHeight)
		}

		object.set_redraw()
		design.needs_redraw = true
	}

	this.cropOrRotate = function(corner,mouseX,mouseY,snapping_line){
		var vertices = object.getVertices();

		var n_point = {x:(vertices[0].x+vertices[1].x)/2,y:(vertices[0].y+vertices[1].y)/2}
		var e_point = {x:(vertices[1].x+vertices[2].x)/2,y:(vertices[1].y+vertices[2].y)/2}
		var s_point = {x:(vertices[2].x+vertices[3].x)/2,y:(vertices[2].y+vertices[3].y)/2}
		var w_point = {x:(vertices[3].x+vertices[0].x)/2,y:(vertices[3].y+vertices[0].y)/2}

		var nw_point = {x:vertices[0].x,y:vertices[0].y}
		var ne_point = {x:vertices[1].x,y:vertices[1].y}
		var se_point = {x:vertices[2].x,y:vertices[2].y}
		var sw_point = {x:vertices[3].x,y:vertices[3].y}

		var angle_right = Math.atan2(vertices[1].y - vertices[0].y,vertices[1].x - vertices[0].x)
		var angle_bottom = Math.atan2(vertices[3].y - vertices[0].y,vertices[3].x - vertices[0].x)

		if(corner == 'top'){
			if(snapping_line){
				var diagonal = utils.getGeneralLineFromLineSegment(
					n_point,s_point
				);
				var snap_general_line = utils.getGeneralLineFromLineSegment(
					snapping_line[0],snapping_line[1]
				);
				if(!utils.areLinesAlmostParallel(diagonal.a,diagonal.b,snap_general_line.a,snap_general_line.b)){
					var new_corner = utils.lineLineIntersectionGeneral(diagonal.a,diagonal.b,diagonal.c,snap_general_line.a,snap_general_line.b,snap_general_line.c)
				}
			}

			if(!new_corner){
				var new_corner = utils.projectPointOnLine(mouseX, mouseY,
					n_point.x,n_point.y,
					s_point.x,s_point.y);
			}
			var new_top_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_right)*100,y:new_corner.y + Math.sin(angle_right)*100}
			);

			var line_left = utils.getGeneralLineFromLineSegment(vertices[3],vertices[0]);
			var line_right = utils.getGeneralLineFromLineSegment(vertices[1],vertices[2]);

			vertices[0] = utils.lineLineIntersectionGeneral(new_top_line.a,new_top_line.b,new_top_line.c,line_left.a,line_left.b,line_left.c)
			vertices[1] = utils.lineLineIntersectionGeneral(new_top_line.a,new_top_line.b,new_top_line.c,line_right.a,line_right.b,line_right.c)

			object.applyVertices(vertices,true,true,corner);
			design.fillImageCropGaps(object);
			if(object.type == 'grid'){
				for (var i = 0; i < object.grid_details.boxes.length; i++) {
					if(object.grid_details.boxes[i].image){
						object.grid_details.boxes[i].image.width = (object.grid_details.boxes[i].width/100)*object.width
						object.grid_details.boxes[i].image.height = (object.grid_details.boxes[i].height/100)*object.height
						design.fillImageCropGaps(object.grid_details.boxes[i].image);
					}
				}
			}
		}else if(corner == 'right'){
			if(snapping_line){
				var diagonal = utils.getGeneralLineFromLineSegment(
					w_point,e_point
				);
				var snap_general_line = utils.getGeneralLineFromLineSegment(
					snapping_line[0],snapping_line[1]
				);
				if(!utils.areLinesAlmostParallel(diagonal.a,diagonal.b,snap_general_line.a,snap_general_line.b)){
					var new_corner = utils.lineLineIntersectionGeneral(diagonal.a,diagonal.b,diagonal.c,snap_general_line.a,snap_general_line.b,snap_general_line.c)
				}
			}
			if(!new_corner){
				var new_corner = utils.projectPointOnLine(mouseX, mouseY,
					w_point.x,w_point.y,
					e_point.x,e_point.y);
			}

			var new_right_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_bottom)*100,y:new_corner.y + Math.sin(angle_bottom)*100}
			);

			var line_top = utils.getGeneralLineFromLineSegment(vertices[0],vertices[1]);
			var line_bottom = utils.getGeneralLineFromLineSegment(vertices[2],vertices[3]);

			vertices[1] = utils.lineLineIntersectionGeneral(new_right_line.a,new_right_line.b,new_right_line.c,line_top.a,line_top.b,line_top.c)
			vertices[2] = utils.lineLineIntersectionGeneral(new_right_line.a,new_right_line.b,new_right_line.c,line_bottom.a,line_bottom.b,line_bottom.c)

			object.applyVertices(vertices,true,true,corner);
			design.fillImageCropGaps(object);
			if(object.type == 'grid'){
				for (var i = 0; i < object.grid_details.boxes.length; i++) {
					if(object.grid_details.boxes[i].image){
						object.grid_details.boxes[i].image.width = (object.grid_details.boxes[i].width/100)*object.width
						object.grid_details.boxes[i].image.height = (object.grid_details.boxes[i].height/100)*object.height
						design.fillImageCropGaps(object.grid_details.boxes[i].image);
					}
				}
			}
		}else if(corner == 'bottom'){
			if(snapping_line){
				var diagonal = utils.getGeneralLineFromLineSegment(
					n_point,s_point
				);
				var snap_general_line = utils.getGeneralLineFromLineSegment(
					snapping_line[0],snapping_line[1]
				);
				if(!utils.areLinesAlmostParallel(diagonal.a,diagonal.b,snap_general_line.a,snap_general_line.b)){
					var new_corner = utils.lineLineIntersectionGeneral(diagonal.a,diagonal.b,diagonal.c,snap_general_line.a,snap_general_line.b,snap_general_line.c)
				}
			}

			if(!new_corner){
				var new_corner = utils.projectPointOnLine(mouseX, mouseY,
					n_point.x,n_point.y,
					s_point.x,s_point.y);
			}

			var new_bottom_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_right)*100,y:new_corner.y + Math.sin(angle_right)*100}
			);

			var line_left = utils.getGeneralLineFromLineSegment(vertices[3],vertices[0]);
			var line_right = utils.getGeneralLineFromLineSegment(vertices[1],vertices[2]);

			vertices[3] = utils.lineLineIntersectionGeneral(new_bottom_line.a,new_bottom_line.b,new_bottom_line.c,line_left.a,line_left.b,line_left.c)
			vertices[2] = utils.lineLineIntersectionGeneral(new_bottom_line.a,new_bottom_line.b,new_bottom_line.c,line_right.a,line_right.b,line_right.c)

			object.applyVertices(vertices,true,true,corner);
			design.fillImageCropGaps(object);
			if(object.type == 'grid'){
				for (var i = 0; i < object.grid_details.boxes.length; i++) {
					if(object.grid_details.boxes[i].image){
						object.grid_details.boxes[i].image.width = (object.grid_details.boxes[i].width/100)*object.width
						object.grid_details.boxes[i].image.height = (object.grid_details.boxes[i].height/100)*object.height
						design.fillImageCropGaps(object.grid_details.boxes[i].image);
					}
				}
			}
		}else if(corner == 'left'){
			if(snapping_line){
				var diagonal = utils.getGeneralLineFromLineSegment(
					w_point,e_point
				);
				var snap_general_line = utils.getGeneralLineFromLineSegment(
					snapping_line[0],snapping_line[1]
				);
				if(!utils.areLinesAlmostParallel(diagonal.a,diagonal.b,snap_general_line.a,snap_general_line.b)){
					var new_corner = utils.lineLineIntersectionGeneral(diagonal.a,diagonal.b,diagonal.c,snap_general_line.a,snap_general_line.b,snap_general_line.c)
				}
			}
			if(!new_corner){
				var new_corner = utils.projectPointOnLine(mouseX, mouseY,
					w_point.x,w_point.y,
					e_point.x,e_point.y);
			}

			var new_left_line = utils.getGeneralLineFromLineSegment(
				new_corner,{x:new_corner.x + Math.cos(angle_bottom)*100,y:new_corner.y + Math.sin(angle_bottom)*100}
			);

			var line_top = utils.getGeneralLineFromLineSegment(vertices[0],vertices[1]);
			var line_bottom = utils.getGeneralLineFromLineSegment(vertices[2],vertices[3]);

			vertices[0] = utils.lineLineIntersectionGeneral(new_left_line.a,new_left_line.b,new_left_line.c,line_top.a,line_top.b,line_top.c)
			vertices[3] = utils.lineLineIntersectionGeneral(new_left_line.a,new_left_line.b,new_left_line.c,line_bottom.a,line_bottom.b,line_bottom.c)

			object.applyVertices(vertices,true,true,corner);
			design.fillImageCropGaps(object);
			if(object.type == 'grid'){
				for (var i = 0; i < object.grid_details.boxes.length; i++) {
					if(object.grid_details.boxes[i].image){
						object.grid_details.boxes[i].image.width = (object.grid_details.boxes[i].width/100)*object.width
						object.grid_details.boxes[i].image.height = (object.grid_details.boxes[i].height/100)*object.height
						design.fillImageCropGaps(object.grid_details.boxes[i].image);
					}
				}
			}
		}else if(corner == 'rotate'){
			var angle0 = Math.atan2(100,0);
			var center = object.getCenter()
			var angle = Math.atan2(mouseY - center.y,mouseX - center.x);

			var new_angle = utils.moduloTwoPI(angle - angle0);
			if(Math.abs(new_angle - 2*Math.PI)<0.075 || Math.abs(new_angle)<0.075){
				new_angle = 0
			}else if(Math.abs(new_angle - 0.5*Math.PI)<0.075){
				new_angle = 0.5*Math.PI
			}else if(Math.abs(new_angle - 1.5*Math.PI)<0.075){
				new_angle = 1.5*Math.PI
			}else if(Math.abs(new_angle - Math.PI)<0.075){
				new_angle = Math.PI
			}


			object.rotation = new_angle
		}

		if(object.type == 'group'){
			object.updateGroupObjects()
		}

		object.set_redraw()
		design.needs_redraw = true

		var rtt = setTimeout(function(){
			if(object.type == 'group'){
				var extra_redraw = false
				for (var i = 0; i < object.group_details.object_data.length; i++) {
					var o = object.group_details.object_data[i].object
					if(o.type == 'text'){
						o.set_redraw()
						extra_redraw = true
					}
				}

				if(extra_redraw){
					design.needs_redraw = true
				}
			}

			clearTimeout(rtt)
		},30)

	}

	this.getVertices = function(){
		var unrotated_vertices = [
			{x:object.position.x,y:object.position.y},
			{x:object.position.x + object.width,y:object.position.y},
			{x:object.position.x + object.width,y:object.position.y + object.height},
			{x:object.position.x,y:object.position.y + object.height}
		]

		return object.rotateVertices(unrotated_vertices,object.rotation);
	}

	this.getImageCropVertices = function(){
		var pos = {x: object.position.x + object.image_details.contentDisplacement.x,y: object.position.y + object.image_details.contentDisplacement.y}

		var unrotated_vertices = [
			{x:pos.x,y:pos.y},
			{x:pos.x + object.image_details.image_width,y:pos.y},
			{x:pos.x + object.image_details.image_width,y:pos.y + object.image_details.image_height},
			{x:pos.x,y:pos.y + object.image_details.image_height}
		]

		return object.rotateVertices(unrotated_vertices,object.rotation,object.getCenter());
	}

	this.rotateVertices = function(vertices,rotation,rotation_origin){
		if(!rotation_origin){
			var rotation_origin = {
				x: (vertices[0].x+vertices[1].x+vertices[2].x+vertices[3].x)/4,
				y: (vertices[0].y+vertices[1].y+vertices[2].y+vertices[3].y)/4
			}
		}

		vertices = vertices.map(function(o){
			return {x:o.x - rotation_origin.x,y: o.y - rotation_origin.y}
		})

		return vertices.map(function(o){
			return {
				x: o.x*Math.cos(rotation) - o.y*Math.sin(rotation) + rotation_origin.x,
				y: o.x*Math.sin(rotation) + o.y*Math.cos(rotation) + rotation_origin.y
			}
		})
	}

	this.getRotationPoint = function(){
		var vertices = object.getVertices();
		var angle = -(Math.PI/2)+Math.atan2(vertices[3].y - vertices[2].y, vertices[3].x - vertices[2].x)
		var rotation_vertex = {x: (vertices[2].x+vertices[3].x)/2,y: (vertices[2].y+vertices[3].y)/2}

		rotation_vertex.x = rotation_vertex.x + (Math.cos(angle)*40)
		rotation_vertex.y = rotation_vertex.y + (Math.sin(angle)*40)

		return rotation_vertex
	}

	this.getCenter = function(){
		var vertices = object.getVertices();

		return {
			x: (vertices[0].x+vertices[1].x+vertices[2].x+vertices[3].x)/4,
			y: (vertices[0].y+vertices[1].y+vertices[2].y+vertices[3].y)/4
		}
	}

	this.updateGridBoxes = function(){
		var boxes = object.grid_details.boxes;

		var unrotated_vertices = object.getUnrotatedVertices();
		var vertices = object.getVertices();

		for (var i = 0; i < boxes.length; i++) {
			var unrotated_pos_start = {
				x:unrotated_vertices[0].x + (boxes[i].position.x*object.width/100),
				y: unrotated_vertices[0].y + (boxes[i].position.y*object.height/100)
			}

			var unrotated_box_vertices = [
				{
					x:unrotated_pos_start.x,
					y: unrotated_pos_start.y
				},
				{
					x:unrotated_pos_start.x + (boxes[i].width*object.width/100),
					y: unrotated_pos_start.y
				},
				{
					x:unrotated_pos_start.x + (boxes[i].width*object.width/100),
					y: unrotated_pos_start.y + (boxes[i].height*object.height/100)
				},
				{
					x:unrotated_pos_start.x,
					y: unrotated_pos_start.y + (boxes[i].height*object.height/100)
				}
			];

			if(boxes[i].image){
				var pos = {x: unrotated_pos_start.x + boxes[i].image.image_details.contentDisplacement.x,y: unrotated_pos_start.y + boxes[i].image.image_details.contentDisplacement.y}
				var image_vertices = [
					{x:pos.x,y:pos.y},
					{x:pos.x + boxes[i].image.image_details.image_width,y:pos.y},
					{x:pos.x + boxes[i].image.image_details.image_width,y:pos.y + boxes[i].image.image_details.image_height},
					{x:pos.x,y:pos.y + boxes[i].image.image_details.image_height}
				]

				boxes[i].image_vertices = object.rotateVertices(image_vertices,object.rotation,object.getCenter());
			}

			boxes[i].vertices = object.rotateVertices(unrotated_box_vertices,object.rotation,object.getCenter())

			boxes[i].local_vertices = unrotated_box_vertices.map(function(o){
				return {x: o.x - unrotated_vertices[0].x,y: o.y - unrotated_vertices[0].y};
			})

			boxes[i].unrotated_pos_start = unrotated_pos_start
		}
	}

	this.applyVertices = function(vertices,dont_change_rotation,crop,crop_point){
		var rotation = Math.atan2(vertices[1].y - vertices[0].y,vertices[1].x - vertices[0].x)
		if(Math.abs(utils.moduloTwoPI(rotation) - utils.moduloTwoPI(object.rotation))>0.01 && dont_change_rotation){
			return
		}
		object.rotation = rotation;

		if(crop_point == 'top_left_crop'||crop_point == 'top_right_crop'||crop_point == 'bottom_right_crop'||crop_point == 'bottom_left_crop'){
			var old_vertices = object.getVertices()
			var v = {x:vertices[0].x - old_vertices[0].x, y:vertices[0].y - old_vertices[0].y}
			var dx = v.x*Math.cos(rotation) + v.y*Math.sin(rotation);
			var dy = -v.x*Math.sin(rotation) + v.y*Math.cos(rotation);
		}

		var unrotated_vertices = object.rotateVertices(vertices,-rotation);

		var old_width = object.width;
		var old_height = object.height;

		if((unrotated_vertices[1].x - unrotated_vertices[0].x) <= 0.01 || (unrotated_vertices[3].y - unrotated_vertices[0].y) <= 0.01){
			return
		}

		object.position.x = unrotated_vertices[0].x
		object.position.y = unrotated_vertices[0].y
		object.width = unrotated_vertices[1].x - unrotated_vertices[0].x
		object.height = unrotated_vertices[3].y - unrotated_vertices[0].y

		if(crop && crop_point){
			if(crop_point == 'top'){
				var height_change = object.height - old_height;
				object.image_details.contentDisplacement.y += height_change;
			}else if(crop_point == 'left'){
				var width_change = object.width - old_width;
				object.image_details.contentDisplacement.x += width_change;
			}else if(crop_point == 'top_left_crop'||crop_point == 'top_right_crop'||crop_point == 'bottom_right_crop'||crop_point == 'bottom_left_crop'){
				var v = object.getVertices();
				object.image_details.contentDisplacement.x -= dx
				object.image_details.contentDisplacement.y -= dy
			}
		}else{
			change_ratio = object.width/old_width;
			object.image_details.image_width *= change_ratio;
			object.image_details.image_height *= change_ratio;
			object.image_details.contentDisplacement.x *= change_ratio;
			object.image_details.contentDisplacement.y *= change_ratio;

			if(object.type == 'grid'){
				var boxes = object.grid_details.boxes;
				for (var i = 0; i < boxes.length; i++) {
					if(boxes[i].image){
						boxes[i].image.image_details.image_width *= change_ratio;
						boxes[i].image.image_details.image_height *= change_ratio;
						boxes[i].image.image_details.contentDisplacement.x *= change_ratio;
						boxes[i].image.image_details.contentDisplacement.y *= change_ratio;
					}
				}
			}
		}
	}

	this.applyImageCropVertices = function(vertices,special_position){
		var unrotated_vertices = object.rotateVertices(vertices,-object.rotation,object.getCenter());

		if((unrotated_vertices[1].x - unrotated_vertices[0].x) < 5 || (unrotated_vertices[3].y - unrotated_vertices[0].y) < 5){
			return
		}

		if(special_position){
			object.image_details.contentDisplacement.x = unrotated_vertices[0].x - special_position.x;
			object.image_details.contentDisplacement.y = unrotated_vertices[0].y - special_position.y;
		}else{
			object.image_details.contentDisplacement.x = unrotated_vertices[0].x - object.position.x;
			object.image_details.contentDisplacement.y = unrotated_vertices[0].y - object.position.y;
		}
		object.image_details.image_width = unrotated_vertices[1].x - unrotated_vertices[0].x
		object.image_details.image_height = unrotated_vertices[3].y - unrotated_vertices[0].y
	}

	this.remove = function(){
		if(object.type == 'group'){
			_.pull(design.groups,object);
			for (var i = 0; i < object.group_details.object_data.length; i++) {
				object.group_details.object_data[i].object.remove()
			}
		}else{
			_.pull(design.objects,object);
		}

		for (var i = design.groups.length - 1; i >= 0; i--) {
			var cond = true
			for(var j=0;j<design.groups[i].group_details.object_data.length;j++){
				var o = design.groups[i].group_details.object_data[j].object;
				if(design.objects.indexOf(o) > -1){
					cond = false;
					break
				}
			}

			if(cond){
				_.pull(design.groups,design.groups[i]);
			}
		}


		var sorted_objects = _.sortBy(design.objects,function(o){
	        return o.layer_index
	    })

	    for (var i = 0; i < sorted_objects.length; i++) {
	    	sorted_objects[i].layer_index = i
	    }
	    
		design.needs_redraw = true;
	}

	this.ungroup = function(){
		if(object.type == 'group'){
			_.pull(design.groups,object);
		}
	}

	this.image_cache_id = function(extra_append){
		if(extra_append == undefined){
			extra_append = ''
		}

		var loadable_id = object.image_details.id_unsplash||object.image_details.id_pixlr||object.image_details.id_123rf||object.image_details.resource_id||object.image_details.src||object.mockup_details.id

		return loadable_id+object.image_details.image_contain+object.id + extra_append
	}

	this.needs_clear_cache = function(object_file){
		try{
			if(object_file.type == 'image'){
				if(object_file.sub_type == 'icon'){
					if(object_file.image_details.svg_colors && !_.isEqual(object.image_details.svg_colors,object_file.image_details.svg_colors)){
						return true
					}
				}else if(object_file.bgremoval && object_file.bgremoval.enabled != object.bgremoval.enabled){
					return true
				}else if(object_file.sub_type=='mockup' && !_.isEqual(object.mockup_details,object_file.mockup_details)){
					return true
				}else if(object_file.image_details.image_contain!=undefined && object_file.image_details.image_contain!=object.image_details.image_contain){
					return true
				}
			}
			return false
		}catch(err){
			console.log(err);
			return false
		}
	}

	this.needs_needs_redraw = function(object_file){
		try{
			return !_.isEqual(object.save(),object_file)
		}catch(err){
			console.log(err);
			return false
		}
	}

	this.save = function(){
		var data = {}
		data.id = object.id
		data.type = object.type
		data.sub_type = object.sub_type
		data.layer_index = object.layer_index
		data.labels = deref(object.labels)
		data.user_labels = deref(object.user_labels)
		data.text_details = deref(object.text_details)
		data.image_details = deref(object.image_details)
		data.mockup_details = deref(object.mockup_details)
		data.filter = deref(object.filter)
		data.bgremoval = deref(object.bgremoval)
		data.grid_details = {
			boxes: object.grid_details.boxes.map(function(o){
				return {
					frame: o.frame?o.frame.save():null,
					image: o.image?o.image.save():null,
					position: o.position,
					width: o.width,
					height: o.height,
					color: o.color
				}
			})
		}

		data.group_details = {
			object_data: object.group_details.object_data.map(function(o){
				var result = {}
				for(var b in o){
					result[b] = o[b]
				}
				result.object = result.object.id;
				return result
			})
		}
		data.position = JSON.parse(JSON.stringify(object.position))
		data.opacity = object.opacity
		data.width = object.width
		data.height = object.height
		data.rotation = object.rotation
		data.locked = object.locked

		return data
	}

	this.load = function(object_file,dont_check_clear_cache){
		var needs_needs_redraw = object.needs_needs_redraw(object_file);
		var needs_clear_cache = object.needs_clear_cache(object_file)

		object_file.id!=undefined?object.id=object_file.id:null;
		object_file.type!=undefined?object.type=object_file.type:null;
		object_file.sub_type!=undefined?object.sub_type=object_file.sub_type:null;
		object_file.layer_index!=undefined?object.layer_index=object_file.layer_index:null;
		object_file.position!=undefined&&object_file.position!=null?object.position=deref(object_file.position):null;
		object_file.rotation!=undefined&&object_file.rotation!=null?object.rotation=object_file.rotation:null;
		object_file.width!=undefined&&object_file.width!=null?object.width=object_file.width:null;
		object_file.height!=undefined&&object_file.height!=null?object.height=object_file.height:null;
		object_file.opacity!=undefined&&object_file.opacity!=null?object.opacity=object_file.opacity:null;
		object_file.locked!=undefined?object.locked=object_file.locked:null;
		object_file.labels!=undefined?object.labels=deref(object_file.labels):null;
		object_file.user_labels!=undefined?object.user_labels=deref(object_file.user_labels):null;

		if(object_file.loader_image){
			object.loader_image = object_file.loader_image
		}

		if(object_file.text_details){
			for(var key in object.text_details){
				if(object_file.text_details[key]!=undefined){
					if(object_file.text_details[key].constructor.name == 'Array' || object_file.text_details[key].constructor.name == 'Object'){
						object.text_details[key] = deref(object_file.text_details[key])
					}else{
						object.text_details[key] = object_file.text_details[key]
					}
				}
			}
		}

		if(object_file.image_details){
			for(var key in object.image_details){
				if(object_file.image_details[key]!=undefined){
					if(object_file.image_details[key].constructor.name == 'Array' || object_file.image_details[key].constructor.name == 'Object'){
						object.image_details[key] = deref(object_file.image_details[key])
					}else{
						object.image_details[key] = object_file.image_details[key]
					}
				}
			}
		}

		if(object_file.mockup_details){
			for(var key in object.mockup_details){
				if(object_file.mockup_details[key]!=undefined){
					if(object_file.mockup_details[key].constructor.name == 'Array' || object_file.mockup_details[key].constructor.name == 'Object'){
						object.mockup_details[key] = deref(object_file.mockup_details[key])
					}else{
						object.mockup_details[key] = object_file.mockup_details[key]
					}
				}
			}
		}

		if(object_file.filter){
			for(var key in object.filter){
				if(object_file.filter[key]!=undefined){
					object.filter[key] = object_file.filter[key]
				}
			}
		}

		if(object_file.bgremoval){
			for(var key in object.bgremoval){
				if(object_file.bgremoval[key]!=undefined){
					object.bgremoval[key] = object_file.bgremoval[key]
				}
			}
		}

		if(object_file.group_details){
			object.group_details.object_data = [];
			for (var i = 0; i < object_file.group_details.object_data.length; i++) {
				object.group_details.object_data[i] = {}
				for(var key in object_file.group_details.object_data[i]){
					object.group_details.object_data[i] = JSON.parse(JSON.stringify(object_file.group_details.object_data[i]))
				}

				object.group_details.object_data[i].object = design.findObjectById(object.group_details.object_data[i].object);
			}

			for (var i = 0; i < object.group_details.object_data.length; i++) {
				if(!object.group_details.object_data[i].object){
					_.pullAt(object.group_details.object_data,i)
					i-=1;
				}
			}
		}

		if(object_file.grid_details && object_file.grid_details.boxes){
			object.grid_details.boxes = []
			for (var i = 0; i < object_file.grid_details.boxes.length; i++) {
				object.grid_details.boxes[i] = {
					position: deref(object_file.grid_details.boxes[i].position),
					width: object_file.grid_details.boxes[i].width,
					height: object_file.grid_details.boxes[i].height,
					color: object_file.grid_details.boxes[i].color,
					master: object,
					vertices:[]
				}

				if(object_file.grid_details.boxes[i].loader_image){
					object.grid_details.boxes[i].loader_image = object_file.grid_details.boxes[i].loader_image
				}
				if(object_file.grid_details.boxes[i].loader_image_frame){
					object.grid_details.boxes[i].loader_image_frame = object_file.grid_details.boxes[i].loader_image_frame
				}

				if(object_file.grid_details.boxes[i].image){
					object.grid_details.boxes[i].image = new designObject(design);
					object.grid_details.boxes[i].image.master = object.grid_details.boxes[i];
					object.grid_details.boxes[i].image.load(object_file.grid_details.boxes[i].image,true)
				}

				if(object_file.grid_details.boxes[i].frame){
					object.grid_details.boxes[i].frame = new designObject(design);
					object.grid_details.boxes[i].frame.load(object_file.grid_details.boxes[i].frame,true)
				}
			}

			object.updateGridBoxes()
		}

		if(!dont_check_clear_cache && needs_clear_cache){
			var image_cache_id = object.image_cache_id()
			var load_promise = design.loadImage(object)
			design.master.resource_promise_array.push(load_promise);
			load_promise
			.then(function(){
				object.set_redraw()
				design.needs_redraw = true
			})
		}

		if(needs_needs_redraw){
			object.set_redraw()
		}
	}

	//methods for group objects
	this.setGroupFromObjects = function(objects,dont_remove_old_groups){
		if(objects.length == 0){
			return
		}
		var all_vertices = [];
		for (var i = 0; i < objects.length; i++) {
			var vertices = objects[i].getVertices();
			all_vertices = all_vertices.concat(vertices);
		}

		if(!dont_remove_old_groups){
			var old_groups = []
			for (var i = 0; i < objects.length; i++) {
				var gp = objects[i].getGroup()
				if(gp && old_groups.indexOf(gp)==-1){
					old_groups.push(gp)
				}
			}

			for (var i = 0; i < old_groups.length; i++) {
				old_groups[i].ungroup()
			}
		}

		var bbox = utils.get2dBoundingBox(all_vertices);

		object.position.x = bbox.minX;
		object.position.y = bbox.minY;
		object.width = (bbox.maxX - bbox.minX);
		object.height = (bbox.maxY - bbox.minY);
		object.rotation = 0;

		object.group_details.object_data = [];
		var vertices = object.getVertices();
		for (var i = 0; i < objects.length; i++) {
			object.group_details.object_data[i] = {};
			object.group_details.object_data[i].object = objects[i];
			object.group_details.object_data[i].vertices_in_percent = objects[i].getVertices().map(function(o){
				var point = {x:0,y:0};
				var x_distance = utils.pointDistanceFromLine( o.x, o.y, vertices[0].x, vertices[0].y, vertices[3].x, vertices[3].y )
				var y_distance = utils.pointDistanceFromLine( o.x, o.y, vertices[0].x, vertices[0].y, vertices[1].x, vertices[1].y )
				point.x = ((x_distance/object.width)*100)
				point.y = ((y_distance/object.height)*100)
				return point
			})
		}
	}

	this.updateGroupObjects = function(){
		var object_data = object.group_details.object_data
		var vertices = object.getVertices();
		var x_angle = Math.atan2(vertices[1].y - vertices[0].y,vertices[1].x - vertices[0].x);
		var y_angle = Math.atan2(vertices[3].y - vertices[0].y,vertices[3].x - vertices[0].x);
		for (var i = 0; i < object_data.length; i++) {
			var new_vertices = object_data[i].vertices_in_percent.map(function(o){
				var point = {x:vertices[0].x,y:vertices[0].y};
				
				var x_distance = (o.x/100)*object.width;
				var y_distance = (o.y/100)*object.height;

				point.x += (Math.cos(x_angle)*x_distance)
				point.y += (Math.sin(x_angle)*x_distance)

				point.x += (Math.cos(y_angle)*y_distance)
				point.y += (Math.sin(y_angle)*y_distance)

				return point;
			})
			object_data[i].object.applyVertices(new_vertices);
			if(object_data[i].object.type == 'group'){
				object_data[i].object.updateGroupObjects();
			}
		}
	}

	this.getGroup = function(){
		var groups = design.groups
		if(design.temporary_group){
			groups = groups.concat(design.temporary_group)
		}

		for (var i = 0; i < groups.length; i++) {
			if(_.findIndex(groups[i].group_details.object_data,function(o){return o.object == object})>-1){
				return groups[i];
			}
		}

		return null;
	}
}


function hexToBase64(str) {
    return btoa(String.fromCharCode.apply(null, str.replace(/\r|\n/g, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")));
}

function applyImageFilter(canvas,filter){
	try{
		if(!filter){
			return
		}
		if(canvas.width == 0 || canvas.height == 0){
			return
		}

		var context = canvas.getContext('2d');

		if(filter.brightness || filter.contrast || filter.blur != 0 || filter.saturation){
			var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
			
			if(filter.brightness || filter.contrast){
				imageData = ImageFilters.BrightnessContrastGimp(imageData,filter.brightness/2,filter.contrast/2);
			}

			if(filter.blur > 0){
				imageData = ImageFilters.BoxBlur(imageData,1,1,filter.blur/2);
			}else if(filter.blur < 0){
				imageData = ImageFilters.Sharpen(imageData,Math.abs(filter.blur/10));
			}

			if(filter.saturation){
				imageData = saturateImage(imageData,filter.saturation/100)
			}

			context.putImageData(imageData, 0, 0);
		}

		// if(filter.tint){
		// 	var h = (filter.tint*(360/200)) + 180
		// 	context.globalCompositeOperation = 'hue'
		// 	context.fillStyle = 'hsla(' + h + ',100%,50%)'
		// 	context.fillRect(0,0,canvas.width,canvas.height)	
		// 	context.globalCompositeOperation = 'source-over'
		// }

		if(filter.tint){
			var h = (filter.tint*(360/200)) + 180
			var oldAlpha = context.globalAlpha
			context.globalCompositeOperation = 'source-over'
			context.fillStyle = 'hsla(' + h + ',100%,50%)'
			context.globalAlpha = 0.1
			context.fillRect(0,0,canvas.width,canvas.height)	
			context.globalCompositeOperation = 'source-over'
			context.globalAlpha = oldAlpha
		}

		if(filter.vignette){
			var width = canvas.width, height = canvas.height;
			var gradient;
			var radius = Math.sqrt( Math.pow(width/2, 2) + Math.pow(height/2, 2) );
			
			gradient = context.createRadialGradient(width/2, height/2, 0, width/2, height/2, radius);
			gradient.addColorStop(0, 'rgba(0,0,0,0)');
			gradient.addColorStop(0.5, 'rgba(0,0,0,0)');
			gradient.addColorStop(1, 'rgba(0,0,0,' + (filter.vignette/100) + ')');
			context.fillStyle = gradient;
			context.fillRect(0, 0, width, height);
		}

	}catch(err){
		console.log(err);
	}

}

function saturateImage (pixels, value) {
    var d = pixels.data;
    for (var i = 0; i < d.length; i += 4) {
        var r = d[i]; 
        var g = d[i + 1];
        var b = d[i + 2];
        var gray = 0.2989*r + 0.5870*g + 0.1140*b; //weights from CCIR 601 spec
        d[i] = -gray * value + d[i] * (1+value);
        d[i+1] = -gray * value + d[i+1] * (1+value);
        d[i+2] = -gray * value + d[i+2] * (1+value);
        //normalize over- and under-saturated values
        if(d[i] > 255) d[i] = 255;
        if(d[i+1] > 255) d[i] = 255;
        if(d[i+2] > 255) d[i] = 255;
        if(d[i] < 0) d[i] = 0;
        if(d[i+1] < 0) d[i] = 0;
        if(d[i+2] < 0) d[i] = 0;
    }
    return pixels;
};

function VignetteFilter(input,value){
	var width = input.width, height = input.height;
	var inputData = input.data;
	var outputData = [];
	var amount = value
	var canvas = document.createElement("canvas");
	canvas.width = width;
	canvas.height = height;
	var context = canvas.getContext("2d");
	var gradient;
	var radius = Math.sqrt( Math.pow(width/2, 2) + Math.pow(height/2, 2) );
	context.putImageData(input,0,0);
	context.globalCompositeOperation = 'source-over';
	
	gradient = context.createRadialGradient(width/2, height/2, 0, width/2, height/2, radius);
	gradient.addColorStop(0, 'rgba(0,0,0,0)');
	gradient.addColorStop(0.5, 'rgba(0,0,0,0)');
	gradient.addColorStop(1, 'rgba(0,0,0,' + amount + ')');
	context.fillStyle = gradient;
	context.fillRect(0, 0, width, height);
	outputData = context.getImageData(0,0,width,height).data;
	for(var k = 0; k < outputData.length; k++){
		inputData[k] = outputData[k];
	}
}